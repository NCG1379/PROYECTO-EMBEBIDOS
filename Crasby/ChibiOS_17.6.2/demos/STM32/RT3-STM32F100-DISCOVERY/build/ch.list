
build/ch.elf:     file format elf32-littlearm


Disassembly of section .text:

08000180 <Reset_Handler>:
 8000180:	b672      	cpsid	i
 8000182:	4825      	ldr	r0, [pc, #148]	; (8000218 <endfiniloop+0x4>)
 8000184:	f380 8809 	msr	PSP, r0
 8000188:	4824      	ldr	r0, [pc, #144]	; (800021c <endfiniloop+0x8>)
 800018a:	f64e 5108 	movw	r1, #60680	; 0xed08
 800018e:	f2ce 0100 	movt	r1, #57344	; 0xe000
 8000192:	6008      	str	r0, [r1, #0]
 8000194:	2002      	movs	r0, #2
 8000196:	f380 8814 	msr	CONTROL, r0
 800019a:	f3bf 8f6f 	isb	sy
 800019e:	f001 f85f 	bl	8001260 <__core_init>
 80001a2:	f000 ff7d 	bl	80010a0 <__early_init>
 80001a6:	481e      	ldr	r0, [pc, #120]	; (8000220 <endfiniloop+0xc>)
 80001a8:	491e      	ldr	r1, [pc, #120]	; (8000224 <endfiniloop+0x10>)
 80001aa:	4a1f      	ldr	r2, [pc, #124]	; (8000228 <endfiniloop+0x14>)

080001ac <msloop>:
 80001ac:	4291      	cmp	r1, r2
 80001ae:	bf3c      	itt	cc
 80001b0:	f841 0b04 	strcc.w	r0, [r1], #4
 80001b4:	e7fa      	bcc.n	80001ac <msloop>
 80001b6:	491d      	ldr	r1, [pc, #116]	; (800022c <endfiniloop+0x18>)
 80001b8:	4a17      	ldr	r2, [pc, #92]	; (8000218 <endfiniloop+0x4>)

080001ba <psloop>:
 80001ba:	4291      	cmp	r1, r2
 80001bc:	bf3c      	itt	cc
 80001be:	f841 0b04 	strcc.w	r0, [r1], #4
 80001c2:	e7fa      	bcc.n	80001ba <psloop>
 80001c4:	491a      	ldr	r1, [pc, #104]	; (8000230 <endfiniloop+0x1c>)
 80001c6:	4a1b      	ldr	r2, [pc, #108]	; (8000234 <endfiniloop+0x20>)
 80001c8:	4b1b      	ldr	r3, [pc, #108]	; (8000238 <endfiniloop+0x24>)

080001ca <dloop>:
 80001ca:	429a      	cmp	r2, r3
 80001cc:	bf3e      	ittt	cc
 80001ce:	f851 0b04 	ldrcc.w	r0, [r1], #4
 80001d2:	f842 0b04 	strcc.w	r0, [r2], #4
 80001d6:	e7f8      	bcc.n	80001ca <dloop>
 80001d8:	2000      	movs	r0, #0
 80001da:	4918      	ldr	r1, [pc, #96]	; (800023c <endfiniloop+0x28>)
 80001dc:	4a18      	ldr	r2, [pc, #96]	; (8000240 <endfiniloop+0x2c>)

080001de <bloop>:
 80001de:	4291      	cmp	r1, r2
 80001e0:	bf3c      	itt	cc
 80001e2:	f841 0b04 	strcc.w	r0, [r1], #4
 80001e6:	e7fa      	bcc.n	80001de <bloop>
 80001e8:	f000 fffa 	bl	80011e0 <__init_ram_areas>
 80001ec:	f001 f830 	bl	8001250 <__late_init>
 80001f0:	4c14      	ldr	r4, [pc, #80]	; (8000244 <endfiniloop+0x30>)
 80001f2:	4d15      	ldr	r5, [pc, #84]	; (8000248 <endfiniloop+0x34>)

080001f4 <initloop>:
 80001f4:	42ac      	cmp	r4, r5
 80001f6:	da03      	bge.n	8000200 <endinitloop>
 80001f8:	f854 1b04 	ldr.w	r1, [r4], #4
 80001fc:	4788      	blx	r1
 80001fe:	e7f9      	b.n	80001f4 <initloop>

08000200 <endinitloop>:
 8000200:	f002 f97e 	bl	8002500 <main>
 8000204:	4c11      	ldr	r4, [pc, #68]	; (800024c <endfiniloop+0x38>)
 8000206:	4d12      	ldr	r5, [pc, #72]	; (8000250 <endfiniloop+0x3c>)

08000208 <finiloop>:
 8000208:	42ac      	cmp	r4, r5
 800020a:	da03      	bge.n	8000214 <endfiniloop>
 800020c:	f854 1b04 	ldr.w	r1, [r4], #4
 8000210:	4788      	blx	r1
 8000212:	e7f9      	b.n	8000208 <finiloop>

08000214 <endfiniloop>:
 8000214:	f001 b814 	b.w	8001240 <__default_exit>
 8000218:	20000800 	.word	0x20000800
 800021c:	08000000 	.word	0x08000000
 8000220:	55555555 	.word	0x55555555
 8000224:	20000000 	.word	0x20000000
 8000228:	20000400 	.word	0x20000400
 800022c:	20000400 	.word	0x20000400
 8000230:	08002ea8 	.word	0x08002ea8
 8000234:	20000800 	.word	0x20000800
 8000238:	20000818 	.word	0x20000818
 800023c:	20000818 	.word	0x20000818
 8000240:	20000b0c 	.word	0x20000b0c
 8000244:	08000180 	.word	0x08000180
 8000248:	08000180 	.word	0x08000180
 800024c:	08000180 	.word	0x08000180
 8000250:	08000180 	.word	0x08000180

08000254 <_port_switch>:
 8000254:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 8000258:	f8c1 d00c 	str.w	sp, [r1, #12]
 800025c:	68c3      	ldr	r3, [r0, #12]
 800025e:	469d      	mov	sp, r3
 8000260:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}

08000264 <_port_thread_start>:
 8000264:	2300      	movs	r3, #0
 8000266:	f383 8811 	msr	BASEPRI, r3
 800026a:	4628      	mov	r0, r5
 800026c:	47a0      	blx	r4
 800026e:	2000      	movs	r0, #0
 8000270:	f000 ff66 	bl	8001140 <chThdExit>

08000274 <_port_switch_from_isr>:
 8000274:	f000 ff94 	bl	80011a0 <chSchDoReschedule>

08000278 <_port_exit_from_isr>:
 8000278:	df00      	svc	0
 800027a:	e7fe      	b.n	800027a <_port_exit_from_isr+0x2>

0800027c <__aeabi_drsub>:
 800027c:	f081 4100 	eor.w	r1, r1, #2147483648	; 0x80000000
 8000280:	e002      	b.n	8000288 <__adddf3>
 8000282:	bf00      	nop

08000284 <__aeabi_dsub>:
 8000284:	f083 4300 	eor.w	r3, r3, #2147483648	; 0x80000000

08000288 <__adddf3>:
 8000288:	b530      	push	{r4, r5, lr}
 800028a:	ea4f 0441 	mov.w	r4, r1, lsl #1
 800028e:	ea4f 0543 	mov.w	r5, r3, lsl #1
 8000292:	ea94 0f05 	teq	r4, r5
 8000296:	bf08      	it	eq
 8000298:	ea90 0f02 	teqeq	r0, r2
 800029c:	bf1f      	itttt	ne
 800029e:	ea54 0c00 	orrsne.w	ip, r4, r0
 80002a2:	ea55 0c02 	orrsne.w	ip, r5, r2
 80002a6:	ea7f 5c64 	mvnsne.w	ip, r4, asr #21
 80002aa:	ea7f 5c65 	mvnsne.w	ip, r5, asr #21
 80002ae:	f000 80e2 	beq.w	8000476 <__adddf3+0x1ee>
 80002b2:	ea4f 5454 	mov.w	r4, r4, lsr #21
 80002b6:	ebd4 5555 	rsbs	r5, r4, r5, lsr #21
 80002ba:	bfb8      	it	lt
 80002bc:	426d      	neglt	r5, r5
 80002be:	dd0c      	ble.n	80002da <__adddf3+0x52>
 80002c0:	442c      	add	r4, r5
 80002c2:	ea80 0202 	eor.w	r2, r0, r2
 80002c6:	ea81 0303 	eor.w	r3, r1, r3
 80002ca:	ea82 0000 	eor.w	r0, r2, r0
 80002ce:	ea83 0101 	eor.w	r1, r3, r1
 80002d2:	ea80 0202 	eor.w	r2, r0, r2
 80002d6:	ea81 0303 	eor.w	r3, r1, r3
 80002da:	2d36      	cmp	r5, #54	; 0x36
 80002dc:	bf88      	it	hi
 80002de:	bd30      	pophi	{r4, r5, pc}
 80002e0:	f011 4f00 	tst.w	r1, #2147483648	; 0x80000000
 80002e4:	ea4f 3101 	mov.w	r1, r1, lsl #12
 80002e8:	f44f 1c80 	mov.w	ip, #1048576	; 0x100000
 80002ec:	ea4c 3111 	orr.w	r1, ip, r1, lsr #12
 80002f0:	d002      	beq.n	80002f8 <__adddf3+0x70>
 80002f2:	4240      	negs	r0, r0
 80002f4:	eb61 0141 	sbc.w	r1, r1, r1, lsl #1
 80002f8:	f013 4f00 	tst.w	r3, #2147483648	; 0x80000000
 80002fc:	ea4f 3303 	mov.w	r3, r3, lsl #12
 8000300:	ea4c 3313 	orr.w	r3, ip, r3, lsr #12
 8000304:	d002      	beq.n	800030c <__adddf3+0x84>
 8000306:	4252      	negs	r2, r2
 8000308:	eb63 0343 	sbc.w	r3, r3, r3, lsl #1
 800030c:	ea94 0f05 	teq	r4, r5
 8000310:	f000 80a7 	beq.w	8000462 <__adddf3+0x1da>
 8000314:	f1a4 0401 	sub.w	r4, r4, #1
 8000318:	f1d5 0e20 	rsbs	lr, r5, #32
 800031c:	db0d      	blt.n	800033a <__adddf3+0xb2>
 800031e:	fa02 fc0e 	lsl.w	ip, r2, lr
 8000322:	fa22 f205 	lsr.w	r2, r2, r5
 8000326:	1880      	adds	r0, r0, r2
 8000328:	f141 0100 	adc.w	r1, r1, #0
 800032c:	fa03 f20e 	lsl.w	r2, r3, lr
 8000330:	1880      	adds	r0, r0, r2
 8000332:	fa43 f305 	asr.w	r3, r3, r5
 8000336:	4159      	adcs	r1, r3
 8000338:	e00e      	b.n	8000358 <__adddf3+0xd0>
 800033a:	f1a5 0520 	sub.w	r5, r5, #32
 800033e:	f10e 0e20 	add.w	lr, lr, #32
 8000342:	2a01      	cmp	r2, #1
 8000344:	fa03 fc0e 	lsl.w	ip, r3, lr
 8000348:	bf28      	it	cs
 800034a:	f04c 0c02 	orrcs.w	ip, ip, #2
 800034e:	fa43 f305 	asr.w	r3, r3, r5
 8000352:	18c0      	adds	r0, r0, r3
 8000354:	eb51 71e3 	adcs.w	r1, r1, r3, asr #31
 8000358:	f001 4500 	and.w	r5, r1, #2147483648	; 0x80000000
 800035c:	d507      	bpl.n	800036e <__adddf3+0xe6>
 800035e:	f04f 0e00 	mov.w	lr, #0
 8000362:	f1dc 0c00 	rsbs	ip, ip, #0
 8000366:	eb7e 0000 	sbcs.w	r0, lr, r0
 800036a:	eb6e 0101 	sbc.w	r1, lr, r1
 800036e:	f5b1 1f80 	cmp.w	r1, #1048576	; 0x100000
 8000372:	d31b      	bcc.n	80003ac <__adddf3+0x124>
 8000374:	f5b1 1f00 	cmp.w	r1, #2097152	; 0x200000
 8000378:	d30c      	bcc.n	8000394 <__adddf3+0x10c>
 800037a:	0849      	lsrs	r1, r1, #1
 800037c:	ea5f 0030 	movs.w	r0, r0, rrx
 8000380:	ea4f 0c3c 	mov.w	ip, ip, rrx
 8000384:	f104 0401 	add.w	r4, r4, #1
 8000388:	ea4f 5244 	mov.w	r2, r4, lsl #21
 800038c:	f512 0f80 	cmn.w	r2, #4194304	; 0x400000
 8000390:	f080 809a 	bcs.w	80004c8 <__adddf3+0x240>
 8000394:	f1bc 4f00 	cmp.w	ip, #2147483648	; 0x80000000
 8000398:	bf08      	it	eq
 800039a:	ea5f 0c50 	movseq.w	ip, r0, lsr #1
 800039e:	f150 0000 	adcs.w	r0, r0, #0
 80003a2:	eb41 5104 	adc.w	r1, r1, r4, lsl #20
 80003a6:	ea41 0105 	orr.w	r1, r1, r5
 80003aa:	bd30      	pop	{r4, r5, pc}
 80003ac:	ea5f 0c4c 	movs.w	ip, ip, lsl #1
 80003b0:	4140      	adcs	r0, r0
 80003b2:	eb41 0101 	adc.w	r1, r1, r1
 80003b6:	f411 1f80 	tst.w	r1, #1048576	; 0x100000
 80003ba:	f1a4 0401 	sub.w	r4, r4, #1
 80003be:	d1e9      	bne.n	8000394 <__adddf3+0x10c>
 80003c0:	f091 0f00 	teq	r1, #0
 80003c4:	bf04      	itt	eq
 80003c6:	4601      	moveq	r1, r0
 80003c8:	2000      	moveq	r0, #0
 80003ca:	fab1 f381 	clz	r3, r1
 80003ce:	bf08      	it	eq
 80003d0:	3320      	addeq	r3, #32
 80003d2:	f1a3 030b 	sub.w	r3, r3, #11
 80003d6:	f1b3 0220 	subs.w	r2, r3, #32
 80003da:	da0c      	bge.n	80003f6 <__adddf3+0x16e>
 80003dc:	320c      	adds	r2, #12
 80003de:	dd08      	ble.n	80003f2 <__adddf3+0x16a>
 80003e0:	f102 0c14 	add.w	ip, r2, #20
 80003e4:	f1c2 020c 	rsb	r2, r2, #12
 80003e8:	fa01 f00c 	lsl.w	r0, r1, ip
 80003ec:	fa21 f102 	lsr.w	r1, r1, r2
 80003f0:	e00c      	b.n	800040c <__adddf3+0x184>
 80003f2:	f102 0214 	add.w	r2, r2, #20
 80003f6:	bfd8      	it	le
 80003f8:	f1c2 0c20 	rsble	ip, r2, #32
 80003fc:	fa01 f102 	lsl.w	r1, r1, r2
 8000400:	fa20 fc0c 	lsr.w	ip, r0, ip
 8000404:	bfdc      	itt	le
 8000406:	ea41 010c 	orrle.w	r1, r1, ip
 800040a:	4090      	lslle	r0, r2
 800040c:	1ae4      	subs	r4, r4, r3
 800040e:	bfa2      	ittt	ge
 8000410:	eb01 5104 	addge.w	r1, r1, r4, lsl #20
 8000414:	4329      	orrge	r1, r5
 8000416:	bd30      	popge	{r4, r5, pc}
 8000418:	ea6f 0404 	mvn.w	r4, r4
 800041c:	3c1f      	subs	r4, #31
 800041e:	da1c      	bge.n	800045a <__adddf3+0x1d2>
 8000420:	340c      	adds	r4, #12
 8000422:	dc0e      	bgt.n	8000442 <__adddf3+0x1ba>
 8000424:	f104 0414 	add.w	r4, r4, #20
 8000428:	f1c4 0220 	rsb	r2, r4, #32
 800042c:	fa20 f004 	lsr.w	r0, r0, r4
 8000430:	fa01 f302 	lsl.w	r3, r1, r2
 8000434:	ea40 0003 	orr.w	r0, r0, r3
 8000438:	fa21 f304 	lsr.w	r3, r1, r4
 800043c:	ea45 0103 	orr.w	r1, r5, r3
 8000440:	bd30      	pop	{r4, r5, pc}
 8000442:	f1c4 040c 	rsb	r4, r4, #12
 8000446:	f1c4 0220 	rsb	r2, r4, #32
 800044a:	fa20 f002 	lsr.w	r0, r0, r2
 800044e:	fa01 f304 	lsl.w	r3, r1, r4
 8000452:	ea40 0003 	orr.w	r0, r0, r3
 8000456:	4629      	mov	r1, r5
 8000458:	bd30      	pop	{r4, r5, pc}
 800045a:	fa21 f004 	lsr.w	r0, r1, r4
 800045e:	4629      	mov	r1, r5
 8000460:	bd30      	pop	{r4, r5, pc}
 8000462:	f094 0f00 	teq	r4, #0
 8000466:	f483 1380 	eor.w	r3, r3, #1048576	; 0x100000
 800046a:	bf06      	itte	eq
 800046c:	f481 1180 	eoreq.w	r1, r1, #1048576	; 0x100000
 8000470:	3401      	addeq	r4, #1
 8000472:	3d01      	subne	r5, #1
 8000474:	e74e      	b.n	8000314 <__adddf3+0x8c>
 8000476:	ea7f 5c64 	mvns.w	ip, r4, asr #21
 800047a:	bf18      	it	ne
 800047c:	ea7f 5c65 	mvnsne.w	ip, r5, asr #21
 8000480:	d029      	beq.n	80004d6 <__adddf3+0x24e>
 8000482:	ea94 0f05 	teq	r4, r5
 8000486:	bf08      	it	eq
 8000488:	ea90 0f02 	teqeq	r0, r2
 800048c:	d005      	beq.n	800049a <__adddf3+0x212>
 800048e:	ea54 0c00 	orrs.w	ip, r4, r0
 8000492:	bf04      	itt	eq
 8000494:	4619      	moveq	r1, r3
 8000496:	4610      	moveq	r0, r2
 8000498:	bd30      	pop	{r4, r5, pc}
 800049a:	ea91 0f03 	teq	r1, r3
 800049e:	bf1e      	ittt	ne
 80004a0:	2100      	movne	r1, #0
 80004a2:	2000      	movne	r0, #0
 80004a4:	bd30      	popne	{r4, r5, pc}
 80004a6:	ea5f 5c54 	movs.w	ip, r4, lsr #21
 80004aa:	d105      	bne.n	80004b8 <__adddf3+0x230>
 80004ac:	0040      	lsls	r0, r0, #1
 80004ae:	4149      	adcs	r1, r1
 80004b0:	bf28      	it	cs
 80004b2:	f041 4100 	orrcs.w	r1, r1, #2147483648	; 0x80000000
 80004b6:	bd30      	pop	{r4, r5, pc}
 80004b8:	f514 0480 	adds.w	r4, r4, #4194304	; 0x400000
 80004bc:	bf3c      	itt	cc
 80004be:	f501 1180 	addcc.w	r1, r1, #1048576	; 0x100000
 80004c2:	bd30      	popcc	{r4, r5, pc}
 80004c4:	f001 4500 	and.w	r5, r1, #2147483648	; 0x80000000
 80004c8:	f045 41fe 	orr.w	r1, r5, #2130706432	; 0x7f000000
 80004cc:	f441 0170 	orr.w	r1, r1, #15728640	; 0xf00000
 80004d0:	f04f 0000 	mov.w	r0, #0
 80004d4:	bd30      	pop	{r4, r5, pc}
 80004d6:	ea7f 5c64 	mvns.w	ip, r4, asr #21
 80004da:	bf1a      	itte	ne
 80004dc:	4619      	movne	r1, r3
 80004de:	4610      	movne	r0, r2
 80004e0:	ea7f 5c65 	mvnseq.w	ip, r5, asr #21
 80004e4:	bf1c      	itt	ne
 80004e6:	460b      	movne	r3, r1
 80004e8:	4602      	movne	r2, r0
 80004ea:	ea50 3401 	orrs.w	r4, r0, r1, lsl #12
 80004ee:	bf06      	itte	eq
 80004f0:	ea52 3503 	orrseq.w	r5, r2, r3, lsl #12
 80004f4:	ea91 0f03 	teqeq	r1, r3
 80004f8:	f441 2100 	orrne.w	r1, r1, #524288	; 0x80000
 80004fc:	bd30      	pop	{r4, r5, pc}
 80004fe:	bf00      	nop

08000500 <__aeabi_ui2d>:
 8000500:	f090 0f00 	teq	r0, #0
 8000504:	bf04      	itt	eq
 8000506:	2100      	moveq	r1, #0
 8000508:	4770      	bxeq	lr
 800050a:	b530      	push	{r4, r5, lr}
 800050c:	f44f 6480 	mov.w	r4, #1024	; 0x400
 8000510:	f104 0432 	add.w	r4, r4, #50	; 0x32
 8000514:	f04f 0500 	mov.w	r5, #0
 8000518:	f04f 0100 	mov.w	r1, #0
 800051c:	e750      	b.n	80003c0 <__adddf3+0x138>
 800051e:	bf00      	nop

08000520 <__aeabi_i2d>:
 8000520:	f090 0f00 	teq	r0, #0
 8000524:	bf04      	itt	eq
 8000526:	2100      	moveq	r1, #0
 8000528:	4770      	bxeq	lr
 800052a:	b530      	push	{r4, r5, lr}
 800052c:	f44f 6480 	mov.w	r4, #1024	; 0x400
 8000530:	f104 0432 	add.w	r4, r4, #50	; 0x32
 8000534:	f010 4500 	ands.w	r5, r0, #2147483648	; 0x80000000
 8000538:	bf48      	it	mi
 800053a:	4240      	negmi	r0, r0
 800053c:	f04f 0100 	mov.w	r1, #0
 8000540:	e73e      	b.n	80003c0 <__adddf3+0x138>
 8000542:	bf00      	nop

08000544 <__aeabi_f2d>:
 8000544:	0042      	lsls	r2, r0, #1
 8000546:	ea4f 01e2 	mov.w	r1, r2, asr #3
 800054a:	ea4f 0131 	mov.w	r1, r1, rrx
 800054e:	ea4f 7002 	mov.w	r0, r2, lsl #28
 8000552:	bf1f      	itttt	ne
 8000554:	f012 437f 	andsne.w	r3, r2, #4278190080	; 0xff000000
 8000558:	f093 4f7f 	teqne	r3, #4278190080	; 0xff000000
 800055c:	f081 5160 	eorne.w	r1, r1, #939524096	; 0x38000000
 8000560:	4770      	bxne	lr
 8000562:	f092 0f00 	teq	r2, #0
 8000566:	bf14      	ite	ne
 8000568:	f093 4f7f 	teqne	r3, #4278190080	; 0xff000000
 800056c:	4770      	bxeq	lr
 800056e:	b530      	push	{r4, r5, lr}
 8000570:	f44f 7460 	mov.w	r4, #896	; 0x380
 8000574:	f001 4500 	and.w	r5, r1, #2147483648	; 0x80000000
 8000578:	f021 4100 	bic.w	r1, r1, #2147483648	; 0x80000000
 800057c:	e720      	b.n	80003c0 <__adddf3+0x138>
 800057e:	bf00      	nop

08000580 <__aeabi_ul2d>:
 8000580:	ea50 0201 	orrs.w	r2, r0, r1
 8000584:	bf08      	it	eq
 8000586:	4770      	bxeq	lr
 8000588:	b530      	push	{r4, r5, lr}
 800058a:	f04f 0500 	mov.w	r5, #0
 800058e:	e00a      	b.n	80005a6 <__aeabi_l2d+0x16>

08000590 <__aeabi_l2d>:
 8000590:	ea50 0201 	orrs.w	r2, r0, r1
 8000594:	bf08      	it	eq
 8000596:	4770      	bxeq	lr
 8000598:	b530      	push	{r4, r5, lr}
 800059a:	f011 4500 	ands.w	r5, r1, #2147483648	; 0x80000000
 800059e:	d502      	bpl.n	80005a6 <__aeabi_l2d+0x16>
 80005a0:	4240      	negs	r0, r0
 80005a2:	eb61 0141 	sbc.w	r1, r1, r1, lsl #1
 80005a6:	f44f 6480 	mov.w	r4, #1024	; 0x400
 80005aa:	f104 0432 	add.w	r4, r4, #50	; 0x32
 80005ae:	ea5f 5c91 	movs.w	ip, r1, lsr #22
 80005b2:	f43f aedc 	beq.w	800036e <__adddf3+0xe6>
 80005b6:	f04f 0203 	mov.w	r2, #3
 80005ba:	ea5f 0cdc 	movs.w	ip, ip, lsr #3
 80005be:	bf18      	it	ne
 80005c0:	3203      	addne	r2, #3
 80005c2:	ea5f 0cdc 	movs.w	ip, ip, lsr #3
 80005c6:	bf18      	it	ne
 80005c8:	3203      	addne	r2, #3
 80005ca:	eb02 02dc 	add.w	r2, r2, ip, lsr #3
 80005ce:	f1c2 0320 	rsb	r3, r2, #32
 80005d2:	fa00 fc03 	lsl.w	ip, r0, r3
 80005d6:	fa20 f002 	lsr.w	r0, r0, r2
 80005da:	fa01 fe03 	lsl.w	lr, r1, r3
 80005de:	ea40 000e 	orr.w	r0, r0, lr
 80005e2:	fa21 f102 	lsr.w	r1, r1, r2
 80005e6:	4414      	add	r4, r2
 80005e8:	e6c1      	b.n	800036e <__adddf3+0xe6>
 80005ea:	bf00      	nop

080005ec <__aeabi_dmul>:
 80005ec:	b570      	push	{r4, r5, r6, lr}
 80005ee:	f04f 0cff 	mov.w	ip, #255	; 0xff
 80005f2:	f44c 6ce0 	orr.w	ip, ip, #1792	; 0x700
 80005f6:	ea1c 5411 	ands.w	r4, ip, r1, lsr #20
 80005fa:	bf1d      	ittte	ne
 80005fc:	ea1c 5513 	andsne.w	r5, ip, r3, lsr #20
 8000600:	ea94 0f0c 	teqne	r4, ip
 8000604:	ea95 0f0c 	teqne	r5, ip
 8000608:	f000 f8de 	bleq	80007c8 <__aeabi_dmul+0x1dc>
 800060c:	442c      	add	r4, r5
 800060e:	ea81 0603 	eor.w	r6, r1, r3
 8000612:	ea21 514c 	bic.w	r1, r1, ip, lsl #21
 8000616:	ea23 534c 	bic.w	r3, r3, ip, lsl #21
 800061a:	ea50 3501 	orrs.w	r5, r0, r1, lsl #12
 800061e:	bf18      	it	ne
 8000620:	ea52 3503 	orrsne.w	r5, r2, r3, lsl #12
 8000624:	f441 1180 	orr.w	r1, r1, #1048576	; 0x100000
 8000628:	f443 1380 	orr.w	r3, r3, #1048576	; 0x100000
 800062c:	d038      	beq.n	80006a0 <__aeabi_dmul+0xb4>
 800062e:	fba0 ce02 	umull	ip, lr, r0, r2
 8000632:	f04f 0500 	mov.w	r5, #0
 8000636:	fbe1 e502 	umlal	lr, r5, r1, r2
 800063a:	f006 4200 	and.w	r2, r6, #2147483648	; 0x80000000
 800063e:	fbe0 e503 	umlal	lr, r5, r0, r3
 8000642:	f04f 0600 	mov.w	r6, #0
 8000646:	fbe1 5603 	umlal	r5, r6, r1, r3
 800064a:	f09c 0f00 	teq	ip, #0
 800064e:	bf18      	it	ne
 8000650:	f04e 0e01 	orrne.w	lr, lr, #1
 8000654:	f1a4 04ff 	sub.w	r4, r4, #255	; 0xff
 8000658:	f5b6 7f00 	cmp.w	r6, #512	; 0x200
 800065c:	f564 7440 	sbc.w	r4, r4, #768	; 0x300
 8000660:	d204      	bcs.n	800066c <__aeabi_dmul+0x80>
 8000662:	ea5f 0e4e 	movs.w	lr, lr, lsl #1
 8000666:	416d      	adcs	r5, r5
 8000668:	eb46 0606 	adc.w	r6, r6, r6
 800066c:	ea42 21c6 	orr.w	r1, r2, r6, lsl #11
 8000670:	ea41 5155 	orr.w	r1, r1, r5, lsr #21
 8000674:	ea4f 20c5 	mov.w	r0, r5, lsl #11
 8000678:	ea40 505e 	orr.w	r0, r0, lr, lsr #21
 800067c:	ea4f 2ece 	mov.w	lr, lr, lsl #11
 8000680:	f1b4 0cfd 	subs.w	ip, r4, #253	; 0xfd
 8000684:	bf88      	it	hi
 8000686:	f5bc 6fe0 	cmphi.w	ip, #1792	; 0x700
 800068a:	d81e      	bhi.n	80006ca <__aeabi_dmul+0xde>
 800068c:	f1be 4f00 	cmp.w	lr, #2147483648	; 0x80000000
 8000690:	bf08      	it	eq
 8000692:	ea5f 0e50 	movseq.w	lr, r0, lsr #1
 8000696:	f150 0000 	adcs.w	r0, r0, #0
 800069a:	eb41 5104 	adc.w	r1, r1, r4, lsl #20
 800069e:	bd70      	pop	{r4, r5, r6, pc}
 80006a0:	f006 4600 	and.w	r6, r6, #2147483648	; 0x80000000
 80006a4:	ea46 0101 	orr.w	r1, r6, r1
 80006a8:	ea40 0002 	orr.w	r0, r0, r2
 80006ac:	ea81 0103 	eor.w	r1, r1, r3
 80006b0:	ebb4 045c 	subs.w	r4, r4, ip, lsr #1
 80006b4:	bfc2      	ittt	gt
 80006b6:	ebd4 050c 	rsbsgt	r5, r4, ip
 80006ba:	ea41 5104 	orrgt.w	r1, r1, r4, lsl #20
 80006be:	bd70      	popgt	{r4, r5, r6, pc}
 80006c0:	f441 1180 	orr.w	r1, r1, #1048576	; 0x100000
 80006c4:	f04f 0e00 	mov.w	lr, #0
 80006c8:	3c01      	subs	r4, #1
 80006ca:	f300 80ab 	bgt.w	8000824 <__aeabi_dmul+0x238>
 80006ce:	f114 0f36 	cmn.w	r4, #54	; 0x36
 80006d2:	bfde      	ittt	le
 80006d4:	2000      	movle	r0, #0
 80006d6:	f001 4100 	andle.w	r1, r1, #2147483648	; 0x80000000
 80006da:	bd70      	pople	{r4, r5, r6, pc}
 80006dc:	f1c4 0400 	rsb	r4, r4, #0
 80006e0:	3c20      	subs	r4, #32
 80006e2:	da35      	bge.n	8000750 <__aeabi_dmul+0x164>
 80006e4:	340c      	adds	r4, #12
 80006e6:	dc1b      	bgt.n	8000720 <__aeabi_dmul+0x134>
 80006e8:	f104 0414 	add.w	r4, r4, #20
 80006ec:	f1c4 0520 	rsb	r5, r4, #32
 80006f0:	fa00 f305 	lsl.w	r3, r0, r5
 80006f4:	fa20 f004 	lsr.w	r0, r0, r4
 80006f8:	fa01 f205 	lsl.w	r2, r1, r5
 80006fc:	ea40 0002 	orr.w	r0, r0, r2
 8000700:	f001 4200 	and.w	r2, r1, #2147483648	; 0x80000000
 8000704:	f021 4100 	bic.w	r1, r1, #2147483648	; 0x80000000
 8000708:	eb10 70d3 	adds.w	r0, r0, r3, lsr #31
 800070c:	fa21 f604 	lsr.w	r6, r1, r4
 8000710:	eb42 0106 	adc.w	r1, r2, r6
 8000714:	ea5e 0e43 	orrs.w	lr, lr, r3, lsl #1
 8000718:	bf08      	it	eq
 800071a:	ea20 70d3 	biceq.w	r0, r0, r3, lsr #31
 800071e:	bd70      	pop	{r4, r5, r6, pc}
 8000720:	f1c4 040c 	rsb	r4, r4, #12
 8000724:	f1c4 0520 	rsb	r5, r4, #32
 8000728:	fa00 f304 	lsl.w	r3, r0, r4
 800072c:	fa20 f005 	lsr.w	r0, r0, r5
 8000730:	fa01 f204 	lsl.w	r2, r1, r4
 8000734:	ea40 0002 	orr.w	r0, r0, r2
 8000738:	f001 4100 	and.w	r1, r1, #2147483648	; 0x80000000
 800073c:	eb10 70d3 	adds.w	r0, r0, r3, lsr #31
 8000740:	f141 0100 	adc.w	r1, r1, #0
 8000744:	ea5e 0e43 	orrs.w	lr, lr, r3, lsl #1
 8000748:	bf08      	it	eq
 800074a:	ea20 70d3 	biceq.w	r0, r0, r3, lsr #31
 800074e:	bd70      	pop	{r4, r5, r6, pc}
 8000750:	f1c4 0520 	rsb	r5, r4, #32
 8000754:	fa00 f205 	lsl.w	r2, r0, r5
 8000758:	ea4e 0e02 	orr.w	lr, lr, r2
 800075c:	fa20 f304 	lsr.w	r3, r0, r4
 8000760:	fa01 f205 	lsl.w	r2, r1, r5
 8000764:	ea43 0302 	orr.w	r3, r3, r2
 8000768:	fa21 f004 	lsr.w	r0, r1, r4
 800076c:	f001 4100 	and.w	r1, r1, #2147483648	; 0x80000000
 8000770:	fa21 f204 	lsr.w	r2, r1, r4
 8000774:	ea20 0002 	bic.w	r0, r0, r2
 8000778:	eb00 70d3 	add.w	r0, r0, r3, lsr #31
 800077c:	ea5e 0e43 	orrs.w	lr, lr, r3, lsl #1
 8000780:	bf08      	it	eq
 8000782:	ea20 70d3 	biceq.w	r0, r0, r3, lsr #31
 8000786:	bd70      	pop	{r4, r5, r6, pc}
 8000788:	f094 0f00 	teq	r4, #0
 800078c:	d10f      	bne.n	80007ae <__aeabi_dmul+0x1c2>
 800078e:	f001 4600 	and.w	r6, r1, #2147483648	; 0x80000000
 8000792:	0040      	lsls	r0, r0, #1
 8000794:	eb41 0101 	adc.w	r1, r1, r1
 8000798:	f411 1f80 	tst.w	r1, #1048576	; 0x100000
 800079c:	bf08      	it	eq
 800079e:	3c01      	subeq	r4, #1
 80007a0:	d0f7      	beq.n	8000792 <__aeabi_dmul+0x1a6>
 80007a2:	ea41 0106 	orr.w	r1, r1, r6
 80007a6:	f095 0f00 	teq	r5, #0
 80007aa:	bf18      	it	ne
 80007ac:	4770      	bxne	lr
 80007ae:	f003 4600 	and.w	r6, r3, #2147483648	; 0x80000000
 80007b2:	0052      	lsls	r2, r2, #1
 80007b4:	eb43 0303 	adc.w	r3, r3, r3
 80007b8:	f413 1f80 	tst.w	r3, #1048576	; 0x100000
 80007bc:	bf08      	it	eq
 80007be:	3d01      	subeq	r5, #1
 80007c0:	d0f7      	beq.n	80007b2 <__aeabi_dmul+0x1c6>
 80007c2:	ea43 0306 	orr.w	r3, r3, r6
 80007c6:	4770      	bx	lr
 80007c8:	ea94 0f0c 	teq	r4, ip
 80007cc:	ea0c 5513 	and.w	r5, ip, r3, lsr #20
 80007d0:	bf18      	it	ne
 80007d2:	ea95 0f0c 	teqne	r5, ip
 80007d6:	d00c      	beq.n	80007f2 <__aeabi_dmul+0x206>
 80007d8:	ea50 0641 	orrs.w	r6, r0, r1, lsl #1
 80007dc:	bf18      	it	ne
 80007de:	ea52 0643 	orrsne.w	r6, r2, r3, lsl #1
 80007e2:	d1d1      	bne.n	8000788 <__aeabi_dmul+0x19c>
 80007e4:	ea81 0103 	eor.w	r1, r1, r3
 80007e8:	f001 4100 	and.w	r1, r1, #2147483648	; 0x80000000
 80007ec:	f04f 0000 	mov.w	r0, #0
 80007f0:	bd70      	pop	{r4, r5, r6, pc}
 80007f2:	ea50 0641 	orrs.w	r6, r0, r1, lsl #1
 80007f6:	bf06      	itte	eq
 80007f8:	4610      	moveq	r0, r2
 80007fa:	4619      	moveq	r1, r3
 80007fc:	ea52 0643 	orrsne.w	r6, r2, r3, lsl #1
 8000800:	d019      	beq.n	8000836 <__aeabi_dmul+0x24a>
 8000802:	ea94 0f0c 	teq	r4, ip
 8000806:	d102      	bne.n	800080e <__aeabi_dmul+0x222>
 8000808:	ea50 3601 	orrs.w	r6, r0, r1, lsl #12
 800080c:	d113      	bne.n	8000836 <__aeabi_dmul+0x24a>
 800080e:	ea95 0f0c 	teq	r5, ip
 8000812:	d105      	bne.n	8000820 <__aeabi_dmul+0x234>
 8000814:	ea52 3603 	orrs.w	r6, r2, r3, lsl #12
 8000818:	bf1c      	itt	ne
 800081a:	4610      	movne	r0, r2
 800081c:	4619      	movne	r1, r3
 800081e:	d10a      	bne.n	8000836 <__aeabi_dmul+0x24a>
 8000820:	ea81 0103 	eor.w	r1, r1, r3
 8000824:	f001 4100 	and.w	r1, r1, #2147483648	; 0x80000000
 8000828:	f041 41fe 	orr.w	r1, r1, #2130706432	; 0x7f000000
 800082c:	f441 0170 	orr.w	r1, r1, #15728640	; 0xf00000
 8000830:	f04f 0000 	mov.w	r0, #0
 8000834:	bd70      	pop	{r4, r5, r6, pc}
 8000836:	f041 41fe 	orr.w	r1, r1, #2130706432	; 0x7f000000
 800083a:	f441 0178 	orr.w	r1, r1, #16252928	; 0xf80000
 800083e:	bd70      	pop	{r4, r5, r6, pc}

08000840 <__aeabi_ddiv>:
 8000840:	b570      	push	{r4, r5, r6, lr}
 8000842:	f04f 0cff 	mov.w	ip, #255	; 0xff
 8000846:	f44c 6ce0 	orr.w	ip, ip, #1792	; 0x700
 800084a:	ea1c 5411 	ands.w	r4, ip, r1, lsr #20
 800084e:	bf1d      	ittte	ne
 8000850:	ea1c 5513 	andsne.w	r5, ip, r3, lsr #20
 8000854:	ea94 0f0c 	teqne	r4, ip
 8000858:	ea95 0f0c 	teqne	r5, ip
 800085c:	f000 f8a7 	bleq	80009ae <__aeabi_ddiv+0x16e>
 8000860:	eba4 0405 	sub.w	r4, r4, r5
 8000864:	ea81 0e03 	eor.w	lr, r1, r3
 8000868:	ea52 3503 	orrs.w	r5, r2, r3, lsl #12
 800086c:	ea4f 3101 	mov.w	r1, r1, lsl #12
 8000870:	f000 8088 	beq.w	8000984 <__aeabi_ddiv+0x144>
 8000874:	ea4f 3303 	mov.w	r3, r3, lsl #12
 8000878:	f04f 5580 	mov.w	r5, #268435456	; 0x10000000
 800087c:	ea45 1313 	orr.w	r3, r5, r3, lsr #4
 8000880:	ea43 6312 	orr.w	r3, r3, r2, lsr #24
 8000884:	ea4f 2202 	mov.w	r2, r2, lsl #8
 8000888:	ea45 1511 	orr.w	r5, r5, r1, lsr #4
 800088c:	ea45 6510 	orr.w	r5, r5, r0, lsr #24
 8000890:	ea4f 2600 	mov.w	r6, r0, lsl #8
 8000894:	f00e 4100 	and.w	r1, lr, #2147483648	; 0x80000000
 8000898:	429d      	cmp	r5, r3
 800089a:	bf08      	it	eq
 800089c:	4296      	cmpeq	r6, r2
 800089e:	f144 04fd 	adc.w	r4, r4, #253	; 0xfd
 80008a2:	f504 7440 	add.w	r4, r4, #768	; 0x300
 80008a6:	d202      	bcs.n	80008ae <__aeabi_ddiv+0x6e>
 80008a8:	085b      	lsrs	r3, r3, #1
 80008aa:	ea4f 0232 	mov.w	r2, r2, rrx
 80008ae:	1ab6      	subs	r6, r6, r2
 80008b0:	eb65 0503 	sbc.w	r5, r5, r3
 80008b4:	085b      	lsrs	r3, r3, #1
 80008b6:	ea4f 0232 	mov.w	r2, r2, rrx
 80008ba:	f44f 1080 	mov.w	r0, #1048576	; 0x100000
 80008be:	f44f 2c00 	mov.w	ip, #524288	; 0x80000
 80008c2:	ebb6 0e02 	subs.w	lr, r6, r2
 80008c6:	eb75 0e03 	sbcs.w	lr, r5, r3
 80008ca:	bf22      	ittt	cs
 80008cc:	1ab6      	subcs	r6, r6, r2
 80008ce:	4675      	movcs	r5, lr
 80008d0:	ea40 000c 	orrcs.w	r0, r0, ip
 80008d4:	085b      	lsrs	r3, r3, #1
 80008d6:	ea4f 0232 	mov.w	r2, r2, rrx
 80008da:	ebb6 0e02 	subs.w	lr, r6, r2
 80008de:	eb75 0e03 	sbcs.w	lr, r5, r3
 80008e2:	bf22      	ittt	cs
 80008e4:	1ab6      	subcs	r6, r6, r2
 80008e6:	4675      	movcs	r5, lr
 80008e8:	ea40 005c 	orrcs.w	r0, r0, ip, lsr #1
 80008ec:	085b      	lsrs	r3, r3, #1
 80008ee:	ea4f 0232 	mov.w	r2, r2, rrx
 80008f2:	ebb6 0e02 	subs.w	lr, r6, r2
 80008f6:	eb75 0e03 	sbcs.w	lr, r5, r3
 80008fa:	bf22      	ittt	cs
 80008fc:	1ab6      	subcs	r6, r6, r2
 80008fe:	4675      	movcs	r5, lr
 8000900:	ea40 009c 	orrcs.w	r0, r0, ip, lsr #2
 8000904:	085b      	lsrs	r3, r3, #1
 8000906:	ea4f 0232 	mov.w	r2, r2, rrx
 800090a:	ebb6 0e02 	subs.w	lr, r6, r2
 800090e:	eb75 0e03 	sbcs.w	lr, r5, r3
 8000912:	bf22      	ittt	cs
 8000914:	1ab6      	subcs	r6, r6, r2
 8000916:	4675      	movcs	r5, lr
 8000918:	ea40 00dc 	orrcs.w	r0, r0, ip, lsr #3
 800091c:	ea55 0e06 	orrs.w	lr, r5, r6
 8000920:	d018      	beq.n	8000954 <__aeabi_ddiv+0x114>
 8000922:	ea4f 1505 	mov.w	r5, r5, lsl #4
 8000926:	ea45 7516 	orr.w	r5, r5, r6, lsr #28
 800092a:	ea4f 1606 	mov.w	r6, r6, lsl #4
 800092e:	ea4f 03c3 	mov.w	r3, r3, lsl #3
 8000932:	ea43 7352 	orr.w	r3, r3, r2, lsr #29
 8000936:	ea4f 02c2 	mov.w	r2, r2, lsl #3
 800093a:	ea5f 1c1c 	movs.w	ip, ip, lsr #4
 800093e:	d1c0      	bne.n	80008c2 <__aeabi_ddiv+0x82>
 8000940:	f411 1f80 	tst.w	r1, #1048576	; 0x100000
 8000944:	d10b      	bne.n	800095e <__aeabi_ddiv+0x11e>
 8000946:	ea41 0100 	orr.w	r1, r1, r0
 800094a:	f04f 0000 	mov.w	r0, #0
 800094e:	f04f 4c00 	mov.w	ip, #2147483648	; 0x80000000
 8000952:	e7b6      	b.n	80008c2 <__aeabi_ddiv+0x82>
 8000954:	f411 1f80 	tst.w	r1, #1048576	; 0x100000
 8000958:	bf04      	itt	eq
 800095a:	4301      	orreq	r1, r0
 800095c:	2000      	moveq	r0, #0
 800095e:	f1b4 0cfd 	subs.w	ip, r4, #253	; 0xfd
 8000962:	bf88      	it	hi
 8000964:	f5bc 6fe0 	cmphi.w	ip, #1792	; 0x700
 8000968:	f63f aeaf 	bhi.w	80006ca <__aeabi_dmul+0xde>
 800096c:	ebb5 0c03 	subs.w	ip, r5, r3
 8000970:	bf04      	itt	eq
 8000972:	ebb6 0c02 	subseq.w	ip, r6, r2
 8000976:	ea5f 0c50 	movseq.w	ip, r0, lsr #1
 800097a:	f150 0000 	adcs.w	r0, r0, #0
 800097e:	eb41 5104 	adc.w	r1, r1, r4, lsl #20
 8000982:	bd70      	pop	{r4, r5, r6, pc}
 8000984:	f00e 4e00 	and.w	lr, lr, #2147483648	; 0x80000000
 8000988:	ea4e 3111 	orr.w	r1, lr, r1, lsr #12
 800098c:	eb14 045c 	adds.w	r4, r4, ip, lsr #1
 8000990:	bfc2      	ittt	gt
 8000992:	ebd4 050c 	rsbsgt	r5, r4, ip
 8000996:	ea41 5104 	orrgt.w	r1, r1, r4, lsl #20
 800099a:	bd70      	popgt	{r4, r5, r6, pc}
 800099c:	f441 1180 	orr.w	r1, r1, #1048576	; 0x100000
 80009a0:	f04f 0e00 	mov.w	lr, #0
 80009a4:	3c01      	subs	r4, #1
 80009a6:	e690      	b.n	80006ca <__aeabi_dmul+0xde>
 80009a8:	ea45 0e06 	orr.w	lr, r5, r6
 80009ac:	e68d      	b.n	80006ca <__aeabi_dmul+0xde>
 80009ae:	ea0c 5513 	and.w	r5, ip, r3, lsr #20
 80009b2:	ea94 0f0c 	teq	r4, ip
 80009b6:	bf08      	it	eq
 80009b8:	ea95 0f0c 	teqeq	r5, ip
 80009bc:	f43f af3b 	beq.w	8000836 <__aeabi_dmul+0x24a>
 80009c0:	ea94 0f0c 	teq	r4, ip
 80009c4:	d10a      	bne.n	80009dc <__aeabi_ddiv+0x19c>
 80009c6:	ea50 3401 	orrs.w	r4, r0, r1, lsl #12
 80009ca:	f47f af34 	bne.w	8000836 <__aeabi_dmul+0x24a>
 80009ce:	ea95 0f0c 	teq	r5, ip
 80009d2:	f47f af25 	bne.w	8000820 <__aeabi_dmul+0x234>
 80009d6:	4610      	mov	r0, r2
 80009d8:	4619      	mov	r1, r3
 80009da:	e72c      	b.n	8000836 <__aeabi_dmul+0x24a>
 80009dc:	ea95 0f0c 	teq	r5, ip
 80009e0:	d106      	bne.n	80009f0 <__aeabi_ddiv+0x1b0>
 80009e2:	ea52 3503 	orrs.w	r5, r2, r3, lsl #12
 80009e6:	f43f aefd 	beq.w	80007e4 <__aeabi_dmul+0x1f8>
 80009ea:	4610      	mov	r0, r2
 80009ec:	4619      	mov	r1, r3
 80009ee:	e722      	b.n	8000836 <__aeabi_dmul+0x24a>
 80009f0:	ea50 0641 	orrs.w	r6, r0, r1, lsl #1
 80009f4:	bf18      	it	ne
 80009f6:	ea52 0643 	orrsne.w	r6, r2, r3, lsl #1
 80009fa:	f47f aec5 	bne.w	8000788 <__aeabi_dmul+0x19c>
 80009fe:	ea50 0441 	orrs.w	r4, r0, r1, lsl #1
 8000a02:	f47f af0d 	bne.w	8000820 <__aeabi_dmul+0x234>
 8000a06:	ea52 0543 	orrs.w	r5, r2, r3, lsl #1
 8000a0a:	f47f aeeb 	bne.w	80007e4 <__aeabi_dmul+0x1f8>
 8000a0e:	e712      	b.n	8000836 <__aeabi_dmul+0x24a>

08000a10 <__aeabi_d2iz>:
 8000a10:	ea4f 0241 	mov.w	r2, r1, lsl #1
 8000a14:	f512 1200 	adds.w	r2, r2, #2097152	; 0x200000
 8000a18:	d215      	bcs.n	8000a46 <__aeabi_d2iz+0x36>
 8000a1a:	d511      	bpl.n	8000a40 <__aeabi_d2iz+0x30>
 8000a1c:	f46f 7378 	mvn.w	r3, #992	; 0x3e0
 8000a20:	ebb3 5262 	subs.w	r2, r3, r2, asr #21
 8000a24:	d912      	bls.n	8000a4c <__aeabi_d2iz+0x3c>
 8000a26:	ea4f 23c1 	mov.w	r3, r1, lsl #11
 8000a2a:	f043 4300 	orr.w	r3, r3, #2147483648	; 0x80000000
 8000a2e:	ea43 5350 	orr.w	r3, r3, r0, lsr #21
 8000a32:	f011 4f00 	tst.w	r1, #2147483648	; 0x80000000
 8000a36:	fa23 f002 	lsr.w	r0, r3, r2
 8000a3a:	bf18      	it	ne
 8000a3c:	4240      	negne	r0, r0
 8000a3e:	4770      	bx	lr
 8000a40:	f04f 0000 	mov.w	r0, #0
 8000a44:	4770      	bx	lr
 8000a46:	ea50 3001 	orrs.w	r0, r0, r1, lsl #12
 8000a4a:	d105      	bne.n	8000a58 <__aeabi_d2iz+0x48>
 8000a4c:	f011 4000 	ands.w	r0, r1, #2147483648	; 0x80000000
 8000a50:	bf08      	it	eq
 8000a52:	f06f 4000 	mvneq.w	r0, #2147483648	; 0x80000000
 8000a56:	4770      	bx	lr
 8000a58:	f04f 0000 	mov.w	r0, #0
 8000a5c:	4770      	bx	lr
 8000a5e:	bf00      	nop

08000a60 <__aeabi_d2f>:
 8000a60:	ea4f 0241 	mov.w	r2, r1, lsl #1
 8000a64:	f1b2 43e0 	subs.w	r3, r2, #1879048192	; 0x70000000
 8000a68:	bf24      	itt	cs
 8000a6a:	f5b3 1c00 	subscs.w	ip, r3, #2097152	; 0x200000
 8000a6e:	f1dc 5cfe 	rsbscs	ip, ip, #532676608	; 0x1fc00000
 8000a72:	d90d      	bls.n	8000a90 <__aeabi_d2f+0x30>
 8000a74:	f001 4c00 	and.w	ip, r1, #2147483648	; 0x80000000
 8000a78:	ea4f 02c0 	mov.w	r2, r0, lsl #3
 8000a7c:	ea4c 7050 	orr.w	r0, ip, r0, lsr #29
 8000a80:	f1b2 4f00 	cmp.w	r2, #2147483648	; 0x80000000
 8000a84:	eb40 0083 	adc.w	r0, r0, r3, lsl #2
 8000a88:	bf08      	it	eq
 8000a8a:	f020 0001 	biceq.w	r0, r0, #1
 8000a8e:	4770      	bx	lr
 8000a90:	f011 4f80 	tst.w	r1, #1073741824	; 0x40000000
 8000a94:	d121      	bne.n	8000ada <__aeabi_d2f+0x7a>
 8000a96:	f113 7238 	adds.w	r2, r3, #48234496	; 0x2e00000
 8000a9a:	bfbc      	itt	lt
 8000a9c:	f001 4000 	andlt.w	r0, r1, #2147483648	; 0x80000000
 8000aa0:	4770      	bxlt	lr
 8000aa2:	f441 1180 	orr.w	r1, r1, #1048576	; 0x100000
 8000aa6:	ea4f 5252 	mov.w	r2, r2, lsr #21
 8000aaa:	f1c2 0218 	rsb	r2, r2, #24
 8000aae:	f1c2 0c20 	rsb	ip, r2, #32
 8000ab2:	fa10 f30c 	lsls.w	r3, r0, ip
 8000ab6:	fa20 f002 	lsr.w	r0, r0, r2
 8000aba:	bf18      	it	ne
 8000abc:	f040 0001 	orrne.w	r0, r0, #1
 8000ac0:	ea4f 23c1 	mov.w	r3, r1, lsl #11
 8000ac4:	ea4f 23d3 	mov.w	r3, r3, lsr #11
 8000ac8:	fa03 fc0c 	lsl.w	ip, r3, ip
 8000acc:	ea40 000c 	orr.w	r0, r0, ip
 8000ad0:	fa23 f302 	lsr.w	r3, r3, r2
 8000ad4:	ea4f 0343 	mov.w	r3, r3, lsl #1
 8000ad8:	e7cc      	b.n	8000a74 <__aeabi_d2f+0x14>
 8000ada:	ea7f 5362 	mvns.w	r3, r2, asr #21
 8000ade:	d107      	bne.n	8000af0 <__aeabi_d2f+0x90>
 8000ae0:	ea50 3301 	orrs.w	r3, r0, r1, lsl #12
 8000ae4:	bf1e      	ittt	ne
 8000ae6:	f04f 40fe 	movne.w	r0, #2130706432	; 0x7f000000
 8000aea:	f440 0040 	orrne.w	r0, r0, #12582912	; 0xc00000
 8000aee:	4770      	bxne	lr
 8000af0:	f001 4000 	and.w	r0, r1, #2147483648	; 0x80000000
 8000af4:	f040 40fe 	orr.w	r0, r0, #2130706432	; 0x7f000000
 8000af8:	f440 0000 	orr.w	r0, r0, #8388608	; 0x800000
 8000afc:	4770      	bx	lr
 8000afe:	bf00      	nop

08000b00 <__gesf2>:
 8000b00:	f04f 3cff 	mov.w	ip, #4294967295
 8000b04:	e006      	b.n	8000b14 <__cmpsf2+0x4>
 8000b06:	bf00      	nop

08000b08 <__lesf2>:
 8000b08:	f04f 0c01 	mov.w	ip, #1
 8000b0c:	e002      	b.n	8000b14 <__cmpsf2+0x4>
 8000b0e:	bf00      	nop

08000b10 <__cmpsf2>:
 8000b10:	f04f 0c01 	mov.w	ip, #1
 8000b14:	f84d cd04 	str.w	ip, [sp, #-4]!
 8000b18:	ea4f 0240 	mov.w	r2, r0, lsl #1
 8000b1c:	ea4f 0341 	mov.w	r3, r1, lsl #1
 8000b20:	ea7f 6c22 	mvns.w	ip, r2, asr #24
 8000b24:	bf18      	it	ne
 8000b26:	ea7f 6c23 	mvnsne.w	ip, r3, asr #24
 8000b2a:	d011      	beq.n	8000b50 <__cmpsf2+0x40>
 8000b2c:	b001      	add	sp, #4
 8000b2e:	ea52 0c53 	orrs.w	ip, r2, r3, lsr #1
 8000b32:	bf18      	it	ne
 8000b34:	ea90 0f01 	teqne	r0, r1
 8000b38:	bf58      	it	pl
 8000b3a:	ebb2 0003 	subspl.w	r0, r2, r3
 8000b3e:	bf88      	it	hi
 8000b40:	17c8      	asrhi	r0, r1, #31
 8000b42:	bf38      	it	cc
 8000b44:	ea6f 70e1 	mvncc.w	r0, r1, asr #31
 8000b48:	bf18      	it	ne
 8000b4a:	f040 0001 	orrne.w	r0, r0, #1
 8000b4e:	4770      	bx	lr
 8000b50:	ea7f 6c22 	mvns.w	ip, r2, asr #24
 8000b54:	d102      	bne.n	8000b5c <__cmpsf2+0x4c>
 8000b56:	ea5f 2c40 	movs.w	ip, r0, lsl #9
 8000b5a:	d105      	bne.n	8000b68 <__cmpsf2+0x58>
 8000b5c:	ea7f 6c23 	mvns.w	ip, r3, asr #24
 8000b60:	d1e4      	bne.n	8000b2c <__cmpsf2+0x1c>
 8000b62:	ea5f 2c41 	movs.w	ip, r1, lsl #9
 8000b66:	d0e1      	beq.n	8000b2c <__cmpsf2+0x1c>
 8000b68:	f85d 0b04 	ldr.w	r0, [sp], #4
 8000b6c:	4770      	bx	lr
 8000b6e:	bf00      	nop

08000b70 <__aeabi_cfrcmple>:
 8000b70:	4684      	mov	ip, r0
 8000b72:	4608      	mov	r0, r1
 8000b74:	4661      	mov	r1, ip
 8000b76:	e7ff      	b.n	8000b78 <__aeabi_cfcmpeq>

08000b78 <__aeabi_cfcmpeq>:
 8000b78:	b50f      	push	{r0, r1, r2, r3, lr}
 8000b7a:	f7ff ffc9 	bl	8000b10 <__cmpsf2>
 8000b7e:	2800      	cmp	r0, #0
 8000b80:	bf48      	it	mi
 8000b82:	f110 0f00 	cmnmi.w	r0, #0
 8000b86:	bd0f      	pop	{r0, r1, r2, r3, pc}

08000b88 <__aeabi_fcmpeq>:
 8000b88:	f84d ed08 	str.w	lr, [sp, #-8]!
 8000b8c:	f7ff fff4 	bl	8000b78 <__aeabi_cfcmpeq>
 8000b90:	bf0c      	ite	eq
 8000b92:	2001      	moveq	r0, #1
 8000b94:	2000      	movne	r0, #0
 8000b96:	f85d fb08 	ldr.w	pc, [sp], #8
 8000b9a:	bf00      	nop

08000b9c <__aeabi_fcmplt>:
 8000b9c:	f84d ed08 	str.w	lr, [sp, #-8]!
 8000ba0:	f7ff ffea 	bl	8000b78 <__aeabi_cfcmpeq>
 8000ba4:	bf34      	ite	cc
 8000ba6:	2001      	movcc	r0, #1
 8000ba8:	2000      	movcs	r0, #0
 8000baa:	f85d fb08 	ldr.w	pc, [sp], #8
 8000bae:	bf00      	nop

08000bb0 <__aeabi_fcmple>:
 8000bb0:	f84d ed08 	str.w	lr, [sp, #-8]!
 8000bb4:	f7ff ffe0 	bl	8000b78 <__aeabi_cfcmpeq>
 8000bb8:	bf94      	ite	ls
 8000bba:	2001      	movls	r0, #1
 8000bbc:	2000      	movhi	r0, #0
 8000bbe:	f85d fb08 	ldr.w	pc, [sp], #8
 8000bc2:	bf00      	nop

08000bc4 <__aeabi_fcmpge>:
 8000bc4:	f84d ed08 	str.w	lr, [sp, #-8]!
 8000bc8:	f7ff ffd2 	bl	8000b70 <__aeabi_cfrcmple>
 8000bcc:	bf94      	ite	ls
 8000bce:	2001      	movls	r0, #1
 8000bd0:	2000      	movhi	r0, #0
 8000bd2:	f85d fb08 	ldr.w	pc, [sp], #8
 8000bd6:	bf00      	nop

08000bd8 <__aeabi_fcmpgt>:
 8000bd8:	f84d ed08 	str.w	lr, [sp, #-8]!
 8000bdc:	f7ff ffc8 	bl	8000b70 <__aeabi_cfrcmple>
 8000be0:	bf34      	ite	cc
 8000be2:	2001      	movcc	r0, #1
 8000be4:	2000      	movcs	r0, #0
 8000be6:	f85d fb08 	ldr.w	pc, [sp], #8
 8000bea:	bf00      	nop

08000bec <__aeabi_f2iz>:
 8000bec:	ea4f 0240 	mov.w	r2, r0, lsl #1
 8000bf0:	f1b2 4ffe 	cmp.w	r2, #2130706432	; 0x7f000000
 8000bf4:	d30f      	bcc.n	8000c16 <__aeabi_f2iz+0x2a>
 8000bf6:	f04f 039e 	mov.w	r3, #158	; 0x9e
 8000bfa:	ebb3 6212 	subs.w	r2, r3, r2, lsr #24
 8000bfe:	d90d      	bls.n	8000c1c <__aeabi_f2iz+0x30>
 8000c00:	ea4f 2300 	mov.w	r3, r0, lsl #8
 8000c04:	f043 4300 	orr.w	r3, r3, #2147483648	; 0x80000000
 8000c08:	f010 4f00 	tst.w	r0, #2147483648	; 0x80000000
 8000c0c:	fa23 f002 	lsr.w	r0, r3, r2
 8000c10:	bf18      	it	ne
 8000c12:	4240      	negne	r0, r0
 8000c14:	4770      	bx	lr
 8000c16:	f04f 0000 	mov.w	r0, #0
 8000c1a:	4770      	bx	lr
 8000c1c:	f112 0f61 	cmn.w	r2, #97	; 0x61
 8000c20:	d101      	bne.n	8000c26 <__aeabi_f2iz+0x3a>
 8000c22:	0242      	lsls	r2, r0, #9
 8000c24:	d105      	bne.n	8000c32 <__aeabi_f2iz+0x46>
 8000c26:	f010 4000 	ands.w	r0, r0, #2147483648	; 0x80000000
 8000c2a:	bf08      	it	eq
 8000c2c:	f06f 4000 	mvneq.w	r0, #2147483648	; 0x80000000
 8000c30:	4770      	bx	lr
 8000c32:	f04f 0000 	mov.w	r0, #0
 8000c36:	4770      	bx	lr
	...

08000c40 <i2c_lld_serve_tx_end_irq.8324>:
static void i2c_lld_serve_tx_end_irq(I2CDriver *i2cp, uint32_t flags) {
  I2C_TypeDef *dp = i2cp->i2c;

  /* DMA errors handling.*/
#if defined(STM32_I2C_DMA_ERROR_HOOK)
  if ((flags & (STM32_DMA_ISR_TEIF | STM32_DMA_ISR_DMEIF)) != 0) {
 8000c40:	070b      	lsls	r3, r1, #28
 *
 * @param[in] i2cp      pointer to the @p I2CDriver object
 *
 * @notapi
 */
static void i2c_lld_serve_tx_end_irq(I2CDriver *i2cp, uint32_t flags) {
 8000c42:	b430      	push	{r4, r5}
  I2C_TypeDef *dp = i2cp->i2c;
 8000c44:	6b42      	ldr	r2, [r0, #52]	; 0x34

  /* DMA errors handling.*/
#if defined(STM32_I2C_DMA_ERROR_HOOK)
  if ((flags & (STM32_DMA_ISR_TEIF | STM32_DMA_ISR_DMEIF)) != 0) {
 8000c46:	d411      	bmi.n	8000c6c <i2c_lld_serve_tx_end_irq.8324+0x2c>
  }
#else
  (void)flags;
#endif

  dmaStreamDisable(i2cp->dmatx);
 8000c48:	6b03      	ldr	r3, [r0, #48]	; 0x30
 8000c4a:	240e      	movs	r4, #14
 8000c4c:	e893 0003 	ldmia.w	r3, {r0, r1}
 8000c50:	680d      	ldr	r5, [r1, #0]
 8000c52:	f025 050f 	bic.w	r5, r5, #15
 8000c56:	600d      	str	r5, [r1, #0]
 8000c58:	7c1b      	ldrb	r3, [r3, #16]
 8000c5a:	fa04 f303 	lsl.w	r3, r4, r3
  /* Enables interrupts to catch BTF event meaning transmission part complete.
     Interrupt handler will decide to generate STOP or to begin receiving part
     of R/W transaction itself.*/
  dp->CR2 |= I2C_CR2_ITEVTEN;
}
 8000c5e:	bc30      	pop	{r4, r5}
  }
#else
  (void)flags;
#endif

  dmaStreamDisable(i2cp->dmatx);
 8000c60:	6043      	str	r3, [r0, #4]
  /* Enables interrupts to catch BTF event meaning transmission part complete.
     Interrupt handler will decide to generate STOP or to begin receiving part
     of R/W transaction itself.*/
  dp->CR2 |= I2C_CR2_ITEVTEN;
 8000c62:	6853      	ldr	r3, [r2, #4]
 8000c64:	f443 7300 	orr.w	r3, r3, #512	; 0x200
 8000c68:	6053      	str	r3, [r2, #4]
}
 8000c6a:	4770      	bx	lr
  \details Disables IRQ interrupts by setting the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __disable_irq(void)
{
  __ASM volatile ("cpsid i" : : : "memory");
 8000c6c:	b672      	cpsid	i

  /* Logging the event.*/
  _trace_halt(reason);

  /* Pointing to the passed message.*/
  ch.dbg.panic_msg = reason;
 8000c6e:	f640 03d8 	movw	r3, #2264	; 0x8d8
 8000c72:	f642 5230 	movw	r2, #11568	; 0x2d30
 8000c76:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8000c7a:	f6c0 0200 	movt	r2, #2048	; 0x800
 8000c7e:	629a      	str	r2, [r3, #40]	; 0x28
 8000c80:	e7fe      	b.n	8000c80 <i2c_lld_serve_tx_end_irq.8324+0x40>
 8000c82:	bf00      	nop
 8000c84:	f3af 8000 	nop.w
 8000c88:	f3af 8000 	nop.w
 8000c8c:	f3af 8000 	nop.w

08000c90 <i2c_lld_serve_rx_end_irq.8328>:
static void i2c_lld_serve_rx_end_irq(I2CDriver *i2cp, uint32_t flags) {
  I2C_TypeDef *dp = i2cp->i2c;

  /* DMA errors handling.*/
#if defined(STM32_I2C_DMA_ERROR_HOOK)
  if ((flags & (STM32_DMA_ISR_TEIF | STM32_DMA_ISR_DMEIF)) != 0) {
 8000c90:	070a      	lsls	r2, r1, #28
 * @param[in] i2cp      pointer to the @p I2CDriver object
 * @param[in] flags     pre-shifted content of the ISR register
 *
 * @notapi
 */
static void i2c_lld_serve_rx_end_irq(I2CDriver *i2cp, uint32_t flags) {
 8000c92:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
  I2C_TypeDef *dp = i2cp->i2c;
 8000c94:	6b43      	ldr	r3, [r0, #52]	; 0x34

  /* DMA errors handling.*/
#if defined(STM32_I2C_DMA_ERROR_HOOK)
  if ((flags & (STM32_DMA_ISR_TEIF | STM32_DMA_ISR_DMEIF)) != 0) {
 8000c96:	d426      	bmi.n	8000ce6 <i2c_lld_serve_rx_end_irq.8328+0x56>
  }
#else
  (void)flags;
#endif

  dmaStreamDisable(i2cp->dmarx);
 8000c98:	6ac2      	ldr	r2, [r0, #44]	; 0x2c
 8000c9a:	260e      	movs	r6, #14
 8000c9c:	6851      	ldr	r1, [r2, #4]
 8000c9e:	6815      	ldr	r5, [r2, #0]
 8000ca0:	680f      	ldr	r7, [r1, #0]
  \details Assigns the given value to the Base Priority register.
  \param [in]    basePri  Base Priority value to set
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __set_BASEPRI(uint32_t value)
{
  __ASM volatile ("MSR basepri, %0" : : "r" (value) : "memory");
 8000ca2:	2420      	movs	r4, #32
 8000ca4:	f027 070f 	bic.w	r7, r7, #15
 8000ca8:	600f      	str	r7, [r1, #0]
 8000caa:	7c12      	ldrb	r2, [r2, #16]
 8000cac:	fa06 f202 	lsl.w	r2, r6, r2
 8000cb0:	606a      	str	r2, [r5, #4]

  dp->CR2 &= ~I2C_CR2_LAST;
 8000cb2:	685a      	ldr	r2, [r3, #4]
 8000cb4:	f422 5280 	bic.w	r2, r2, #4096	; 0x1000
 8000cb8:	605a      	str	r2, [r3, #4]
  dp->CR1 &= ~I2C_CR1_ACK;
 8000cba:	681a      	ldr	r2, [r3, #0]
 8000cbc:	f422 6280 	bic.w	r2, r2, #1024	; 0x400
 8000cc0:	601a      	str	r2, [r3, #0]
  dp->CR1 |= I2C_CR1_STOP;
 8000cc2:	681a      	ldr	r2, [r3, #0]
 8000cc4:	f442 7200 	orr.w	r2, r2, #512	; 0x200
 8000cc8:	601a      	str	r2, [r3, #0]
 8000cca:	f384 8811 	msr	BASEPRI, r4
 *
 * @iclass
 */
void chThdResumeI(thread_reference_t *trp, msg_t msg) {

  if (*trp != NULL) {
 8000cce:	69c3      	ldr	r3, [r0, #28]
 8000cd0:	b12b      	cbz	r3, 8000cde <i2c_lld_serve_rx_end_irq.8328+0x4e>
    thread_t *tp = *trp;

    chDbgAssert(tp->state == CH_STATE_SUSPENDED, "not CH_STATE_SUSPENDED");

    *trp = NULL;
 8000cd2:	2200      	movs	r2, #0
 8000cd4:	61c2      	str	r2, [r0, #28]
    tp->u.rdymsg = msg;
    (void) chSchReadyI(tp);
 8000cd6:	4618      	mov	r0, r3
    thread_t *tp = *trp;

    chDbgAssert(tp->state == CH_STATE_SUSPENDED, "not CH_STATE_SUSPENDED");

    *trp = NULL;
    tp->u.rdymsg = msg;
 8000cd8:	625a      	str	r2, [r3, #36]	; 0x24
    (void) chSchReadyI(tp);
 8000cda:	f001 fac9 	bl	8002270 <chSchReadyI>
 8000cde:	2300      	movs	r3, #0
 8000ce0:	f383 8811 	msr	BASEPRI, r3
 8000ce4:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
  \details Disables IRQ interrupts by setting the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __disable_irq(void)
{
  __ASM volatile ("cpsid i" : : : "memory");
 8000ce6:	b672      	cpsid	i
 8000ce8:	f640 03d8 	movw	r3, #2264	; 0x8d8
 8000cec:	f642 5230 	movw	r2, #11568	; 0x2d30
 8000cf0:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8000cf4:	f6c0 0200 	movt	r2, #2048	; 0x800
 8000cf8:	629a      	str	r2, [r3, #40]	; 0x28
 8000cfa:	e7fe      	b.n	8000cfa <i2c_lld_serve_rx_end_irq.8328+0x6a>
 8000cfc:	f3af 8000 	nop.w

08000d00 <VectorC0.4168>:
}

/**
 * @brief   I2C1 error interrupt handler.
 */
OSAL_IRQ_HANDLER(STM32_I2C1_ERROR_HANDLER) {
 8000d00:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
  uint16_t sr = I2CD1.i2c->SR1;
 8000d02:	f640 2358 	movw	r3, #2648	; 0xa58
 8000d06:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8000d0a:	6b58      	ldr	r0, [r3, #52]	; 0x34
 * @notapi
 */
static void i2c_lld_serve_error_interrupt(I2CDriver *i2cp, uint16_t sr) {

  /* Clears interrupt flags just to be safe.*/
  dmaStreamDisable(i2cp->dmatx);
 8000d0c:	6b1c      	ldr	r4, [r3, #48]	; 0x30

/**
 * @brief   I2C1 error interrupt handler.
 */
OSAL_IRQ_HANDLER(STM32_I2C1_ERROR_HANDLER) {
  uint16_t sr = I2CD1.i2c->SR1;
 8000d0e:	6945      	ldr	r5, [r0, #20]
 * @notapi
 */
static void i2c_lld_serve_error_interrupt(I2CDriver *i2cp, uint16_t sr) {

  /* Clears interrupt flags just to be safe.*/
  dmaStreamDisable(i2cp->dmatx);
 8000d10:	6861      	ldr	r1, [r4, #4]

/**
 * @brief   I2C1 error interrupt handler.
 */
OSAL_IRQ_HANDLER(STM32_I2C1_ERROR_HANDLER) {
  uint16_t sr = I2CD1.i2c->SR1;
 8000d12:	b2aa      	uxth	r2, r5

  OSAL_IRQ_PROLOGUE();

  I2CD1.i2c->SR1 = ~(sr & I2C_ERROR_MASK);
 8000d14:	f402 465f 	and.w	r6, r2, #57088	; 0xdf00
 8000d18:	43f6      	mvns	r6, r6
 8000d1a:	6146      	str	r6, [r0, #20]
 * @notapi
 */
static void i2c_lld_serve_error_interrupt(I2CDriver *i2cp, uint16_t sr) {

  /* Clears interrupt flags just to be safe.*/
  dmaStreamDisable(i2cp->dmatx);
 8000d1c:	680f      	ldr	r7, [r1, #0]
 8000d1e:	260e      	movs	r6, #14
 8000d20:	f027 070f 	bic.w	r7, r7, #15
 8000d24:	600f      	str	r7, [r1, #0]
 8000d26:	f894 c010 	ldrb.w	ip, [r4, #16]
  dmaStreamDisable(i2cp->dmarx);
 8000d2a:	6ad9      	ldr	r1, [r3, #44]	; 0x2c
 * @notapi
 */
static void i2c_lld_serve_error_interrupt(I2CDriver *i2cp, uint16_t sr) {

  /* Clears interrupt flags just to be safe.*/
  dmaStreamDisable(i2cp->dmatx);
 8000d2c:	fa06 fc0c 	lsl.w	ip, r6, ip
 8000d30:	6827      	ldr	r7, [r4, #0]
  dmaStreamDisable(i2cp->dmarx);
 8000d32:	684c      	ldr	r4, [r1, #4]
 * @notapi
 */
static void i2c_lld_serve_error_interrupt(I2CDriver *i2cp, uint16_t sr) {

  /* Clears interrupt flags just to be safe.*/
  dmaStreamDisable(i2cp->dmatx);
 8000d34:	f8c7 c004 	str.w	ip, [r7, #4]
  dmaStreamDisable(i2cp->dmarx);
 8000d38:	f8d4 c000 	ldr.w	ip, [r4]
 8000d3c:	680f      	ldr	r7, [r1, #0]
 8000d3e:	f02c 0c0f 	bic.w	ip, ip, #15
 8000d42:	f8c4 c000 	str.w	ip, [r4]
 8000d46:	7c0c      	ldrb	r4, [r1, #16]

  i2cp->errors = I2C_NO_ERROR;

  if (sr & I2C_SR1_BERR)                            /* Bus error.           */
 8000d48:	f402 7180 	and.w	r1, r2, #256	; 0x100
 */
static void i2c_lld_serve_error_interrupt(I2CDriver *i2cp, uint16_t sr) {

  /* Clears interrupt flags just to be safe.*/
  dmaStreamDisable(i2cp->dmatx);
  dmaStreamDisable(i2cp->dmarx);
 8000d4c:	40a6      	lsls	r6, r4

  i2cp->errors = I2C_NO_ERROR;

  if (sr & I2C_SR1_BERR)                            /* Bus error.           */
 8000d4e:	b289      	uxth	r1, r1
 */
static void i2c_lld_serve_error_interrupt(I2CDriver *i2cp, uint16_t sr) {

  /* Clears interrupt flags just to be safe.*/
  dmaStreamDisable(i2cp->dmatx);
  dmaStreamDisable(i2cp->dmarx);
 8000d50:	607e      	str	r6, [r7, #4]

  i2cp->errors = I2C_NO_ERROR;

  if (sr & I2C_SR1_BERR)                            /* Bus error.           */
 8000d52:	b101      	cbz	r1, 8000d56 <VectorC0.4168+0x56>
    i2cp->errors |= I2C_BUS_ERROR;
 8000d54:	2101      	movs	r1, #1

  if (sr & I2C_SR1_ARLO)                            /* Arbitration lost.    */
 8000d56:	0596      	lsls	r6, r2, #22
  dmaStreamDisable(i2cp->dmarx);

  i2cp->errors = I2C_NO_ERROR;

  if (sr & I2C_SR1_BERR)                            /* Bus error.           */
    i2cp->errors |= I2C_BUS_ERROR;
 8000d58:	6099      	str	r1, [r3, #8]

  if (sr & I2C_SR1_ARLO)                            /* Arbitration lost.    */
    i2cp->errors |= I2C_ARBITRATION_LOST;
 8000d5a:	bf44      	itt	mi
 8000d5c:	f041 0102 	orrmi.w	r1, r1, #2
 8000d60:	6099      	strmi	r1, [r3, #8]

  if (sr & I2C_SR1_AF) {                            /* Acknowledge fail.    */
 8000d62:	0554      	lsls	r4, r2, #21
 8000d64:	d50b      	bpl.n	8000d7e <VectorC0.4168+0x7e>
    i2cp->i2c->CR2 &= ~I2C_CR2_ITEVTEN;
 8000d66:	6846      	ldr	r6, [r0, #4]
    i2cp->i2c->CR1 |= I2C_CR1_STOP;                 /* Setting stop bit.    */
    i2cp->errors |= I2C_ACK_FAILURE;
 8000d68:	f041 0404 	orr.w	r4, r1, #4

  if (sr & I2C_SR1_ARLO)                            /* Arbitration lost.    */
    i2cp->errors |= I2C_ARBITRATION_LOST;

  if (sr & I2C_SR1_AF) {                            /* Acknowledge fail.    */
    i2cp->i2c->CR2 &= ~I2C_CR2_ITEVTEN;
 8000d6c:	f426 7100 	bic.w	r1, r6, #512	; 0x200
 8000d70:	6041      	str	r1, [r0, #4]
    i2cp->i2c->CR1 |= I2C_CR1_STOP;                 /* Setting stop bit.    */
 8000d72:	6806      	ldr	r6, [r0, #0]
    i2cp->errors |= I2C_ACK_FAILURE;
 8000d74:	4621      	mov	r1, r4
  if (sr & I2C_SR1_ARLO)                            /* Arbitration lost.    */
    i2cp->errors |= I2C_ARBITRATION_LOST;

  if (sr & I2C_SR1_AF) {                            /* Acknowledge fail.    */
    i2cp->i2c->CR2 &= ~I2C_CR2_ITEVTEN;
    i2cp->i2c->CR1 |= I2C_CR1_STOP;                 /* Setting stop bit.    */
 8000d76:	f446 7600 	orr.w	r6, r6, #512	; 0x200
 8000d7a:	6006      	str	r6, [r0, #0]
    i2cp->errors |= I2C_ACK_FAILURE;
 8000d7c:	609c      	str	r4, [r3, #8]
  }

  if (sr & I2C_SR1_OVR)                             /* Overrun.             */
 8000d7e:	0517      	lsls	r7, r2, #20
    i2cp->errors |= I2C_OVERRUN;
 8000d80:	bf44      	itt	mi
 8000d82:	f041 0108 	orrmi.w	r1, r1, #8
 8000d86:	6099      	strmi	r1, [r3, #8]

  if (sr & I2C_SR1_TIMEOUT)                         /* SMBus Timeout.       */
 8000d88:	0456      	lsls	r6, r2, #17
    i2cp->errors |= I2C_TIMEOUT;
 8000d8a:	bf44      	itt	mi
 8000d8c:	f041 0120 	orrmi.w	r1, r1, #32
 8000d90:	6099      	strmi	r1, [r3, #8]

  if (sr & I2C_SR1_PECERR)                          /* PEC error.           */
 8000d92:	04d4      	lsls	r4, r2, #19
    i2cp->errors |= I2C_PEC_ERROR;
 8000d94:	bf44      	itt	mi
 8000d96:	f041 0110 	orrmi.w	r1, r1, #16
 8000d9a:	6099      	strmi	r1, [r3, #8]

  if (sr & I2C_SR1_SMBALERT)                        /* SMBus alert.         */
 8000d9c:	0428      	lsls	r0, r5, #16
    i2cp->errors |= I2C_SMB_ALERT;
 8000d9e:	bf44      	itt	mi
 8000da0:	f041 0140 	orrmi.w	r1, r1, #64	; 0x40
 8000da4:	6099      	strmi	r1, [r3, #8]
    i2cp->errors |= I2C_TIMEOUT;

  if (sr & I2C_SR1_PECERR)                          /* PEC error.           */
    i2cp->errors |= I2C_PEC_ERROR;

  if (sr & I2C_SR1_SMBALERT)                        /* SMBus alert.         */
 8000da6:	d404      	bmi.n	8000db2 <VectorC0.4168+0xb2>
    i2cp->errors |= I2C_SMB_ALERT;

  /* If some error has been identified then sends wakes the waiting thread.*/
  if (i2cp->errors != I2C_NO_ERROR)
 8000da8:	b919      	cbnz	r1, 8000db2 <VectorC0.4168+0xb2>

  I2CD1.i2c->SR1 = ~(sr & I2C_ERROR_MASK);
  i2c_lld_serve_error_interrupt(&I2CD1, sr);

  OSAL_IRQ_EPILOGUE();
}
 8000daa:	e8bd 40f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, lr}
  OSAL_IRQ_PROLOGUE();

  I2CD1.i2c->SR1 = ~(sr & I2C_ERROR_MASK);
  i2c_lld_serve_error_interrupt(&I2CD1, sr);

  OSAL_IRQ_EPILOGUE();
 8000dae:	f001 b937 	b.w	8002020 <_port_irq_epilogue>
  \details Assigns the given value to the Base Priority register.
  \param [in]    basePri  Base Priority value to set
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __set_BASEPRI(uint32_t value)
{
  __ASM volatile ("MSR basepri, %0" : : "r" (value) : "memory");
 8000db2:	2220      	movs	r2, #32
 8000db4:	f382 8811 	msr	BASEPRI, r2
 *
 * @iclass
 */
void chThdResumeI(thread_reference_t *trp, msg_t msg) {

  if (*trp != NULL) {
 8000db8:	69d8      	ldr	r0, [r3, #28]
 8000dba:	f640 2358 	movw	r3, #2648	; 0xa58
 8000dbe:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8000dc2:	b130      	cbz	r0, 8000dd2 <VectorC0.4168+0xd2>
    thread_t *tp = *trp;

    chDbgAssert(tp->state == CH_STATE_SUSPENDED, "not CH_STATE_SUSPENDED");

    *trp = NULL;
    tp->u.rdymsg = msg;
 8000dc4:	f06f 0201 	mvn.w	r2, #1
 8000dc8:	6242      	str	r2, [r0, #36]	; 0x24
  if (*trp != NULL) {
    thread_t *tp = *trp;

    chDbgAssert(tp->state == CH_STATE_SUSPENDED, "not CH_STATE_SUSPENDED");

    *trp = NULL;
 8000dca:	2200      	movs	r2, #0
 8000dcc:	61da      	str	r2, [r3, #28]
    tp->u.rdymsg = msg;
    (void) chSchReadyI(tp);
 8000dce:	f001 fa4f 	bl	8002270 <chSchReadyI>
 8000dd2:	2300      	movs	r3, #0
 8000dd4:	f383 8811 	msr	BASEPRI, r3
}
 8000dd8:	e8bd 40f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, lr}
  OSAL_IRQ_PROLOGUE();

  I2CD1.i2c->SR1 = ~(sr & I2C_ERROR_MASK);
  i2c_lld_serve_error_interrupt(&I2CD1, sr);

  OSAL_IRQ_EPILOGUE();
 8000ddc:	f001 b920 	b.w	8002020 <_port_irq_epilogue>

08000de0 <VectorB0.4418>:
  OSAL_IRQ_PROLOGUE();

  /* Note, under rare circumstances an interrupt can remain latched even if
     the timer SR register has been cleared, in those cases the interrupt
     is simply ignored.*/
  if ((STM32_ST_TIM->SR & TIM_SR_CC1IF) != 0U) {
 8000de0:	f04f 4380 	mov.w	r3, #1073741824	; 0x40000000
 8000de4:	691a      	ldr	r2, [r3, #16]
 * @brief   TIM2 interrupt handler.
 * @details This interrupt is used for system tick in free running mode.
 *
 * @isr
 */
OSAL_IRQ_HANDLER(ST_HANDLER) {
 8000de6:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
  OSAL_IRQ_PROLOGUE();

  /* Note, under rare circumstances an interrupt can remain latched even if
     the timer SR register has been cleared, in those cases the interrupt
     is simply ignored.*/
  if ((STM32_ST_TIM->SR & TIM_SR_CC1IF) != 0U) {
 8000dea:	0797      	lsls	r7, r2, #30
 8000dec:	d403      	bmi.n	8000df6 <VectorB0.4418+0x16>
    osalOsTimerHandlerI();
    osalSysUnlockFromISR();
  }

  OSAL_IRQ_EPILOGUE();
}
 8000dee:	e8bd 41f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, lr}
    osalSysLockFromISR();
    osalOsTimerHandlerI();
    osalSysUnlockFromISR();
  }

  OSAL_IRQ_EPILOGUE();
 8000df2:	f001 b915 	b.w	8002020 <_port_irq_epilogue>

  /* Note, under rare circumstances an interrupt can remain latched even if
     the timer SR register has been cleared, in those cases the interrupt
     is simply ignored.*/
  if ((STM32_ST_TIM->SR & TIM_SR_CC1IF) != 0U) {
    STM32_ST_TIM->SR = 0U;
 8000df6:	2200      	movs	r2, #0
 8000df8:	611a      	str	r2, [r3, #16]
 8000dfa:	2320      	movs	r3, #32
 8000dfc:	f383 8811 	msr	BASEPRI, r3
#else /* CH_CFG_ST_TIMEDELTA > 0 */
  virtual_timer_t *vtp;
  systime_t now, delta;

  /* First timer to be processed.*/
  vtp = ch.vtlist.next;
 8000e00:	f640 04d8 	movw	r4, #2264	; 0x8d8
 *
 * @notapi
 */
static inline systime_t st_lld_get_counter(void) {

  return (systime_t)STM32_ST_TIM->CNT;
 8000e04:	f04f 4580 	mov.w	r5, #1073741824	; 0x40000000
 8000e08:	f2c2 0400 	movt	r4, #8192	; 0x2000
 8000e0c:	6a6a      	ldr	r2, [r5, #36]	; 0x24

  /* All timers within the time window are triggered and removed,
     note that the loop is stopped by the timers header having
     "ch.vtlist.vt_delta == (systime_t)-1" which is greater than
     all deltas.*/
  while (vtp->delta <= (systime_t)(now - ch.vtlist.lasttime)) {
 8000e0e:	8ce0      	ldrh	r0, [r4, #38]	; 0x26
#else /* CH_CFG_ST_TIMEDELTA > 0 */
  virtual_timer_t *vtp;
  systime_t now, delta;

  /* First timer to be processed.*/
  vtp = ch.vtlist.next;
 8000e10:	69e3      	ldr	r3, [r4, #28]
 8000e12:	b292      	uxth	r2, r2

  /* All timers within the time window are triggered and removed,
     note that the loop is stopped by the timers header having
     "ch.vtlist.vt_delta == (systime_t)-1" which is greater than
     all deltas.*/
  while (vtp->delta <= (systime_t)(now - ch.vtlist.lasttime)) {
 8000e14:	1a16      	subs	r6, r2, r0
 8000e16:	8919      	ldrh	r1, [r3, #8]
 8000e18:	b2b6      	uxth	r6, r6
 8000e1a:	428e      	cmp	r6, r1
 8000e1c:	f104 071c 	add.w	r7, r4, #28
    ch.vtlist.lasttime += vtp->delta;

    vtp->next->prev = (virtual_timer_t *)&ch.vtlist;
    ch.vtlist.next = vtp->next;
    fn = vtp->func;
    vtp->func = NULL;
 8000e20:	bf24      	itt	cs
 8000e22:	f04f 0800 	movcs.w	r8, #0
 8000e26:	2620      	movcs	r6, #32

  /* All timers within the time window are triggered and removed,
     note that the loop is stopped by the timers header having
     "ch.vtlist.vt_delta == (systime_t)-1" which is greater than
     all deltas.*/
  while (vtp->delta <= (systime_t)(now - ch.vtlist.lasttime)) {
 8000e28:	d31c      	bcc.n	8000e64 <VectorB0.4418+0x84>
    vtfunc_t fn;

    /* The "last time" becomes this timer's expiration time.*/
    ch.vtlist.lasttime += vtp->delta;

    vtp->next->prev = (virtual_timer_t *)&ch.vtlist;
 8000e2a:	681a      	ldr	r2, [r3, #0]
     all deltas.*/
  while (vtp->delta <= (systime_t)(now - ch.vtlist.lasttime)) {
    vtfunc_t fn;

    /* The "last time" becomes this timer's expiration time.*/
    ch.vtlist.lasttime += vtp->delta;
 8000e2c:	4401      	add	r1, r0
    ch.vtlist.next = vtp->next;
    fn = vtp->func;
    vtp->func = NULL;

    /* if the list becomes empty then the timer is stopped.*/
    if (ch.vtlist.next == (virtual_timer_t *)&ch.vtlist) {
 8000e2e:	42ba      	cmp	r2, r7
     all deltas.*/
  while (vtp->delta <= (systime_t)(now - ch.vtlist.lasttime)) {
    vtfunc_t fn;

    /* The "last time" becomes this timer's expiration time.*/
    ch.vtlist.lasttime += vtp->delta;
 8000e30:	84e1      	strh	r1, [r4, #38]	; 0x26

    vtp->next->prev = (virtual_timer_t *)&ch.vtlist;
    ch.vtlist.next = vtp->next;
    fn = vtp->func;
 8000e32:	68d9      	ldr	r1, [r3, #12]
    vtfunc_t fn;

    /* The "last time" becomes this timer's expiration time.*/
    ch.vtlist.lasttime += vtp->delta;

    vtp->next->prev = (virtual_timer_t *)&ch.vtlist;
 8000e34:	6057      	str	r7, [r2, #4]
    ch.vtlist.next = vtp->next;
 8000e36:	61e2      	str	r2, [r4, #28]
    fn = vtp->func;
    vtp->func = NULL;
 8000e38:	f8c3 800c 	str.w	r8, [r3, #12]
 *
 * @notapi
 */
static inline void st_lld_stop_alarm(void) {

  STM32_ST_TIM->DIER = 0;
 8000e3c:	bf08      	it	eq
 8000e3e:	f8c5 800c 	streq.w	r8, [r5, #12]
 8000e42:	f388 8811 	msr	BASEPRI, r8
       and in order to give a preemption chance to higher priority
       interrupts.*/
    chSysUnlockFromISR();

    /* The callback is invoked outside the kernel critical zone.*/
    fn(vtp->par);
 8000e46:	6918      	ldr	r0, [r3, #16]
 8000e48:	4788      	blx	r1
 8000e4a:	f386 8811 	msr	BASEPRI, r6
 *
 * @notapi
 */
static inline systime_t st_lld_get_counter(void) {

  return (systime_t)STM32_ST_TIM->CNT;
 8000e4e:	6a6a      	ldr	r2, [r5, #36]	; 0x24

  /* All timers within the time window are triggered and removed,
     note that the loop is stopped by the timers header having
     "ch.vtlist.vt_delta == (systime_t)-1" which is greater than
     all deltas.*/
  while (vtp->delta <= (systime_t)(now - ch.vtlist.lasttime)) {
 8000e50:	8ce0      	ldrh	r0, [r4, #38]	; 0x26
       of the list.*/
    chSysLockFromISR();

    /* Next element in the list, the current time could have advanced so
       recalculating the time window.*/
    vtp = ch.vtlist.next;
 8000e52:	69e3      	ldr	r3, [r4, #28]
 8000e54:	b292      	uxth	r2, r2

  /* All timers within the time window are triggered and removed,
     note that the loop is stopped by the timers header having
     "ch.vtlist.vt_delta == (systime_t)-1" which is greater than
     all deltas.*/
  while (vtp->delta <= (systime_t)(now - ch.vtlist.lasttime)) {
 8000e56:	ebc0 0c02 	rsb	ip, r0, r2
 8000e5a:	8919      	ldrh	r1, [r3, #8]
 8000e5c:	fa1f fc8c 	uxth.w	ip, ip
 8000e60:	4561      	cmp	r1, ip
 8000e62:	d9e2      	bls.n	8000e2a <VectorB0.4418+0x4a>
    vtp = ch.vtlist.next;
    now = chVTGetSystemTimeX();
  }

  /* if the list is empty, nothing else to do.*/
  if (ch.vtlist.next == (virtual_timer_t *)&ch.vtlist) {
 8000e64:	42bb      	cmp	r3, r7
 8000e66:	d00a      	beq.n	8000e7e <VectorB0.4418+0x9e>
    return;
  }

  /* Recalculating the next alarm time.*/
  delta = ch.vtlist.lasttime + vtp->delta - now;
 8000e68:	4401      	add	r1, r0
 8000e6a:	1a89      	subs	r1, r1, r2
 8000e6c:	b289      	uxth	r1, r1
  if (delta < (systime_t)CH_CFG_ST_TIMEDELTA) {
    delta = (systime_t)CH_CFG_ST_TIMEDELTA;
 8000e6e:	2901      	cmp	r1, #1
 8000e70:	bf98      	it	ls
 8000e72:	2102      	movls	r1, #2
  }
  port_timer_set_alarm(now + delta);
 8000e74:	440a      	add	r2, r1
 *
 * @notapi
 */
static inline void st_lld_set_alarm(systime_t time) {

  STM32_ST_TIM->CCR[0] = (uint32_t)time;
 8000e76:	b292      	uxth	r2, r2
 8000e78:	f04f 4380 	mov.w	r3, #1073741824	; 0x40000000
 8000e7c:	635a      	str	r2, [r3, #52]	; 0x34
 8000e7e:	2300      	movs	r3, #0
 8000e80:	f383 8811 	msr	BASEPRI, r3
    osalOsTimerHandlerI();
    osalSysUnlockFromISR();
  }

  OSAL_IRQ_EPILOGUE();
}
 8000e84:	e8bd 41f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, lr}
    osalSysLockFromISR();
    osalOsTimerHandlerI();
    osalSysUnlockFromISR();
  }

  OSAL_IRQ_EPILOGUE();
 8000e88:	f001 b8ca 	b.w	8002020 <_port_irq_epilogue>
 8000e8c:	f3af 8000 	nop.w

08000e90 <serve_interrupt.8720.4185>:
/**
 * @brief   Common IRQ handler.
 *
 * @param[in] sdp       communication channel associated to the USART
 */
static void serve_interrupt(SerialDriver *sdp) {
 8000e90:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
  USART_TypeDef *u = sdp->usart;
 8000e94:	6f46      	ldr	r6, [r0, #116]	; 0x74
/**
 * @brief   Common IRQ handler.
 *
 * @param[in] sdp       communication channel associated to the USART
 */
static void serve_interrupt(SerialDriver *sdp) {
 8000e96:	4605      	mov	r5, r0
  USART_TypeDef *u = sdp->usart;
  uint16_t cr1 = u->CR1;
 8000e98:	f8d6 a00c 	ldr.w	sl, [r6, #12]
  uint16_t sr = u->SR;
 8000e9c:	6833      	ldr	r3, [r6, #0]
/**
 * @brief   Common IRQ handler.
 *
 * @param[in] sdp       communication channel associated to the USART
 */
static void serve_interrupt(SerialDriver *sdp) {
 8000e9e:	b083      	sub	sp, #12
  USART_TypeDef *u = sdp->usart;
  uint16_t cr1 = u->CR1;
  uint16_t sr = u->SR;

  /* Special case, LIN break detection.*/
  if (sr & USART_SR_LBD) {
 8000ea0:	05d8      	lsls	r0, r3, #23
 * @param[in] sdp       communication channel associated to the USART
 */
static void serve_interrupt(SerialDriver *sdp) {
  USART_TypeDef *u = sdp->usart;
  uint16_t cr1 = u->CR1;
  uint16_t sr = u->SR;
 8000ea2:	b29c      	uxth	r4, r3

  /* Special case, LIN break detection.*/
  if (sr & USART_SR_LBD) {
 8000ea4:	f100 8089 	bmi.w	8000fba <serve_interrupt.8720.4185+0x12a>
 8000ea8:	2320      	movs	r3, #32
 8000eaa:	f383 8811 	msr	BASEPRI, r3
    osalSysUnlockFromISR();
  }

  /* Data available.*/
  osalSysLockFromISR();
  while (sr & (USART_SR_RXNE | USART_SR_ORE | USART_SR_NE | USART_SR_FE |
 8000eae:	f014 0f2f 	tst.w	r4, #47	; 0x2f
 8000eb2:	d050      	beq.n	8000f56 <serve_interrupt.8720.4185+0xc6>
    sts |= SD_PARITY_ERROR;
  if (sr & USART_SR_FE)
    sts |= SD_FRAMING_ERROR;
  if (sr & USART_SR_NE)
    sts |= SD_NOISE_ERROR;
  chnAddFlagsI(sdp, sts);
 8000eb4:	f105 0804 	add.w	r8, r5, #4
  *iqp->q_wrptr++ = b;
  if (iqp->q_wrptr >= iqp->q_top) {
    iqp->q_wrptr = iqp->q_buffer;
  }

  osalThreadDequeueNextI(&iqp->q_waiting, MSG_OK);
 8000eb8:	f105 070c 	add.w	r7, r5, #12

  tp = queue_fifo_remove(tqp);

  chDbgAssert(tp->state == CH_STATE_QUEUED, "invalid state");

  tp->u.rdymsg = msg;
 8000ebc:	f04f 0900 	mov.w	r9, #0
 8000ec0:	e009      	b.n	8000ed6 <serve_interrupt.8720.4185+0x46>

    /* Error condition detection.*/
    if (sr & (USART_SR_ORE | USART_SR_NE | USART_SR_FE  | USART_SR_PE))
      set_error(sdp, sr);
    b = (uint8_t)u->DR & sdp->rxmask;
    if (sr & USART_SR_RXNE)
 8000ec2:	06a1      	lsls	r1, r4, #26
    uint8_t b;

    /* Error condition detection.*/
    if (sr & (USART_SR_ORE | USART_SR_NE | USART_SR_FE  | USART_SR_PE))
      set_error(sdp, sr);
    b = (uint8_t)u->DR & sdp->rxmask;
 8000ec4:	6873      	ldr	r3, [r6, #4]
 8000ec6:	f895 b078 	ldrb.w	fp, [r5, #120]	; 0x78
    if (sr & USART_SR_RXNE)
 8000eca:	d41f      	bmi.n	8000f0c <serve_interrupt.8720.4185+0x7c>
      sdIncomingDataI(sdp, b);
    sr = u->SR;
 8000ecc:	6834      	ldr	r4, [r6, #0]
 8000ece:	b2a4      	uxth	r4, r4
    osalSysUnlockFromISR();
  }

  /* Data available.*/
  osalSysLockFromISR();
  while (sr & (USART_SR_RXNE | USART_SR_ORE | USART_SR_NE | USART_SR_FE |
 8000ed0:	f014 0f2f 	tst.w	r4, #47	; 0x2f
 8000ed4:	d03f      	beq.n	8000f56 <serve_interrupt.8720.4185+0xc6>
               USART_SR_PE)) {
    uint8_t b;

    /* Error condition detection.*/
    if (sr & (USART_SR_ORE | USART_SR_NE | USART_SR_FE  | USART_SR_PE))
 8000ed6:	0721      	lsls	r1, r4, #28
 8000ed8:	d0f3      	beq.n	8000ec2 <serve_interrupt.8720.4185+0x32>
 *
 * @param[in] sdp       pointer to a @p SerialDriver object
 * @param[in] sr        USART SR register value
 */
static void set_error(SerialDriver *sdp, uint16_t sr) {
  eventflags_t sts = 0;
 8000eda:	f014 0f08 	tst.w	r4, #8
 8000ede:	bf14      	ite	ne
 8000ee0:	2180      	movne	r1, #128	; 0x80
 8000ee2:	2100      	moveq	r1, #0

  if (sr & USART_SR_ORE)
    sts |= SD_OVERRUN_ERROR;
  if (sr & USART_SR_PE)
 8000ee4:	07e2      	lsls	r2, r4, #31
    sts |= SD_PARITY_ERROR;
 8000ee6:	bf48      	it	mi
 8000ee8:	f041 0120 	orrmi.w	r1, r1, #32
  if (sr & USART_SR_FE)
 8000eec:	07a3      	lsls	r3, r4, #30
    sts |= SD_FRAMING_ERROR;
 8000eee:	bf48      	it	mi
 8000ef0:	f041 0140 	orrmi.w	r1, r1, #64	; 0x40
  if (sr & USART_SR_NE)
 8000ef4:	0760      	lsls	r0, r4, #29
    sts |= SD_NOISE_ERROR;
 8000ef6:	bf48      	it	mi
 8000ef8:	f441 7180 	orrmi.w	r1, r1, #256	; 0x100
 * @iclass
 */
static inline void osalEventBroadcastFlagsI(event_source_t *esp,
                                            eventflags_t flags) {

  chEvtBroadcastFlagsI(esp, flags);
 8000efc:	4640      	mov	r0, r8
 8000efe:	f001 fa5f 	bl	80023c0 <chEvtBroadcastFlagsI>

    /* Error condition detection.*/
    if (sr & (USART_SR_ORE | USART_SR_NE | USART_SR_FE  | USART_SR_PE))
      set_error(sdp, sr);
    b = (uint8_t)u->DR & sdp->rxmask;
    if (sr & USART_SR_RXNE)
 8000f02:	06a1      	lsls	r1, r4, #26
    uint8_t b;

    /* Error condition detection.*/
    if (sr & (USART_SR_ORE | USART_SR_NE | USART_SR_FE  | USART_SR_PE))
      set_error(sdp, sr);
    b = (uint8_t)u->DR & sdp->rxmask;
 8000f04:	6873      	ldr	r3, [r6, #4]
 8000f06:	f895 b078 	ldrb.w	fp, [r5, #120]	; 0x78
    if (sr & USART_SR_RXNE)
 8000f0a:	d5df      	bpl.n	8000ecc <serve_interrupt.8720.4185+0x3c>
void sdIncomingDataI(SerialDriver *sdp, uint8_t b) {

  osalDbgCheckClassI();
  osalDbgCheck(sdp != NULL);

  if (iqIsEmptyI(&sdp->iqueue))
 8000f0c:	696a      	ldr	r2, [r5, #20]
 8000f0e:	2a00      	cmp	r2, #0
 8000f10:	d040      	beq.n	8000f94 <serve_interrupt.8720.4185+0x104>
 */
msg_t iqPutI(input_queue_t *iqp, uint8_t b) {

  osalDbgCheckClassI();

  if (iqIsFullI(iqp)) {
 8000f12:	6a2a      	ldr	r2, [r5, #32]
 8000f14:	6a69      	ldr	r1, [r5, #36]	; 0x24
 8000f16:	428a      	cmp	r2, r1
 8000f18:	d046      	beq.n	8000fa8 <serve_interrupt.8720.4185+0x118>
    return MSG_TIMEOUT;
  }

  iqp->q_counter++;
 8000f1a:	6968      	ldr	r0, [r5, #20]
    uint8_t b;

    /* Error condition detection.*/
    if (sr & (USART_SR_ORE | USART_SR_NE | USART_SR_FE  | USART_SR_PE))
      set_error(sdp, sr);
    b = (uint8_t)u->DR & sdp->rxmask;
 8000f1c:	ea0b 0303 	and.w	r3, fp, r3
  *iqp->q_wrptr++ = b;
 8000f20:	1c51      	adds	r1, r2, #1

  if (iqIsFullI(iqp)) {
    return MSG_TIMEOUT;
  }

  iqp->q_counter++;
 8000f22:	3001      	adds	r0, #1
  *iqp->q_wrptr++ = b;
 8000f24:	6229      	str	r1, [r5, #32]

  if (iqIsFullI(iqp)) {
    return MSG_TIMEOUT;
  }

  iqp->q_counter++;
 8000f26:	6168      	str	r0, [r5, #20]
  *iqp->q_wrptr++ = b;
 8000f28:	7013      	strb	r3, [r2, #0]
  if (iqp->q_wrptr >= iqp->q_top) {
 8000f2a:	6a2a      	ldr	r2, [r5, #32]
 8000f2c:	69eb      	ldr	r3, [r5, #28]
 8000f2e:	429a      	cmp	r2, r3
 8000f30:	d301      	bcc.n	8000f36 <serve_interrupt.8720.4185+0xa6>
    iqp->q_wrptr = iqp->q_buffer;
 8000f32:	69ab      	ldr	r3, [r5, #24]
 8000f34:	622b      	str	r3, [r5, #32]
 *
 * @notapi
 */
static inline bool queue_notempty(const threads_queue_t *tqp) {

  return (bool)(tqp->next != (const thread_t *)tqp);
 8000f36:	68eb      	ldr	r3, [r5, #12]
 *
 * @iclass
 */
void chThdDequeueNextI(threads_queue_t *tqp, msg_t msg) {

  if (queue_notempty(tqp)) {
 8000f38:	429f      	cmp	r7, r3
 8000f3a:	d0c7      	beq.n	8000ecc <serve_interrupt.8720.4185+0x3c>
}

static inline thread_t *queue_fifo_remove(threads_queue_t *tqp) {
  thread_t *tp = tqp->next;

  tqp->next             = tp->queue.next;
 8000f3c:	681a      	ldr	r2, [r3, #0]
  (void) chSchReadyI(tp);
 8000f3e:	4618      	mov	r0, r3
 8000f40:	60ea      	str	r2, [r5, #12]
  tqp->next->queue.prev = (thread_t *)tqp;
 8000f42:	6057      	str	r7, [r2, #4]

  tp = queue_fifo_remove(tqp);

  chDbgAssert(tp->state == CH_STATE_QUEUED, "invalid state");

  tp->u.rdymsg = msg;
 8000f44:	f8c3 9024 	str.w	r9, [r3, #36]	; 0x24
  (void) chSchReadyI(tp);
 8000f48:	f001 f992 	bl	8002270 <chSchReadyI>
    if (sr & USART_SR_RXNE)
      sdIncomingDataI(sdp, b);
    sr = u->SR;
 8000f4c:	6834      	ldr	r4, [r6, #0]
 8000f4e:	b2a4      	uxth	r4, r4
    osalSysUnlockFromISR();
  }

  /* Data available.*/
  osalSysLockFromISR();
  while (sr & (USART_SR_RXNE | USART_SR_ORE | USART_SR_NE | USART_SR_FE |
 8000f50:	f014 0f2f 	tst.w	r4, #47	; 0x2f
 8000f54:	d1bf      	bne.n	8000ed6 <serve_interrupt.8720.4185+0x46>
 8000f56:	2300      	movs	r3, #0
 8000f58:	f383 8811 	msr	BASEPRI, r3
    sr = u->SR;
  }
  osalSysUnlockFromISR();

  /* Transmission buffer empty.*/
  if ((cr1 & USART_CR1_TXEIE) && (sr & USART_SR_TXE)) {
 8000f5c:	f01a 0f80 	tst.w	sl, #128	; 0x80
 8000f60:	d001      	beq.n	8000f66 <serve_interrupt.8720.4185+0xd6>
 8000f62:	0622      	lsls	r2, r4, #24
 8000f64:	d438      	bmi.n	8000fd8 <serve_interrupt.8720.4185+0x148>
      u->DR = b;
    osalSysUnlockFromISR();
  }

  /* Physical transmission end.*/
  if (sr & USART_SR_TC) {
 8000f66:	0663      	lsls	r3, r4, #25
 8000f68:	d511      	bpl.n	8000f8e <serve_interrupt.8720.4185+0xfe>
 8000f6a:	2320      	movs	r3, #32
 8000f6c:	f383 8811 	msr	BASEPRI, r3
    osalSysLockFromISR();
    if (oqIsEmptyI(&sdp->oqueue))
 8000f70:	6c6a      	ldr	r2, [r5, #68]	; 0x44
 8000f72:	6cab      	ldr	r3, [r5, #72]	; 0x48
 8000f74:	429a      	cmp	r2, r3
 8000f76:	d055      	beq.n	8001024 <serve_interrupt.8720.4185+0x194>
      chnAddFlagsI(sdp, CHN_TRANSMISSION_END);
    u->CR1 = cr1 & ~USART_CR1_TCIE;
 8000f78:	f64f 73bf 	movw	r3, #65471	; 0xffbf
 8000f7c:	ea0a 0303 	and.w	r3, sl, r3
    u->SR = ~USART_SR_TC;
 8000f80:	f06f 0240 	mvn.w	r2, #64	; 0x40
  /* Physical transmission end.*/
  if (sr & USART_SR_TC) {
    osalSysLockFromISR();
    if (oqIsEmptyI(&sdp->oqueue))
      chnAddFlagsI(sdp, CHN_TRANSMISSION_END);
    u->CR1 = cr1 & ~USART_CR1_TCIE;
 8000f84:	60f3      	str	r3, [r6, #12]
 8000f86:	2300      	movs	r3, #0
    u->SR = ~USART_SR_TC;
 8000f88:	6032      	str	r2, [r6, #0]
 8000f8a:	f383 8811 	msr	BASEPRI, r3
    osalSysUnlockFromISR();
  }
}
 8000f8e:	b003      	add	sp, #12
 8000f90:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
 8000f94:	2104      	movs	r1, #4
 8000f96:	4640      	mov	r0, r8
 8000f98:	9301      	str	r3, [sp, #4]
 8000f9a:	f001 fa11 	bl	80023c0 <chEvtBroadcastFlagsI>
 */
msg_t iqPutI(input_queue_t *iqp, uint8_t b) {

  osalDbgCheckClassI();

  if (iqIsFullI(iqp)) {
 8000f9e:	6a2a      	ldr	r2, [r5, #32]
 8000fa0:	6a69      	ldr	r1, [r5, #36]	; 0x24
 8000fa2:	9b01      	ldr	r3, [sp, #4]
 8000fa4:	428a      	cmp	r2, r1
 8000fa6:	d1b8      	bne.n	8000f1a <serve_interrupt.8720.4185+0x8a>
 8000fa8:	6969      	ldr	r1, [r5, #20]
 8000faa:	2900      	cmp	r1, #0
 8000fac:	d0b5      	beq.n	8000f1a <serve_interrupt.8720.4185+0x8a>
 8000fae:	4640      	mov	r0, r8
 8000fb0:	f44f 6180 	mov.w	r1, #1024	; 0x400
 8000fb4:	f001 fa04 	bl	80023c0 <chEvtBroadcastFlagsI>
 8000fb8:	e788      	b.n	8000ecc <serve_interrupt.8720.4185+0x3c>
 8000fba:	2320      	movs	r3, #32
 8000fbc:	f383 8811 	msr	BASEPRI, r3
 8000fc0:	f44f 7100 	mov.w	r1, #512	; 0x200
 8000fc4:	1d28      	adds	r0, r5, #4
 8000fc6:	f001 f9fb 	bl	80023c0 <chEvtBroadcastFlagsI>

  /* Special case, LIN break detection.*/
  if (sr & USART_SR_LBD) {
    osalSysLockFromISR();
    chnAddFlagsI(sdp, SD_BREAK_DETECTED);
    u->SR = ~USART_SR_LBD;
 8000fca:	f46f 7380 	mvn.w	r3, #256	; 0x100
 8000fce:	6033      	str	r3, [r6, #0]
 8000fd0:	2300      	movs	r3, #0
 8000fd2:	f383 8811 	msr	BASEPRI, r3
 8000fd6:	e767      	b.n	8000ea8 <serve_interrupt.8720.4185+0x18>
 8000fd8:	2320      	movs	r3, #32
 8000fda:	f383 8811 	msr	BASEPRI, r3
msg_t oqGetI(output_queue_t *oqp) {
  uint8_t b;

  osalDbgCheckClassI();

  if (oqIsEmptyI(oqp)) {
 8000fde:	6cab      	ldr	r3, [r5, #72]	; 0x48
 8000fe0:	6c6a      	ldr	r2, [r5, #68]	; 0x44
 8000fe2:	429a      	cmp	r2, r3
 8000fe4:	d026      	beq.n	8001034 <serve_interrupt.8720.4185+0x1a4>
    return MSG_TIMEOUT;
  }

  oqp->q_counter++;
 8000fe6:	6ba8      	ldr	r0, [r5, #56]	; 0x38
  b = *oqp->q_rdptr++;
  if (oqp->q_rdptr >= oqp->q_top) {
 8000fe8:	6c29      	ldr	r1, [r5, #64]	; 0x40
  if (oqIsEmptyI(oqp)) {
    return MSG_TIMEOUT;
  }

  oqp->q_counter++;
  b = *oqp->q_rdptr++;
 8000fea:	1c5a      	adds	r2, r3, #1

  if (oqIsEmptyI(oqp)) {
    return MSG_TIMEOUT;
  }

  oqp->q_counter++;
 8000fec:	3001      	adds	r0, #1
 8000fee:	63a8      	str	r0, [r5, #56]	; 0x38
  b = *oqp->q_rdptr++;
 8000ff0:	64aa      	str	r2, [r5, #72]	; 0x48
  if (oqp->q_rdptr >= oqp->q_top) {
 8000ff2:	428a      	cmp	r2, r1
  if (oqIsEmptyI(oqp)) {
    return MSG_TIMEOUT;
  }

  oqp->q_counter++;
  b = *oqp->q_rdptr++;
 8000ff4:	781f      	ldrb	r7, [r3, #0]
  if (oqp->q_rdptr >= oqp->q_top) {
 8000ff6:	d301      	bcc.n	8000ffc <serve_interrupt.8720.4185+0x16c>
    oqp->q_rdptr = oqp->q_buffer;
 8000ff8:	6beb      	ldr	r3, [r5, #60]	; 0x3c
 8000ffa:	64ab      	str	r3, [r5, #72]	; 0x48
 *
 * @notapi
 */
static inline bool queue_notempty(const threads_queue_t *tqp) {

  return (bool)(tqp->next != (const thread_t *)tqp);
 8000ffc:	6b2b      	ldr	r3, [r5, #48]	; 0x30
  }

  osalThreadDequeueNextI(&oqp->q_waiting, MSG_OK);
 8000ffe:	f105 0230 	add.w	r2, r5, #48	; 0x30
 8001002:	429a      	cmp	r2, r3
 8001004:	d009      	beq.n	800101a <serve_interrupt.8720.4185+0x18a>
}

static inline thread_t *queue_fifo_remove(threads_queue_t *tqp) {
  thread_t *tp = tqp->next;

  tqp->next             = tp->queue.next;
 8001006:	6819      	ldr	r1, [r3, #0]

  tp = queue_fifo_remove(tqp);

  chDbgAssert(tp->state == CH_STATE_QUEUED, "invalid state");

  tp->u.rdymsg = msg;
 8001008:	f04f 0e00 	mov.w	lr, #0
 800100c:	6329      	str	r1, [r5, #48]	; 0x30
  (void) chSchReadyI(tp);
 800100e:	4618      	mov	r0, r3
  tqp->next->queue.prev = (thread_t *)tqp;
 8001010:	604a      	str	r2, [r1, #4]

  tp = queue_fifo_remove(tqp);

  chDbgAssert(tp->state == CH_STATE_QUEUED, "invalid state");

  tp->u.rdymsg = msg;
 8001012:	f8c3 e024 	str.w	lr, [r3, #36]	; 0x24
  (void) chSchReadyI(tp);
 8001016:	f001 f92b 	bl	8002270 <chSchReadyI>
    if (b < MSG_OK) {
      chnAddFlagsI(sdp, CHN_OUTPUT_EMPTY);
      u->CR1 = (cr1 & ~USART_CR1_TXEIE) | USART_CR1_TCIE;
    }
    else
      u->DR = b;
 800101a:	6077      	str	r7, [r6, #4]
 800101c:	2300      	movs	r3, #0
 800101e:	f383 8811 	msr	BASEPRI, r3
 8001022:	e7a0      	b.n	8000f66 <serve_interrupt.8720.4185+0xd6>
  }

  /* Physical transmission end.*/
  if (sr & USART_SR_TC) {
    osalSysLockFromISR();
    if (oqIsEmptyI(&sdp->oqueue))
 8001024:	6bab      	ldr	r3, [r5, #56]	; 0x38
 8001026:	2b00      	cmp	r3, #0
 8001028:	d0a6      	beq.n	8000f78 <serve_interrupt.8720.4185+0xe8>
 800102a:	1d28      	adds	r0, r5, #4
 800102c:	2110      	movs	r1, #16
 800102e:	f001 f9c7 	bl	80023c0 <chEvtBroadcastFlagsI>
 8001032:	e7a1      	b.n	8000f78 <serve_interrupt.8720.4185+0xe8>
msg_t oqGetI(output_queue_t *oqp) {
  uint8_t b;

  osalDbgCheckClassI();

  if (oqIsEmptyI(oqp)) {
 8001034:	6baa      	ldr	r2, [r5, #56]	; 0x38
 8001036:	2a00      	cmp	r2, #0
 8001038:	d0d5      	beq.n	8000fe6 <serve_interrupt.8720.4185+0x156>
 800103a:	1d28      	adds	r0, r5, #4
 800103c:	2108      	movs	r1, #8
 800103e:	f001 f9bf 	bl	80023c0 <chEvtBroadcastFlagsI>
    msg_t b;
    osalSysLockFromISR();
    b = oqGetI(&sdp->oqueue);
    if (b < MSG_OK) {
      chnAddFlagsI(sdp, CHN_OUTPUT_EMPTY);
      u->CR1 = (cr1 & ~USART_CR1_TXEIE) | USART_CR1_TCIE;
 8001042:	f64f 733f 	movw	r3, #65343	; 0xff3f
 8001046:	ea0a 0303 	and.w	r3, sl, r3
 800104a:	f043 0340 	orr.w	r3, r3, #64	; 0x40
 800104e:	60f3      	str	r3, [r6, #12]
 8001050:	e7e4      	b.n	800101c <serve_interrupt.8720.4185+0x18c>
 8001052:	bf00      	nop
 8001054:	f3af 8000 	nop.w
 8001058:	f3af 8000 	nop.w
 800105c:	f3af 8000 	nop.w

08001060 <VectorDC.4180>:
/**
 * @brief   USART3 interrupt handler.
 *
 * @isr
 */
OSAL_IRQ_HANDLER(STM32_USART3_HANDLER) {
 8001060:	b508      	push	{r3, lr}

  OSAL_IRQ_PROLOGUE();

  serve_interrupt(&SD3);
 8001062:	f640 2090 	movw	r0, #2704	; 0xa90
 8001066:	f2c2 0000 	movt	r0, #8192	; 0x2000
 800106a:	f7ff ff11 	bl	8000e90 <serve_interrupt.8720.4185>

  OSAL_IRQ_EPILOGUE();
}
 800106e:	e8bd 4008 	ldmia.w	sp!, {r3, lr}

  OSAL_IRQ_PROLOGUE();

  serve_interrupt(&SD3);

  OSAL_IRQ_EPILOGUE();
 8001072:	f000 bfd5 	b.w	8002020 <_port_irq_epilogue>
 8001076:	bf00      	nop
 8001078:	f3af 8000 	nop.w
 800107c:	f3af 8000 	nop.w

08001080 <VectorD8.4183>:
/**
 * @brief   USART2 interrupt handler.
 *
 * @isr
 */
OSAL_IRQ_HANDLER(STM32_USART2_HANDLER) {
 8001080:	b508      	push	{r3, lr}

  OSAL_IRQ_PROLOGUE();

  serve_interrupt(&SD2);
 8001082:	f640 0050 	movw	r0, #2128	; 0x850
 8001086:	f2c2 0000 	movt	r0, #8192	; 0x2000
 800108a:	f7ff ff01 	bl	8000e90 <serve_interrupt.8720.4185>

  OSAL_IRQ_EPILOGUE();
}
 800108e:	e8bd 4008 	ldmia.w	sp!, {r3, lr}

  OSAL_IRQ_PROLOGUE();

  serve_interrupt(&SD2);

  OSAL_IRQ_EPILOGUE();
 8001092:	f000 bfc5 	b.w	8002020 <_port_irq_epilogue>
 8001096:	bf00      	nop
 8001098:	f3af 8000 	nop.w
 800109c:	f3af 8000 	nop.w

080010a0 <__early_init>:
void stm32_clock_init(void) {

#if !STM32_NO_INIT
  /* HSI setup, it enforces the reset situation in order to handle possible
     problems with JTAG probes and re-initializations.*/
  RCC->CR |= RCC_CR_HSION;                  /* Make sure HSI is ON.         */
 80010a0:	f44f 5380 	mov.w	r3, #4096	; 0x1000
 80010a4:	f2c4 0302 	movt	r3, #16386	; 0x4002
 80010a8:	681a      	ldr	r2, [r3, #0]
  while (!(RCC->CR & RCC_CR_HSIRDY))
 80010aa:	4619      	mov	r1, r3
void stm32_clock_init(void) {

#if !STM32_NO_INIT
  /* HSI setup, it enforces the reset situation in order to handle possible
     problems with JTAG probes and re-initializations.*/
  RCC->CR |= RCC_CR_HSION;                  /* Make sure HSI is ON.         */
 80010ac:	f042 0201 	orr.w	r2, r2, #1
 80010b0:	601a      	str	r2, [r3, #0]
  while (!(RCC->CR & RCC_CR_HSIRDY))
 80010b2:	680a      	ldr	r2, [r1, #0]
 80010b4:	f44f 5380 	mov.w	r3, #4096	; 0x1000
 80010b8:	0792      	lsls	r2, r2, #30
 80010ba:	f2c4 0302 	movt	r3, #16386	; 0x4002
 80010be:	d5f8      	bpl.n	80010b2 <__early_init+0x12>
    ;                                       /* Wait until HSI is stable.    */
  RCC->CR &= RCC_CR_HSITRIM | RCC_CR_HSION; /* CR Reset value.              */
 80010c0:	6819      	ldr	r1, [r3, #0]
  RCC->CFGR = 0;                            /* CFGR reset value.            */
 80010c2:	2200      	movs	r2, #0
  /* HSI setup, it enforces the reset situation in order to handle possible
     problems with JTAG probes and re-initializations.*/
  RCC->CR |= RCC_CR_HSION;                  /* Make sure HSI is ON.         */
  while (!(RCC->CR & RCC_CR_HSIRDY))
    ;                                       /* Wait until HSI is stable.    */
  RCC->CR &= RCC_CR_HSITRIM | RCC_CR_HSION; /* CR Reset value.              */
 80010c4:	f001 01f9 	and.w	r1, r1, #249	; 0xf9
 80010c8:	6019      	str	r1, [r3, #0]
  RCC->CFGR = 0;                            /* CFGR reset value.            */
  while ((RCC->CFGR & RCC_CFGR_SWS) != RCC_CFGR_SWS_HSI)
 80010ca:	4619      	mov	r1, r3
     problems with JTAG probes and re-initializations.*/
  RCC->CR |= RCC_CR_HSION;                  /* Make sure HSI is ON.         */
  while (!(RCC->CR & RCC_CR_HSIRDY))
    ;                                       /* Wait until HSI is stable.    */
  RCC->CR &= RCC_CR_HSITRIM | RCC_CR_HSION; /* CR Reset value.              */
  RCC->CFGR = 0;                            /* CFGR reset value.            */
 80010cc:	605a      	str	r2, [r3, #4]
  while ((RCC->CFGR & RCC_CFGR_SWS) != RCC_CFGR_SWS_HSI)
 80010ce:	684a      	ldr	r2, [r1, #4]
 80010d0:	f44f 5380 	mov.w	r3, #4096	; 0x1000
 80010d4:	f012 0f0c 	tst.w	r2, #12
 80010d8:	f2c4 0302 	movt	r3, #16386	; 0x4002
 80010dc:	d1f7      	bne.n	80010ce <__early_init+0x2e>
#if defined(STM32_HSE_BYPASS)
  /* HSE Bypass.*/
  RCC->CR |= RCC_CR_HSEON | RCC_CR_HSEBYP;
#endif
  /* HSE activation.*/
  RCC->CR |= RCC_CR_HSEON;
 80010de:	681a      	ldr	r2, [r3, #0]
  while (!(RCC->CR & RCC_CR_HSERDY))
 80010e0:	4619      	mov	r1, r3
#if defined(STM32_HSE_BYPASS)
  /* HSE Bypass.*/
  RCC->CR |= RCC_CR_HSEON | RCC_CR_HSEBYP;
#endif
  /* HSE activation.*/
  RCC->CR |= RCC_CR_HSEON;
 80010e2:	f442 3280 	orr.w	r2, r2, #65536	; 0x10000
 80010e6:	601a      	str	r2, [r3, #0]
  while (!(RCC->CR & RCC_CR_HSERDY))
 80010e8:	680a      	ldr	r2, [r1, #0]
 80010ea:	f44f 5380 	mov.w	r3, #4096	; 0x1000
 80010ee:	0390      	lsls	r0, r2, #14
 80010f0:	f2c4 0302 	movt	r3, #16386	; 0x4002
 80010f4:	d5f8      	bpl.n	80010e8 <__early_init+0x48>
    ;                                       /* Waits until LSI is stable.   */
#endif

#if STM32_ACTIVATE_PLL
  /* PLL activation.*/
  RCC->CFGR |= STM32_PLLMUL | STM32_PLLXTPRE | STM32_PLLSRC;
 80010f6:	685a      	ldr	r2, [r3, #4]
  RCC->CR   |= RCC_CR_PLLON;
  while (!(RCC->CR & RCC_CR_PLLRDY))
 80010f8:	4619      	mov	r1, r3
    ;                                       /* Waits until LSI is stable.   */
#endif

#if STM32_ACTIVATE_PLL
  /* PLL activation.*/
  RCC->CFGR |= STM32_PLLMUL | STM32_PLLXTPRE | STM32_PLLSRC;
 80010fa:	f442 3280 	orr.w	r2, r2, #65536	; 0x10000
 80010fe:	605a      	str	r2, [r3, #4]
  RCC->CR   |= RCC_CR_PLLON;
 8001100:	681a      	ldr	r2, [r3, #0]
 8001102:	f042 7280 	orr.w	r2, r2, #16777216	; 0x1000000
 8001106:	601a      	str	r2, [r3, #0]
  while (!(RCC->CR & RCC_CR_PLLRDY))
 8001108:	680a      	ldr	r2, [r1, #0]
 800110a:	f44f 5380 	mov.w	r3, #4096	; 0x1000
 800110e:	0192      	lsls	r2, r2, #6
 8001110:	f2c4 0302 	movt	r3, #16386	; 0x4002
 8001114:	d5f8      	bpl.n	8001108 <__early_init+0x68>
              STM32_PLLSRC | STM32_ADCPRE | STM32_PPRE2  | STM32_PPRE1    |
              STM32_HPRE;
#endif

  /* Flash setup and final clock selection.   */
  FLASH->ACR = STM32_FLASHBITS;
 8001116:	f44f 5200 	mov.w	r2, #8192	; 0x2000
 800111a:	f2c4 0202 	movt	r2, #16386	; 0x4002
 800111e:	2110      	movs	r1, #16
#if STM32_HAS_USB
  RCC->CFGR = STM32_MCOSEL | STM32_USBPRE | STM32_PLLMUL | STM32_PLLXTPRE |
              STM32_PLLSRC | STM32_ADCPRE | STM32_PPRE2  | STM32_PPRE1    |
              STM32_HPRE;
#else
  RCC->CFGR = STM32_MCOSEL |                STM32_PLLMUL | STM32_PLLXTPRE |
 8001120:	f44f 3080 	mov.w	r0, #65536	; 0x10000
 8001124:	6058      	str	r0, [r3, #4]
              STM32_PLLSRC | STM32_ADCPRE | STM32_PPRE2  | STM32_PPRE1    |
              STM32_HPRE;
#endif

  /* Flash setup and final clock selection.   */
  FLASH->ACR = STM32_FLASHBITS;
 8001126:	6011      	str	r1, [r2, #0]

  /* Switching to the configured clock source if it is different from HSI.*/
#if (STM32_SW != STM32_SW_HSI)
  /* Switches clock source.*/
  RCC->CFGR |= STM32_SW;
 8001128:	6859      	ldr	r1, [r3, #4]
  while ((RCC->CFGR & RCC_CFGR_SWS) != (STM32_SW << 2))
 800112a:	461a      	mov	r2, r3
  FLASH->ACR = STM32_FLASHBITS;

  /* Switching to the configured clock source if it is different from HSI.*/
#if (STM32_SW != STM32_SW_HSI)
  /* Switches clock source.*/
  RCC->CFGR |= STM32_SW;
 800112c:	f041 0102 	orr.w	r1, r1, #2
 8001130:	6059      	str	r1, [r3, #4]
  while ((RCC->CFGR & RCC_CFGR_SWS) != (STM32_SW << 2))
 8001132:	6853      	ldr	r3, [r2, #4]
 8001134:	f003 030c 	and.w	r3, r3, #12
 8001138:	2b08      	cmp	r3, #8
 800113a:	d1fa      	bne.n	8001132 <__early_init+0x92>
 * any other initialization.
 */
void __early_init(void) {

  stm32_clock_init();
}
 800113c:	4770      	bx	lr
 800113e:	bf00      	nop

08001140 <chThdExit>:
 *
 * @param[in] msg       thread exit code
 *
 * @api
 */
void chThdExit(msg_t msg) {
 8001140:	b538      	push	{r3, r4, r5, lr}
 8001142:	4602      	mov	r2, r0
 8001144:	2320      	movs	r3, #32
 8001146:	f383 8811 	msr	BASEPRI, r3
 * @param[in] msg       thread exit code
 *
 * @sclass
 */
void chThdExitS(msg_t msg) {
  thread_t *tp = currp;
 800114a:	f640 03d8 	movw	r3, #2264	; 0x8d8
 800114e:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8001152:	699c      	ldr	r4, [r3, #24]
 *
 * @notapi
 */
static inline bool list_notempty(threads_list_t *tlp) {

  return (bool)(tlp->next != (thread_t *)tlp);
 8001154:	6aa0      	ldr	r0, [r4, #40]	; 0x28
  /* Exit handler hook.*/
  CH_CFG_THREAD_EXIT_HOOK(tp);

#if CH_CFG_USE_WAITEXIT == TRUE
  /* Waking up any waiting thread.*/
  while (list_notempty(&tp->waiting)) {
 8001156:	f104 0528 	add.w	r5, r4, #40	; 0x28
 800115a:	42a8      	cmp	r0, r5
 */
void chThdExitS(msg_t msg) {
  thread_t *tp = currp;

  /* Storing exit message.*/
  tp->u.exitcode = msg;
 800115c:	6262      	str	r2, [r4, #36]	; 0x24
  /* Exit handler hook.*/
  CH_CFG_THREAD_EXIT_HOOK(tp);

#if CH_CFG_USE_WAITEXIT == TRUE
  /* Waking up any waiting thread.*/
  while (list_notempty(&tp->waiting)) {
 800115e:	d006      	beq.n	800116e <chThdExit+0x2e>
}

static inline thread_t *list_remove(threads_list_t *tlp) {

  thread_t *tp = tlp->next;
  tlp->next = tp->queue.next;
 8001160:	6803      	ldr	r3, [r0, #0]
 8001162:	62a3      	str	r3, [r4, #40]	; 0x28
    (void) chSchReadyI(list_remove(&tp->waiting));
 8001164:	f001 f884 	bl	8002270 <chSchReadyI>
 *
 * @notapi
 */
static inline bool list_notempty(threads_list_t *tlp) {

  return (bool)(tlp->next != (thread_t *)tlp);
 8001168:	6aa0      	ldr	r0, [r4, #40]	; 0x28
  /* Exit handler hook.*/
  CH_CFG_THREAD_EXIT_HOOK(tp);

#if CH_CFG_USE_WAITEXIT == TRUE
  /* Waking up any waiting thread.*/
  while (list_notempty(&tp->waiting)) {
 800116a:	42a8      	cmp	r0, r5
 800116c:	d1f8      	bne.n	8001160 <chThdExit+0x20>

#if CH_CFG_USE_REGISTRY == TRUE
  /* Static threads with no references are immediately removed from the
     registry because there is no memory to recover.*/
#if CH_CFG_USE_DYNAMIC == TRUE
  if ((tp->refs == (trefs_t)0) &&
 800116e:	f894 3022 	ldrb.w	r3, [r4, #34]	; 0x22
 8001172:	b94b      	cbnz	r3, 8001188 <chThdExit+0x48>
      ((tp->flags & CH_FLAG_MODE_MASK) == CH_FLAG_MODE_STATIC)) {
 8001174:	f894 3021 	ldrb.w	r3, [r4, #33]	; 0x21

#if CH_CFG_USE_REGISTRY == TRUE
  /* Static threads with no references are immediately removed from the
     registry because there is no memory to recover.*/
#if CH_CFG_USE_DYNAMIC == TRUE
  if ((tp->refs == (trefs_t)0) &&
 8001178:	0799      	lsls	r1, r3, #30
      ((tp->flags & CH_FLAG_MODE_MASK) == CH_FLAG_MODE_STATIC)) {
    REG_REMOVE(tp);
 800117a:	bf01      	itttt	eq
 800117c:	6922      	ldreq	r2, [r4, #16]
 800117e:	6963      	ldreq	r3, [r4, #20]
 8001180:	611a      	streq	r2, [r3, #16]
 8001182:	6922      	ldreq	r2, [r4, #16]
 8001184:	bf08      	it	eq
 8001186:	6153      	streq	r3, [r2, #20]
  }
#endif
#endif

  /* Going into final state.*/
  chSchGoSleepS(CH_STATE_FINAL);
 8001188:	200f      	movs	r0, #15
void chThdExit(msg_t msg) {

  chSysLock();
  chThdExitS(msg);
  /* The thread never returns here.*/
}
 800118a:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
  }
#endif
#endif

  /* Going into final state.*/
  chSchGoSleepS(CH_STATE_FINAL);
 800118e:	f001 b857 	b.w	8002240 <chSchGoSleepS>
 8001192:	bf00      	nop
 8001194:	f3af 8000 	nop.w
 8001198:	f3af 8000 	nop.w
 800119c:	f3af 8000 	nop.w

080011a0 <chSchDoReschedule>:
 *          itself or from within the port layer.
 *
 * @special
 */
void chSchDoReschedule(void) {
  thread_t *otp = currp;
 80011a0:	f640 02d8 	movw	r2, #2264	; 0x8d8
 80011a4:	f2c2 0200 	movt	r2, #8192	; 0x2000
  tp->queue.prev->queue.next = tp;
  tqp->prev                  = tp;
}

static inline thread_t *queue_fifo_remove(threads_queue_t *tqp) {
  thread_t *tp = tqp->next;
 80011a8:	6810      	ldr	r0, [r2, #0]
 * @note    Not a user function, it is meant to be invoked by the scheduler
 *          itself or from within the port layer.
 *
 * @special
 */
void chSchDoReschedule(void) {
 80011aa:	b470      	push	{r4, r5, r6}

  tqp->next             = tp->queue.next;
 80011ac:	6803      	ldr	r3, [r0, #0]
  thread_t *otp = currp;
 80011ae:	6995      	ldr	r5, [r2, #24]

  /* Picks the first thread from the ready queue and makes it current.*/
  currp = queue_fifo_remove(&ch.rlist.queue);
  currp->state = CH_STATE_CURRENT;
 80011b0:	2601      	movs	r6, #1
  chDbgCheck(tp != NULL);
  chDbgAssert((tp->state != CH_STATE_READY) &&
              (tp->state != CH_STATE_FINAL),
              "invalid state");

  tp->state = CH_STATE_READY;
 80011b2:	2100      	movs	r1, #0
 80011b4:	68ac      	ldr	r4, [r5, #8]
 80011b6:	6013      	str	r3, [r2, #0]
  tqp->next->queue.prev = (thread_t *)tqp;
 80011b8:	605a      	str	r2, [r3, #4]
void chSchDoReschedule(void) {
  thread_t *otp = currp;

  /* Picks the first thread from the ready queue and makes it current.*/
  currp = queue_fifo_remove(&ch.rlist.queue);
  currp->state = CH_STATE_CURRENT;
 80011ba:	f880 6020 	strb.w	r6, [r0, #32]
 */
void chSchDoReschedule(void) {
  thread_t *otp = currp;

  /* Picks the first thread from the ready queue and makes it current.*/
  currp = queue_fifo_remove(&ch.rlist.queue);
 80011be:	6190      	str	r0, [r2, #24]
  chDbgCheck(tp != NULL);
  chDbgAssert((tp->state != CH_STATE_READY) &&
              (tp->state != CH_STATE_FINAL),
              "invalid state");

  tp->state = CH_STATE_READY;
 80011c0:	f885 1020 	strb.w	r1, [r5, #32]
 80011c4:	e000      	b.n	80011c8 <chSchDoReschedule+0x28>
 80011c6:	681b      	ldr	r3, [r3, #0]
  cp = (thread_t *)&ch.rlist.queue;
  do {
    cp = cp->queue.next;
  } while (cp->prio > tp->prio);
 80011c8:	689a      	ldr	r2, [r3, #8]
 80011ca:	42a2      	cmp	r2, r4
 80011cc:	d8fb      	bhi.n	80011c6 <chSchDoReschedule+0x26>
  /* Insertion on prev.*/
  tp->queue.next             = cp;
  tp->queue.prev             = cp->queue.prev;
 80011ce:	685a      	ldr	r2, [r3, #4]
     ahead of its peers.*/
  otp = chSchReadyAheadI(otp);
#endif /* !(CH_CFG_TIME_QUANTUM > 0) */

  /* Swap operation as tail call.*/
  chSysSwitch(currp, otp);
 80011d0:	4629      	mov	r1, r5
  cp = (thread_t *)&ch.rlist.queue;
  do {
    cp = cp->queue.next;
  } while (cp->prio > tp->prio);
  /* Insertion on prev.*/
  tp->queue.next             = cp;
 80011d2:	602b      	str	r3, [r5, #0]
  tp->queue.prev             = cp->queue.prev;
 80011d4:	606a      	str	r2, [r5, #4]
  tp->queue.prev->queue.next = tp;
 80011d6:	6015      	str	r5, [r2, #0]
  cp->queue.prev             = tp;
 80011d8:	605d      	str	r5, [r3, #4]
  otp = chSchReadyAheadI(otp);
#endif /* !(CH_CFG_TIME_QUANTUM > 0) */

  /* Swap operation as tail call.*/
  chSysSwitch(currp, otp);
}
 80011da:	bc70      	pop	{r4, r5, r6}
     ahead of its peers.*/
  otp = chSchReadyAheadI(otp);
#endif /* !(CH_CFG_TIME_QUANTUM > 0) */

  /* Swap operation as tail call.*/
  chSysSwitch(currp, otp);
 80011dc:	f7ff b83a 	b.w	8000254 <_port_switch>

080011e0 <__init_ram_areas>:
}

/**
 * @brief   Performs the initialization of the various RAM areas.
 */
void __init_ram_areas(void) {
 80011e0:	b4f0      	push	{r4, r5, r6, r7}
 80011e2:	4e13      	ldr	r6, [pc, #76]	; (8001230 <__init_ram_areas+0x50>)
      tp++;
    }

    /* Zeroing clear area.*/
    while (p < rap->no_init_area) {
      *p = 0;
 80011e4:	2500      	movs	r5, #0
 80011e6:	f106 0770 	add.w	r7, r6, #112	; 0x70
void __init_ram_areas(void) {
#if CRT1_AREAS_NUMBER > 0
  const ram_init_area_t *rap = ram_areas;

  do {
    uint32_t *tp = rap->init_text_area;
 80011ea:	f1a6 0110 	sub.w	r1, r6, #16
 80011ee:	c91a      	ldmia	r1, {r1, r3, r4}
    uint32_t *p = rap->init_area;

    /* Copying initialization data.*/
    while (p < rap->clear_area) {
 80011f0:	42a3      	cmp	r3, r4
 80011f2:	d20d      	bcs.n	8001210 <__init_ram_areas+0x30>
 80011f4:	3904      	subs	r1, #4
 80011f6:	461a      	mov	r2, r3
      *p = *tp;
 80011f8:	f851 0f04 	ldr.w	r0, [r1, #4]!
 80011fc:	f842 0b04 	str.w	r0, [r2], #4
  do {
    uint32_t *tp = rap->init_text_area;
    uint32_t *p = rap->init_area;

    /* Copying initialization data.*/
    while (p < rap->clear_area) {
 8001200:	42a2      	cmp	r2, r4
 8001202:	d3f9      	bcc.n	80011f8 <__init_ram_areas+0x18>
 8001204:	43da      	mvns	r2, r3
 8001206:	4414      	add	r4, r2
 8001208:	f024 0403 	bic.w	r4, r4, #3
 800120c:	3404      	adds	r4, #4
 800120e:	4423      	add	r3, r4
      p++;
      tp++;
    }

    /* Zeroing clear area.*/
    while (p < rap->no_init_area) {
 8001210:	f856 2c04 	ldr.w	r2, [r6, #-4]
 8001214:	4293      	cmp	r3, r2
 8001216:	d203      	bcs.n	8001220 <__init_ram_areas+0x40>
      *p = 0;
 8001218:	f843 5b04 	str.w	r5, [r3], #4
      p++;
      tp++;
    }

    /* Zeroing clear area.*/
    while (p < rap->no_init_area) {
 800121c:	4293      	cmp	r3, r2
 800121e:	d3fb      	bcc.n	8001218 <__init_ram_areas+0x38>
      *p = 0;
      p++;
    }
    rap++;
  }
  while (rap < &ram_areas[CRT1_AREAS_NUMBER]);
 8001220:	42be      	cmp	r6, r7
 8001222:	f106 0310 	add.w	r3, r6, #16
 8001226:	d201      	bcs.n	800122c <__init_ram_areas+0x4c>
 8001228:	461e      	mov	r6, r3
 800122a:	e7de      	b.n	80011ea <__init_ram_areas+0xa>
#endif
}
 800122c:	bcf0      	pop	{r4, r5, r6, r7}
 800122e:	4770      	bx	lr
 8001230:	08002cc0 	.word	0x08002cc0
 8001234:	f3af 8000 	nop.w
 8001238:	f3af 8000 	nop.w
 800123c:	f3af 8000 	nop.w

08001240 <__default_exit>:
 */
#if !defined(__DOXYGEN__)
__attribute__((noreturn, weak))
#endif
/*lint -save -e9075 [8.4] All symbols are invoked from asm context.*/
void __default_exit(void) {
 8001240:	e7fe      	b.n	8001240 <__default_exit>
 8001242:	bf00      	nop
 8001244:	f3af 8000 	nop.w
 8001248:	f3af 8000 	nop.w
 800124c:	f3af 8000 	nop.w

08001250 <__late_init>:
 */
#if !defined(__DOXYGEN__)
__attribute__((weak))
#endif
/*lint -save -e9075 [8.4] All symbols are invoked from asm context.*/
void __late_init(void) {}
 8001250:	4770      	bx	lr
 8001252:	bf00      	nop
 8001254:	f3af 8000 	nop.w
 8001258:	f3af 8000 	nop.w
 800125c:	f3af 8000 	nop.w

08001260 <__core_init>:
 */
#if !defined(__DOXYGEN__)
__attribute__((weak))
#endif
/*lint -save -e9075 [8.4] All symbols are invoked from asm context.*/
void __core_init(void) {
 8001260:	4770      	bx	lr
 8001262:	bf00      	nop
 8001264:	f3af 8000 	nop.w
 8001268:	f3af 8000 	nop.w
 800126c:	f3af 8000 	nop.w

08001270 <sdStart>:
 *                      If this parameter is set to @p NULL then a default
 *                      configuration is used.
 *
 * @api
 */
void sdStart(SerialDriver *sdp, const SerialConfig *config) {
 8001270:	b470      	push	{r4, r5, r6}
 8001272:	2320      	movs	r3, #32
 8001274:	f383 8811 	msr	BASEPRI, r3
 * @notapi
 */
void sd_lld_start(SerialDriver *sdp, const SerialConfig *config) {

  if (config == NULL)
    config = &default_config;
 8001278:	f642 533c 	movw	r3, #11580	; 0x2d3c

  if (sdp->state == SD_STOP) {
 800127c:	7a02      	ldrb	r2, [r0, #8]
 * @notapi
 */
void sd_lld_start(SerialDriver *sdp, const SerialConfig *config) {

  if (config == NULL)
    config = &default_config;
 800127e:	f6c0 0300 	movt	r3, #2048	; 0x800
 8001282:	2900      	cmp	r1, #0
 8001284:	bf08      	it	eq
 8001286:	4619      	moveq	r1, r3

  if (sdp->state == SD_STOP) {
 8001288:	2a01      	cmp	r2, #1
 800128a:	d02c      	beq.n	80012e6 <sdStart+0x76>
#if STM32_HAS_USART6
  if ((sdp->usart == USART1) || (sdp->usart == USART6))
#else
  if (sdp->usart == USART1)
#endif
    u->BRR = STM32_PCLK2 / config->speed;
 800128c:	680c      	ldr	r4, [r1, #0]
 800128e:	f44f 5258 	mov.w	r2, #13824	; 0x3600
  else
    u->BRR = STM32_PCLK1 / config->speed;

  /* Note that some bits are enforced.*/
  u->CR2 = config->cr2 | USART_CR2_LBDIE;
 8001292:	88ce      	ldrh	r6, [r1, #6]
  u->CR3 = config->cr3 | USART_CR3_EIE;
 8001294:	890d      	ldrh	r5, [r1, #8]
 *
 * @param[in] sdp       pointer to a @p SerialDriver object
 * @param[in] config    the architecture-dependent serial driver configuration
 */
static void usart_init(SerialDriver *sdp, const SerialConfig *config) {
  USART_TypeDef *u = sdp->usart;
 8001296:	6f43      	ldr	r3, [r0, #116]	; 0x74
    u->BRR = STM32_PCLK1 / config->speed;

  /* Note that some bits are enforced.*/
  u->CR2 = config->cr2 | USART_CR2_LBDIE;
  u->CR3 = config->cr3 | USART_CR3_EIE;
  u->CR1 = config->cr1 | USART_CR1_UE | USART_CR1_PEIE |
 8001298:	8889      	ldrh	r1, [r1, #4]
#if STM32_HAS_USART6
  if ((sdp->usart == USART1) || (sdp->usart == USART6))
#else
  if (sdp->usart == USART1)
#endif
    u->BRR = STM32_PCLK2 / config->speed;
 800129a:	f2c0 126e 	movt	r2, #366	; 0x16e
 800129e:	fbb2 f2f4 	udiv	r2, r2, r4
 80012a2:	609a      	str	r2, [r3, #8]
  else
    u->BRR = STM32_PCLK1 / config->speed;

  /* Note that some bits are enforced.*/
  u->CR2 = config->cr2 | USART_CR2_LBDIE;
 80012a4:	f046 0640 	orr.w	r6, r6, #64	; 0x40
  u->CR3 = config->cr3 | USART_CR3_EIE;
  u->CR1 = config->cr1 | USART_CR1_UE | USART_CR1_PEIE |
 80012a8:	f441 5204 	orr.w	r2, r1, #8448	; 0x2100
  else
    u->BRR = STM32_PCLK1 / config->speed;

  /* Note that some bits are enforced.*/
  u->CR2 = config->cr2 | USART_CR2_LBDIE;
  u->CR3 = config->cr3 | USART_CR3_EIE;
 80012ac:	f045 0501 	orr.w	r5, r5, #1
    u->BRR = STM32_PCLK2 / config->speed;
  else
    u->BRR = STM32_PCLK1 / config->speed;

  /* Note that some bits are enforced.*/
  u->CR2 = config->cr2 | USART_CR2_LBDIE;
 80012b0:	b2b6      	uxth	r6, r6
  u->CR3 = config->cr3 | USART_CR3_EIE;
 80012b2:	b2ad      	uxth	r5, r5
  u->CR1 = config->cr1 | USART_CR1_UE | USART_CR1_PEIE |
 80012b4:	f042 022c 	orr.w	r2, r2, #44	; 0x2c
                         USART_CR1_RXNEIE | USART_CR1_TE |
                         USART_CR1_RE;
  u->SR = 0;
 80012b8:	2400      	movs	r4, #0
    u->BRR = STM32_PCLK2 / config->speed;
  else
    u->BRR = STM32_PCLK1 / config->speed;

  /* Note that some bits are enforced.*/
  u->CR2 = config->cr2 | USART_CR2_LBDIE;
 80012ba:	611e      	str	r6, [r3, #16]
  (void)u->SR;  /* SR reset step 1.*/
  (void)u->DR;  /* SR reset step 2.*/

  /* Deciding mask to be applied on the data register on receive, this is
     required in order to mask out the parity bit.*/
  if ((config->cr1 & (USART_CR1_M | USART_CR1_PCE)) == USART_CR1_PCE) {
 80012bc:	f401 51a0 	and.w	r1, r1, #5120	; 0x1400
  else
    u->BRR = STM32_PCLK1 / config->speed;

  /* Note that some bits are enforced.*/
  u->CR2 = config->cr2 | USART_CR2_LBDIE;
  u->CR3 = config->cr3 | USART_CR3_EIE;
 80012c0:	615d      	str	r5, [r3, #20]
  u->CR1 = config->cr1 | USART_CR1_UE | USART_CR1_PEIE |
 80012c2:	60da      	str	r2, [r3, #12]
                         USART_CR1_RXNEIE | USART_CR1_TE |
                         USART_CR1_RE;
  u->SR = 0;
 80012c4:	601c      	str	r4, [r3, #0]
  (void)u->SR;  /* SR reset step 1.*/
 80012c6:	681a      	ldr	r2, [r3, #0]
  (void)u->DR;  /* SR reset step 2.*/

  /* Deciding mask to be applied on the data register on receive, this is
     required in order to mask out the parity bit.*/
  if ((config->cr1 & (USART_CR1_M | USART_CR1_PCE)) == USART_CR1_PCE) {
 80012c8:	f5b1 6f80 	cmp.w	r1, #1024	; 0x400
  u->CR1 = config->cr1 | USART_CR1_UE | USART_CR1_PEIE |
                         USART_CR1_RXNEIE | USART_CR1_TE |
                         USART_CR1_RE;
  u->SR = 0;
  (void)u->SR;  /* SR reset step 1.*/
  (void)u->DR;  /* SR reset step 2.*/
 80012cc:	685b      	ldr	r3, [r3, #4]

  /* Deciding mask to be applied on the data register on receive, this is
     required in order to mask out the parity bit.*/
  if ((config->cr1 & (USART_CR1_M | USART_CR1_PCE)) == USART_CR1_PCE) {
    sdp->rxmask = 0x7F;
 80012ce:	bf0c      	ite	eq
 80012d0:	237f      	moveq	r3, #127	; 0x7f
  }
  else {
    sdp->rxmask = 0xFF;
 80012d2:	23ff      	movne	r3, #255	; 0xff
 80012d4:	f880 3078 	strb.w	r3, [r0, #120]	; 0x78

  osalSysLock();
  osalDbgAssert((sdp->state == SD_STOP) || (sdp->state == SD_READY),
                "invalid state");
  sd_lld_start(sdp, config);
  sdp->state = SD_READY;
 80012d8:	2302      	movs	r3, #2
 80012da:	7203      	strb	r3, [r0, #8]
 80012dc:	2300      	movs	r3, #0
 80012de:	f383 8811 	msr	BASEPRI, r3
  osalSysUnlock();
}
 80012e2:	bc70      	pop	{r4, r5, r6}
 80012e4:	4770      	bx	lr
      rccEnableUSART1(FALSE);
      nvicEnableVector(STM32_USART1_NUMBER, STM32_SERIAL_USART1_PRIORITY);
    }
#endif
#if STM32_SERIAL_USE_USART2
    if (&SD2 == sdp) {
 80012e6:	f640 0350 	movw	r3, #2128	; 0x850
 80012ea:	f2c2 0300 	movt	r3, #8192	; 0x2000
 80012ee:	4298      	cmp	r0, r3
 80012f0:	d019      	beq.n	8001326 <sdStart+0xb6>
      rccEnableUSART2(FALSE);
      nvicEnableVector(STM32_USART2_NUMBER, STM32_SERIAL_USART2_PRIORITY);
    }
#endif
#if STM32_SERIAL_USE_USART3
    if (&SD3 == sdp) {
 80012f2:	f640 2390 	movw	r3, #2704	; 0xa90
 80012f6:	f2c2 0300 	movt	r3, #8192	; 0x2000
 80012fa:	4298      	cmp	r0, r3
 80012fc:	d1c6      	bne.n	800128c <sdStart+0x1c>
      rccEnableUSART3(FALSE);
 80012fe:	f44f 5280 	mov.w	r2, #4096	; 0x1000
 8001302:	f2c4 0202 	movt	r2, #16386	; 0x4002
 8001306:	69d6      	ldr	r6, [r2, #28]

#if defined(__CORE_CM0_H_GENERIC)
  NVIC->IP[_IP_IDX(n)] = (NVIC->IP[_IP_IDX(n)] & ~(0xFFU << _BIT_SHIFT(n))) |
                         (NVIC_PRIORITY_MASK(prio) << _BIT_SHIFT(n));
#else
  NVIC->IP[n] = NVIC_PRIORITY_MASK(prio);
 8001308:	f44f 4361 	mov.w	r3, #57600	; 0xe100
 800130c:	f2ce 0300 	movt	r3, #57344	; 0xe000
#endif
  NVIC->ICPR[n >> 5U] = 1U << (n & 0x1FU);
 8001310:	2480      	movs	r4, #128	; 0x80
 8001312:	f446 2680 	orr.w	r6, r6, #262144	; 0x40000

#if defined(__CORE_CM0_H_GENERIC)
  NVIC->IP[_IP_IDX(n)] = (NVIC->IP[_IP_IDX(n)] & ~(0xFFU << _BIT_SHIFT(n))) |
                         (NVIC_PRIORITY_MASK(prio) << _BIT_SHIFT(n));
#else
  NVIC->IP[n] = NVIC_PRIORITY_MASK(prio);
 8001316:	25c0      	movs	r5, #192	; 0xc0
 8001318:	61d6      	str	r6, [r2, #28]
 800131a:	f883 5327 	strb.w	r5, [r3, #807]	; 0x327
#endif
  NVIC->ICPR[n >> 5U] = 1U << (n & 0x1FU);
 800131e:	f8c3 4184 	str.w	r4, [r3, #388]	; 0x184
  NVIC->ISER[n >> 5U] = 1U << (n & 0x1FU);
 8001322:	605c      	str	r4, [r3, #4]
 8001324:	e7b2      	b.n	800128c <sdStart+0x1c>
      nvicEnableVector(STM32_USART1_NUMBER, STM32_SERIAL_USART1_PRIORITY);
    }
#endif
#if STM32_SERIAL_USE_USART2
    if (&SD2 == sdp) {
      rccEnableUSART2(FALSE);
 8001326:	f44f 5280 	mov.w	r2, #4096	; 0x1000
 800132a:	f2c4 0202 	movt	r2, #16386	; 0x4002
 800132e:	69d6      	ldr	r6, [r2, #28]

#if defined(__CORE_CM0_H_GENERIC)
  NVIC->IP[_IP_IDX(n)] = (NVIC->IP[_IP_IDX(n)] & ~(0xFFU << _BIT_SHIFT(n))) |
                         (NVIC_PRIORITY_MASK(prio) << _BIT_SHIFT(n));
#else
  NVIC->IP[n] = NVIC_PRIORITY_MASK(prio);
 8001330:	f44f 4361 	mov.w	r3, #57600	; 0xe100
 8001334:	f2ce 0300 	movt	r3, #57344	; 0xe000
#endif
  NVIC->ICPR[n >> 5U] = 1U << (n & 0x1FU);
 8001338:	2440      	movs	r4, #64	; 0x40
 800133a:	f446 3600 	orr.w	r6, r6, #131072	; 0x20000

#if defined(__CORE_CM0_H_GENERIC)
  NVIC->IP[_IP_IDX(n)] = (NVIC->IP[_IP_IDX(n)] & ~(0xFFU << _BIT_SHIFT(n))) |
                         (NVIC_PRIORITY_MASK(prio) << _BIT_SHIFT(n));
#else
  NVIC->IP[n] = NVIC_PRIORITY_MASK(prio);
 800133e:	25c0      	movs	r5, #192	; 0xc0
 8001340:	61d6      	str	r6, [r2, #28]
 8001342:	f883 5326 	strb.w	r5, [r3, #806]	; 0x326
#endif
  NVIC->ICPR[n >> 5U] = 1U << (n & 0x1FU);
 8001346:	f8c3 4184 	str.w	r4, [r3, #388]	; 0x184
  NVIC->ISER[n >> 5U] = 1U << (n & 0x1FU);
 800134a:	605c      	str	r4, [r3, #4]
 800134c:	e79e      	b.n	800128c <sdStart+0x1c>
 800134e:	bf00      	nop

08001350 <chVTDoResetI>:
#else /* CH_CFG_ST_TIMEDELTA > 0 */
  systime_t nowdelta, delta;

  /* If the timer is not the first of the list then it is simply unlinked
     else the operation is more complex.*/
  if (ch.vtlist.next != vtp) {
 8001350:	f640 03d8 	movw	r3, #2264	; 0x8d8
 8001354:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8001358:	69da      	ldr	r2, [r3, #28]
 *
 * @param[in] vtp       the @p virtual_timer_t structure pointer
 *
 * @iclass
 */
void chVTDoResetI(virtual_timer_t *vtp) {
 800135a:	b4f0      	push	{r4, r5, r6, r7}
#else /* CH_CFG_ST_TIMEDELTA > 0 */
  systime_t nowdelta, delta;

  /* If the timer is not the first of the list then it is simply unlinked
     else the operation is more complex.*/
  if (ch.vtlist.next != vtp) {
 800135c:	4282      	cmp	r2, r0
 800135e:	d00f      	beq.n	8001380 <chVTDoResetI+0x30>
    /* Removing the element from the delta list.*/
    vtp->prev->next = vtp->next;
 8001360:	6802      	ldr	r2, [r0, #0]
 8001362:	6841      	ldr	r1, [r0, #4]
    vtp->next->prev = vtp->prev;
    vtp->func = NULL;

    /* Adding delta to the next element, if it is not the last one.*/
    if (&ch.vtlist != (virtual_timers_list_t *)vtp->next)
 8001364:	331c      	adds	r3, #28

  /* If the timer is not the first of the list then it is simply unlinked
     else the operation is more complex.*/
  if (ch.vtlist.next != vtp) {
    /* Removing the element from the delta list.*/
    vtp->prev->next = vtp->next;
 8001366:	600a      	str	r2, [r1, #0]
    vtp->next->prev = vtp->prev;
 8001368:	6802      	ldr	r2, [r0, #0]
    vtp->func = NULL;
 800136a:	2400      	movs	r4, #0

    /* Adding delta to the next element, if it is not the last one.*/
    if (&ch.vtlist != (virtual_timers_list_t *)vtp->next)
 800136c:	429a      	cmp	r2, r3
  /* If the timer is not the first of the list then it is simply unlinked
     else the operation is more complex.*/
  if (ch.vtlist.next != vtp) {
    /* Removing the element from the delta list.*/
    vtp->prev->next = vtp->next;
    vtp->next->prev = vtp->prev;
 800136e:	6051      	str	r1, [r2, #4]
    vtp->func = NULL;
 8001370:	60c4      	str	r4, [r0, #12]

    /* Adding delta to the next element, if it is not the last one.*/
    if (&ch.vtlist != (virtual_timers_list_t *)vtp->next)
 8001372:	d003      	beq.n	800137c <chVTDoResetI+0x2c>
      vtp->next->delta += vtp->delta;
 8001374:	8901      	ldrh	r1, [r0, #8]
 8001376:	8913      	ldrh	r3, [r2, #8]
 8001378:	440b      	add	r3, r1
 800137a:	8113      	strh	r3, [r2, #8]
    delta = (systime_t)CH_CFG_ST_TIMEDELTA;
  }

  port_timer_set_alarm(ch.vtlist.lasttime + nowdelta + delta);
#endif /* CH_CFG_ST_TIMEDELTA > 0 */
}
 800137c:	bcf0      	pop	{r4, r5, r6, r7}
 800137e:	4770      	bx	lr

    return;
  }

  /* Removing the first timer from the list.*/
  ch.vtlist.next = vtp->next;
 8001380:	6811      	ldr	r1, [r2, #0]
 8001382:	4618      	mov	r0, r3
 8001384:	f840 1f1c 	str.w	r1, [r0, #28]!
  ch.vtlist.next->prev = (virtual_timer_t *)&ch.vtlist;
  vtp->func = NULL;

  /* If the list become empty then the alarm timer is stopped and done.*/
  if (&ch.vtlist == (virtual_timers_list_t *)ch.vtlist.next) {
 8001388:	4281      	cmp	r1, r0
  }

  /* Removing the first timer from the list.*/
  ch.vtlist.next = vtp->next;
  ch.vtlist.next->prev = (virtual_timer_t *)&ch.vtlist;
  vtp->func = NULL;
 800138a:	f04f 0400 	mov.w	r4, #0
 *
 * @notapi
 */
static inline void st_lld_stop_alarm(void) {

  STM32_ST_TIM->DIER = 0;
 800138e:	bf08      	it	eq
 8001390:	f04f 4380 	moveq.w	r3, #1073741824	; 0x40000000
    return;
  }

  /* Removing the first timer from the list.*/
  ch.vtlist.next = vtp->next;
  ch.vtlist.next->prev = (virtual_timer_t *)&ch.vtlist;
 8001394:	6048      	str	r0, [r1, #4]
  vtp->func = NULL;
 8001396:	60d4      	str	r4, [r2, #12]
 8001398:	bf08      	it	eq
 800139a:	60dc      	streq	r4, [r3, #12]

  /* If the list become empty then the alarm timer is stopped and done.*/
  if (&ch.vtlist == (virtual_timers_list_t *)ch.vtlist.next) {
 800139c:	d0ee      	beq.n	800137c <chVTDoResetI+0x2c>
 *
 * @notapi
 */
static inline systime_t st_lld_get_counter(void) {

  return (systime_t)STM32_ST_TIM->CNT;
 800139e:	f04f 4080 	mov.w	r0, #1073741824	; 0x40000000
 80013a2:	6a47      	ldr	r7, [r0, #36]	; 0x24

    return;
  }

  /* The delta of the removed timer is added to the new first timer.*/
  ch.vtlist.next->delta += vtp->delta;
 80013a4:	8916      	ldrh	r6, [r2, #8]
/*  if (ch.vtlist.next->delta == 0) {
    return;
  }*/

  /* Distance in ticks between the last alarm event and current time.*/
  nowdelta = chVTGetSystemTimeX() - ch.vtlist.lasttime;
 80013a6:	8cdc      	ldrh	r4, [r3, #38]	; 0x26

    return;
  }

  /* The delta of the removed timer is added to the new first timer.*/
  ch.vtlist.next->delta += vtp->delta;
 80013a8:	890d      	ldrh	r5, [r1, #8]
 80013aa:	b2ba      	uxth	r2, r7
 80013ac:	1973      	adds	r3, r6, r5
/*  if (ch.vtlist.next->delta == 0) {
    return;
  }*/

  /* Distance in ticks between the last alarm event and current time.*/
  nowdelta = chVTGetSystemTimeX() - ch.vtlist.lasttime;
 80013ae:	1b14      	subs	r4, r2, r4

    return;
  }

  /* The delta of the removed timer is added to the new first timer.*/
  ch.vtlist.next->delta += vtp->delta;
 80013b0:	b29b      	uxth	r3, r3
/*  if (ch.vtlist.next->delta == 0) {
    return;
  }*/

  /* Distance in ticks between the last alarm event and current time.*/
  nowdelta = chVTGetSystemTimeX() - ch.vtlist.lasttime;
 80013b2:	b2a4      	uxth	r4, r4

  /* If the current time surpassed the time of the next element in list
     then the event interrupt is already pending, just return.*/
  if (nowdelta >= ch.vtlist.next->delta) {
 80013b4:	42a3      	cmp	r3, r4

    return;
  }

  /* The delta of the removed timer is added to the new first timer.*/
  ch.vtlist.next->delta += vtp->delta;
 80013b6:	810b      	strh	r3, [r1, #8]
  /* Distance in ticks between the last alarm event and current time.*/
  nowdelta = chVTGetSystemTimeX() - ch.vtlist.lasttime;

  /* If the current time surpassed the time of the next element in list
     then the event interrupt is already pending, just return.*/
  if (nowdelta >= ch.vtlist.next->delta) {
 80013b8:	d9e0      	bls.n	800137c <chVTDoResetI+0x2c>
    return;
  }

  /* Distance from the next scheduled event and now.*/
  delta = ch.vtlist.next->delta - nowdelta;
 80013ba:	1b1b      	subs	r3, r3, r4
 80013bc:	b29b      	uxth	r3, r3

  /* Making sure to not schedule an event closer than CH_CFG_ST_TIMEDELTA
     ticks from now.*/
  if (delta < (systime_t)CH_CFG_ST_TIMEDELTA) {
    delta = (systime_t)CH_CFG_ST_TIMEDELTA;
 80013be:	2b01      	cmp	r3, #1
 80013c0:	bf98      	it	ls
 80013c2:	2302      	movls	r3, #2
  }

  port_timer_set_alarm(ch.vtlist.lasttime + nowdelta + delta);
 80013c4:	4413      	add	r3, r2
 *
 * @notapi
 */
static inline void st_lld_set_alarm(systime_t time) {

  STM32_ST_TIM->CCR[0] = (uint32_t)time;
 80013c6:	b29b      	uxth	r3, r3
 80013c8:	6343      	str	r3, [r0, #52]	; 0x34
 80013ca:	e7d7      	b.n	800137c <chVTDoResetI+0x2c>
 80013cc:	f3af 8000 	nop.w

080013d0 <chVTDoSetI.constprop.23>:
 * @param[in] par       a parameter that will be passed to the callback
 *                      function
 *
 * @iclass
 */
void chVTDoSetI(virtual_timer_t *vtp, systime_t delay,
 80013d0:	b4f0      	push	{r4, r5, r6, r7}
    if (delay < (systime_t)CH_CFG_ST_TIMEDELTA) {
      delay = (systime_t)CH_CFG_ST_TIMEDELTA;
    }

    /* Special case where the timers list is empty.*/
    if (&ch.vtlist == (virtual_timers_list_t *)ch.vtlist.next) {
 80013d2:	f640 04d8 	movw	r4, #2264	; 0x8d8
 80013d6:	f2c2 0400 	movt	r4, #8192	; 0x2000
 80013da:	4625      	mov	r5, r4
 80013dc:	f855 3f1c 	ldr.w	r3, [r5, #28]!
 *
 * @notapi
 */
static inline systime_t st_lld_get_counter(void) {

  return (systime_t)STM32_ST_TIM->CNT;
 80013e0:	f04f 4780 	mov.w	r7, #1073741824	; 0x40000000
 80013e4:	f8d7 c024 	ldr.w	ip, [r7, #36]	; 0x24

  chDbgCheckClassI();
  chDbgCheck((vtp != NULL) && (vtfunc != NULL) && (delay != TIME_IMMEDIATE));

  vtp->par = par;
  vtp->func = vtfunc;
 80013e8:	f641 2621 	movw	r6, #6689	; 0x1a21
 80013ec:	f6c0 0600 	movt	r6, #2048	; 0x800
    systime_t now = chVTGetSystemTimeX();

    /* If the requested delay is lower than the minimum safe delta then it
       is raised to the minimum safe value.*/
    if (delay < (systime_t)CH_CFG_ST_TIMEDELTA) {
      delay = (systime_t)CH_CFG_ST_TIMEDELTA;
 80013f0:	2901      	cmp	r1, #1
 80013f2:	bf98      	it	ls
 80013f4:	2102      	movls	r1, #2
    }

    /* Special case where the timers list is empty.*/
    if (&ch.vtlist == (virtual_timers_list_t *)ch.vtlist.next) {
 80013f6:	42ab      	cmp	r3, r5
  systime_t delta;

  chDbgCheckClassI();
  chDbgCheck((vtp != NULL) && (vtfunc != NULL) && (delay != TIME_IMMEDIATE));

  vtp->par = par;
 80013f8:	6102      	str	r2, [r0, #16]
  vtp->func = vtfunc;
 80013fa:	60c6      	str	r6, [r0, #12]
 80013fc:	fa1f f28c 	uxth.w	r2, ip
    if (delay < (systime_t)CH_CFG_ST_TIMEDELTA) {
      delay = (systime_t)CH_CFG_ST_TIMEDELTA;
    }

    /* Special case where the timers list is empty.*/
    if (&ch.vtlist == (virtual_timers_list_t *)ch.vtlist.next) {
 8001400:	d026      	beq.n	8001450 <chVTDoSetI.constprop.23+0x80>
    /* Pointer to the first element in the delta list, which is non-empty.*/
    p = ch.vtlist.next;

    /* Delay as delta from 'lasttime'. Note, it can overflow and the value
       becomes lower than 'now'.*/
    delta = now - ch.vtlist.lasttime + delay;
 8001402:	8ce6      	ldrh	r6, [r4, #38]	; 0x26
 8001404:	1b95      	subs	r5, r2, r6
 8001406:	194a      	adds	r2, r1, r5
 8001408:	b292      	uxth	r2, r2

    if (delta < now - ch.vtlist.lasttime) {
 800140a:	42aa      	cmp	r2, r5
      /* Scenario where a very large delay excedeed the numeric range, it
         requires a special handling. We need to skip the first element and
         adjust the delta to wrap back in the previous numeric range.*/
      delta -= p->delta;
 800140c:	8919      	ldrh	r1, [r3, #8]

    /* Delay as delta from 'lasttime'. Note, it can overflow and the value
       becomes lower than 'now'.*/
    delta = now - ch.vtlist.lasttime + delay;

    if (delta < now - ch.vtlist.lasttime) {
 800140e:	db1a      	blt.n	8001446 <chVTDoSetI.constprop.23+0x76>
         requires a special handling. We need to skip the first element and
         adjust the delta to wrap back in the previous numeric range.*/
      delta -= p->delta;
      p = p->next;
    }
    else if (delta < p->delta) {
 8001410:	428a      	cmp	r2, r1
     /* A small delay that will become the first element in the delta list
        and next deadline.*/
      port_timer_set_alarm(ch.vtlist.lasttime + delta);
 8001412:	bf3e      	ittt	cc
 8001414:	1995      	addcc	r5, r2, r6
 *
 * @notapi
 */
static inline void st_lld_set_alarm(systime_t time) {

  STM32_ST_TIM->CCR[0] = (uint32_t)time;
 8001416:	b2ad      	uxthcc	r5, r5
 8001418:	637d      	strcc	r5, [r7, #52]	; 0x34
  p = ch.vtlist.next;
#endif /* CH_CFG_ST_TIMEDELTA == 0 */

  /* The delta list is scanned in order to find the correct position for
     this timer. */
  while (p->delta < delta) {
 800141a:	428a      	cmp	r2, r1
 800141c:	d905      	bls.n	800142a <chVTDoSetI.constprop.23+0x5a>
    delta -= p->delta;
    p = p->next;
 800141e:	681b      	ldr	r3, [r3, #0]
#endif /* CH_CFG_ST_TIMEDELTA == 0 */

  /* The delta list is scanned in order to find the correct position for
     this timer. */
  while (p->delta < delta) {
    delta -= p->delta;
 8001420:	1a52      	subs	r2, r2, r1
  p = ch.vtlist.next;
#endif /* CH_CFG_ST_TIMEDELTA == 0 */

  /* The delta list is scanned in order to find the correct position for
     this timer. */
  while (p->delta < delta) {
 8001422:	8919      	ldrh	r1, [r3, #8]
    delta -= p->delta;
 8001424:	b292      	uxth	r2, r2
  p = ch.vtlist.next;
#endif /* CH_CFG_ST_TIMEDELTA == 0 */

  /* The delta list is scanned in order to find the correct position for
     this timer. */
  while (p->delta < delta) {
 8001426:	4291      	cmp	r1, r2
 8001428:	d3f9      	bcc.n	800141e <chVTDoSetI.constprop.23+0x4e>
    p = p->next;
  }

  /* The timer is inserted in the delta list.*/
  vtp->next = p;
  vtp->prev = vtp->next->prev;
 800142a:	6859      	ldr	r1, [r3, #4]
    delta -= p->delta;
    p = p->next;
  }

  /* The timer is inserted in the delta list.*/
  vtp->next = p;
 800142c:	6003      	str	r3, [r0, #0]
  vtp->prev = vtp->next->prev;
 800142e:	6041      	str	r1, [r0, #4]
  vtp->prev->next = vtp;
 8001430:	6008      	str	r0, [r1, #0]
  p->prev = vtp;
 8001432:	6058      	str	r0, [r3, #4]
  vtp->delta = delta
 8001434:	8102      	strh	r2, [r0, #8]

  /* Special case when the timer is in last position in the list, the
     value in the header must be restored.*/;
  p->delta -= delta;
 8001436:	8918      	ldrh	r0, [r3, #8]
  ch.vtlist.delta = (systime_t)-1;
 8001438:	f64f 71ff 	movw	r1, #65535	; 0xffff
  p->prev = vtp;
  vtp->delta = delta

  /* Special case when the timer is in last position in the list, the
     value in the header must be restored.*/;
  p->delta -= delta;
 800143c:	1a82      	subs	r2, r0, r2
 800143e:	811a      	strh	r2, [r3, #8]
  ch.vtlist.delta = (systime_t)-1;
 8001440:	84a1      	strh	r1, [r4, #36]	; 0x24
}
 8001442:	bcf0      	pop	{r4, r5, r6, r7}
 8001444:	4770      	bx	lr
    if (delta < now - ch.vtlist.lasttime) {
      /* Scenario where a very large delay excedeed the numeric range, it
         requires a special handling. We need to skip the first element and
         adjust the delta to wrap back in the previous numeric range.*/
      delta -= p->delta;
      p = p->next;
 8001446:	681b      	ldr	r3, [r3, #0]

    if (delta < now - ch.vtlist.lasttime) {
      /* Scenario where a very large delay excedeed the numeric range, it
         requires a special handling. We need to skip the first element and
         adjust the delta to wrap back in the previous numeric range.*/
      delta -= p->delta;
 8001448:	1a52      	subs	r2, r2, r1
 800144a:	b292      	uxth	r2, r2
 800144c:	8919      	ldrh	r1, [r3, #8]
 800144e:	e7e4      	b.n	800141a <chVTDoSetI.constprop.23+0x4a>
      vtp->next = (virtual_timer_t *)&ch.vtlist;
      vtp->prev = (virtual_timer_t *)&ch.vtlist;
      vtp->delta = delay;

      /* Being the first element in the list the alarm timer is started.*/
      port_timer_start_alarm(ch.vtlist.lasttime + delay);
 8001450:	eb01 0c02 	add.w	ip, r1, r2
 *
 * @notapi
 */
static inline void st_lld_start_alarm(systime_t time) {

  STM32_ST_TIM->CCR[0] = (uint32_t)time;
 8001454:	fa1f fc8c 	uxth.w	ip, ip
  STM32_ST_TIM->SR     = 0;
 8001458:	2600      	movs	r6, #0
  STM32_ST_TIM->DIER   = STM32_TIM_DIER_CC1IE;
 800145a:	2502      	movs	r5, #2
    /* Special case where the timers list is empty.*/
    if (&ch.vtlist == (virtual_timers_list_t *)ch.vtlist.next) {

      /* The delta list is empty, the current time becomes the new
         delta list base time, the timer is inserted.*/
      ch.vtlist.lasttime = now;
 800145c:	84e2      	strh	r2, [r4, #38]	; 0x26
      ch.vtlist.next = vtp;
 800145e:	61e0      	str	r0, [r4, #28]
      ch.vtlist.prev = vtp;
 8001460:	6220      	str	r0, [r4, #32]
      vtp->next = (virtual_timer_t *)&ch.vtlist;
 8001462:	6003      	str	r3, [r0, #0]
      vtp->prev = (virtual_timer_t *)&ch.vtlist;
 8001464:	6043      	str	r3, [r0, #4]
      vtp->delta = delay;
 8001466:	8101      	strh	r1, [r0, #8]
 *
 * @notapi
 */
static inline void st_lld_start_alarm(systime_t time) {

  STM32_ST_TIM->CCR[0] = (uint32_t)time;
 8001468:	f8c7 c034 	str.w	ip, [r7, #52]	; 0x34
  STM32_ST_TIM->SR     = 0;
 800146c:	613e      	str	r6, [r7, #16]
  STM32_ST_TIM->DIER   = STM32_TIM_DIER_CC1IE;
 800146e:	60fd      	str	r5, [r7, #12]
 8001470:	e7e7      	b.n	8001442 <chVTDoSetI.constprop.23+0x72>
 8001472:	bf00      	nop
 8001474:	f3af 8000 	nop.w
 8001478:	f3af 8000 	nop.w
 800147c:	f3af 8000 	nop.w

08001480 <chSchGoSleepTimeoutS>:
 * @return              The wakeup message.
 * @retval MSG_TIMEOUT  if a timeout occurs.
 *
 * @sclass
 */
msg_t chSchGoSleepTimeoutS(tstate_t newstate, systime_t time) {
 8001480:	b530      	push	{r4, r5, lr}

  chDbgCheckClassS();

  if (TIME_INFINITE != time) {
 8001482:	f64f 73ff 	movw	r3, #65535	; 0xffff
 8001486:	4299      	cmp	r1, r3
 * @return              The wakeup message.
 * @retval MSG_TIMEOUT  if a timeout occurs.
 *
 * @sclass
 */
msg_t chSchGoSleepTimeoutS(tstate_t newstate, systime_t time) {
 8001488:	b087      	sub	sp, #28
 800148a:	4605      	mov	r5, r0

  chDbgCheckClassS();

  if (TIME_INFINITE != time) {
 800148c:	d013      	beq.n	80014b6 <chSchGoSleepTimeoutS+0x36>
    virtual_timer_t vt;

    chVTDoSetI(&vt, time, wakeup, currp);
 800148e:	f640 04d8 	movw	r4, #2264	; 0x8d8
 8001492:	f2c2 0400 	movt	r4, #8192	; 0x2000
 8001496:	69a2      	ldr	r2, [r4, #24]
 8001498:	a801      	add	r0, sp, #4
 800149a:	f7ff ff99 	bl	80013d0 <chVTDoSetI.constprop.23>
    chSchGoSleepS(newstate);
 800149e:	4628      	mov	r0, r5
 80014a0:	f000 fece 	bl	8002240 <chSchGoSleepS>
    if (chVTIsArmedI(&vt)) {
 80014a4:	9b04      	ldr	r3, [sp, #16]
 80014a6:	b113      	cbz	r3, 80014ae <chSchGoSleepTimeoutS+0x2e>
      chVTDoResetI(&vt);
 80014a8:	a801      	add	r0, sp, #4
 80014aa:	f7ff ff51 	bl	8001350 <chVTDoResetI>
  }
  else {
    chSchGoSleepS(newstate);
  }

  return currp->u.rdymsg;
 80014ae:	69a3      	ldr	r3, [r4, #24]
}
 80014b0:	6a58      	ldr	r0, [r3, #36]	; 0x24
 80014b2:	b007      	add	sp, #28
 80014b4:	bd30      	pop	{r4, r5, pc}
    if (chVTIsArmedI(&vt)) {
      chVTDoResetI(&vt);
    }
  }
  else {
    chSchGoSleepS(newstate);
 80014b6:	f000 fec3 	bl	8002240 <chSchGoSleepS>
 80014ba:	f640 04d8 	movw	r4, #2264	; 0x8d8
 80014be:	f2c2 0400 	movt	r4, #8192	; 0x2000
  }

  return currp->u.rdymsg;
 80014c2:	69a3      	ldr	r3, [r4, #24]
}
 80014c4:	6a58      	ldr	r0, [r3, #36]	; 0x24
 80014c6:	b007      	add	sp, #28
 80014c8:	bd30      	pop	{r4, r5, pc}
 80014ca:	bf00      	nop
 80014cc:	f3af 8000 	nop.w

080014d0 <chThdSleep>:
 *                      - @a TIME_IMMEDIATE this value is not allowed.
 *                      .
 *
 * @api
 */
void chThdSleep(systime_t time) {
 80014d0:	b508      	push	{r3, lr}
 80014d2:	4601      	mov	r1, r0
 80014d4:	2320      	movs	r3, #32
 80014d6:	f383 8811 	msr	BASEPRI, r3
 */
static inline void chThdSleepS(systime_t time) {

  chDbgCheck(time != TIME_IMMEDIATE);

  (void) chSchGoSleepTimeoutS(CH_STATE_SLEEPING, time);
 80014da:	2008      	movs	r0, #8
 80014dc:	f7ff ffd0 	bl	8001480 <chSchGoSleepTimeoutS>
 80014e0:	2300      	movs	r3, #0
 80014e2:	f383 8811 	msr	BASEPRI, r3
 80014e6:	bd08      	pop	{r3, pc}
 80014e8:	f3af 8000 	nop.w
 80014ec:	f3af 8000 	nop.w

080014f0 <chThdEnqueueTimeoutS.4393>:
 *                      invoked with @p TIME_IMMEDIATE as timeout
 *                      specification.
 *
 * @sclass
 */
msg_t chThdEnqueueTimeoutS(threads_queue_t *tqp, systime_t timeout) {
 80014f0:	b410      	push	{r4}
 80014f2:	4602      	mov	r2, r0

  if (TIME_IMMEDIATE == timeout) {
 80014f4:	b171      	cbz	r1, 8001514 <chThdEnqueueTimeoutS.4393+0x24>
    return MSG_TIMEOUT;
  }

  queue_insert(currp, tqp);
 80014f6:	f640 03d8 	movw	r3, #2264	; 0x8d8
 80014fa:	f2c2 0300 	movt	r3, #8192	; 0x2000
}

static inline void queue_insert(thread_t *tp, threads_queue_t *tqp) {

  tp->queue.next             = (thread_t *)tqp;
  tp->queue.prev             = tqp->prev;
 80014fe:	6844      	ldr	r4, [r0, #4]
 8001500:	699b      	ldr	r3, [r3, #24]

  return chSchGoSleepTimeoutS(CH_STATE_QUEUED, timeout);
 8001502:	2004      	movs	r0, #4
 8001504:	e883 0014 	stmia.w	r3, {r2, r4}
  tp->queue.prev->queue.next = tp;
 8001508:	6023      	str	r3, [r4, #0]
  tqp->prev                  = tp;
 800150a:	6053      	str	r3, [r2, #4]
}
 800150c:	f85d 4b04 	ldr.w	r4, [sp], #4
    return MSG_TIMEOUT;
  }

  queue_insert(currp, tqp);

  return chSchGoSleepTimeoutS(CH_STATE_QUEUED, timeout);
 8001510:	f7ff bfb6 	b.w	8001480 <chSchGoSleepTimeoutS>
}
 8001514:	f04f 30ff 	mov.w	r0, #4294967295
 8001518:	f85d 4b04 	ldr.w	r4, [sp], #4
 800151c:	4770      	bx	lr
 800151e:	bf00      	nop

08001520 <iqGetTimeout>:
 * @retval MSG_TIMEOUT  if the specified time expired.
 * @retval MSG_RESET    if the queue has been reset.
 *
 * @api
 */
msg_t iqGetTimeout(input_queue_t *iqp, systime_t timeout) {
 8001520:	b570      	push	{r4, r5, r6, lr}
 8001522:	2320      	movs	r3, #32
 8001524:	4604      	mov	r4, r0
 8001526:	460e      	mov	r6, r1
 8001528:	f383 8811 	msr	BASEPRI, r3
 800152c:	e003      	b.n	8001536 <iqGetTimeout+0x16>
 * @sclass
 */
static inline msg_t osalThreadEnqueueTimeoutS(threads_queue_t *tqp,
                                              systime_t time) {

  return chThdEnqueueTimeoutS(tqp, time);
 800152e:	f7ff ffdf 	bl	80014f0 <chThdEnqueueTimeoutS.4393>
  osalSysLock();

  /* Waiting until there is a character available or a timeout occurs.*/
  while (iqIsEmptyI(iqp)) {
    msg_t msg = osalThreadEnqueueTimeoutS(&iqp->q_waiting, timeout);
    if (msg < MSG_OK) {
 8001532:	2800      	cmp	r0, #0
 8001534:	db1b      	blt.n	800156e <iqGetTimeout+0x4e>
  uint8_t b;

  osalSysLock();

  /* Waiting until there is a character available or a timeout occurs.*/
  while (iqIsEmptyI(iqp)) {
 8001536:	68a5      	ldr	r5, [r4, #8]
 8001538:	4620      	mov	r0, r4
 800153a:	4631      	mov	r1, r6
 800153c:	2d00      	cmp	r5, #0
 800153e:	d0f6      	beq.n	800152e <iqGetTimeout+0xe>
    }
  }

  /* Getting the character from the queue.*/
  iqp->q_counter--;
  b = *iqp->q_rdptr++;
 8001540:	69a2      	ldr	r2, [r4, #24]
  if (iqp->q_rdptr >= iqp->q_top) {
 8001542:	6921      	ldr	r1, [r4, #16]
    }
  }

  /* Getting the character from the queue.*/
  iqp->q_counter--;
  b = *iqp->q_rdptr++;
 8001544:	1c53      	adds	r3, r2, #1
      return msg;
    }
  }

  /* Getting the character from the queue.*/
  iqp->q_counter--;
 8001546:	68a0      	ldr	r0, [r4, #8]
  b = *iqp->q_rdptr++;
  if (iqp->q_rdptr >= iqp->q_top) {
 8001548:	428b      	cmp	r3, r1
    }
  }

  /* Getting the character from the queue.*/
  iqp->q_counter--;
  b = *iqp->q_rdptr++;
 800154a:	61a3      	str	r3, [r4, #24]
      return msg;
    }
  }

  /* Getting the character from the queue.*/
  iqp->q_counter--;
 800154c:	f100 30ff 	add.w	r0, r0, #4294967295
  b = *iqp->q_rdptr++;
  if (iqp->q_rdptr >= iqp->q_top) {
    iqp->q_rdptr = iqp->q_buffer;
 8001550:	bf28      	it	cs
 8001552:	68e3      	ldrcs	r3, [r4, #12]
      return msg;
    }
  }

  /* Getting the character from the queue.*/
  iqp->q_counter--;
 8001554:	60a0      	str	r0, [r4, #8]
  b = *iqp->q_rdptr++;
 8001556:	7815      	ldrb	r5, [r2, #0]
  if (iqp->q_rdptr >= iqp->q_top) {
    iqp->q_rdptr = iqp->q_buffer;
 8001558:	bf28      	it	cs
 800155a:	61a3      	strcs	r3, [r4, #24]
  }

  /* Inform the low side that the queue has at least one slot available.*/
  if (iqp->q_notify != NULL) {
 800155c:	69e3      	ldr	r3, [r4, #28]
 800155e:	b10b      	cbz	r3, 8001564 <iqGetTimeout+0x44>
    iqp->q_notify(iqp);
 8001560:	4620      	mov	r0, r4
 8001562:	4798      	blx	r3
 8001564:	2300      	movs	r3, #0
 8001566:	f383 8811 	msr	BASEPRI, r3
  }

  osalSysUnlock();

  return (msg_t)b;
 800156a:	4628      	mov	r0, r5
}
 800156c:	bd70      	pop	{r4, r5, r6, pc}
 800156e:	f385 8811 	msr	BASEPRI, r5
 8001572:	bd70      	pop	{r4, r5, r6, pc}
 8001574:	f3af 8000 	nop.w
 8001578:	f3af 8000 	nop.w
 800157c:	f3af 8000 	nop.w

08001580 <_gett.7843>:
  return oqPutTimeout(&((SerialDriver *)ip)->oqueue, b, timeout);
}

static msg_t _gett(void *ip, systime_t timeout) {

  return iqGetTimeout(&((SerialDriver *)ip)->iqueue, timeout);
 8001580:	300c      	adds	r0, #12
 8001582:	f7ff bfcd 	b.w	8001520 <iqGetTimeout>
 8001586:	bf00      	nop
 8001588:	f3af 8000 	nop.w
 800158c:	f3af 8000 	nop.w

08001590 <_get.7847>:
  return oqPutTimeout(&((SerialDriver *)ip)->oqueue, b, TIME_INFINITE);
}

static msg_t _get(void *ip) {

  return iqGetTimeout(&((SerialDriver *)ip)->iqueue, TIME_INFINITE);
 8001590:	300c      	adds	r0, #12
 8001592:	f64f 71ff 	movw	r1, #65535	; 0xffff
 8001596:	f7ff bfc3 	b.w	8001520 <iqGetTimeout>
 800159a:	bf00      	nop
 800159c:	f3af 8000 	nop.w

080015a0 <iqReadTimeout.4352>:
 * @return              The number of bytes effectively transferred.
 *
 * @api
 */
size_t iqReadTimeout(input_queue_t *iqp, uint8_t *bp,
                     size_t n, systime_t timeout) {
 80015a0:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 80015a4:	4698      	mov	r8, r3
 80015a6:	b083      	sub	sp, #12
 80015a8:	4604      	mov	r4, r0
 80015aa:	4689      	mov	r9, r1
 80015ac:	4615      	mov	r5, r2
  systime_t deadline;
  qnotify_t nfy = iqp->q_notify;
 80015ae:	69c7      	ldr	r7, [r0, #28]
 80015b0:	2320      	movs	r3, #32
 80015b2:	f383 8811 	msr	BASEPRI, r3
 *
 * @notapi
 */
static inline systime_t st_lld_get_counter(void) {

  return (systime_t)STM32_ST_TIM->CNT;
 80015b6:	f04f 4380 	mov.w	r3, #1073741824	; 0x40000000
 80015ba:	6a5a      	ldr	r2, [r3, #36]	; 0x24
    while (iqIsEmptyI(iqp)) {
      msg_t msg;

      /* TIME_INFINITE and TIME_IMMEDIATE are handled differently, no
         deadline.*/
      if ((timeout == TIME_INFINITE) || (timeout == TIME_IMMEDIATE)) {
 80015bc:	f108 3bff 	add.w	fp, r8, #4294967295
  osalSysLock();

  /* Time deadline for the whole operation, note the result is invalid
     when timeout is TIME_INFINITE or TIME_IMMEDIATE but in that case
     the deadline is not used.*/
  deadline = osalOsGetSystemTimeX() + timeout;
 80015c0:	4442      	add	r2, r8
 80015c2:	b292      	uxth	r2, r2
 */
size_t iqReadTimeout(input_queue_t *iqp, uint8_t *bp,
                     size_t n, systime_t timeout) {
  systime_t deadline;
  qnotify_t nfy = iqp->q_notify;
  size_t r = 0;
 80015c4:	2600      	movs	r6, #0
  osalSysLock();

  /* Time deadline for the whole operation, note the result is invalid
     when timeout is TIME_INFINITE or TIME_IMMEDIATE but in that case
     the deadline is not used.*/
  deadline = osalOsGetSystemTimeX() + timeout;
 80015c6:	9201      	str	r2, [sp, #4]
    while (iqIsEmptyI(iqp)) {
      msg_t msg;

      /* TIME_INFINITE and TIME_IMMEDIATE are handled differently, no
         deadline.*/
      if ((timeout == TIME_INFINITE) || (timeout == TIME_IMMEDIATE)) {
 80015c8:	fa1f fb8b 	uxth.w	fp, fp
     the deadline is not used.*/
  deadline = osalOsGetSystemTimeX() + timeout;

  while (true) {
    /* Waiting until there is a character available or a timeout occurs.*/
    while (iqIsEmptyI(iqp)) {
 80015cc:	68a3      	ldr	r3, [r4, #8]
 80015ce:	b30b      	cbz	r3, 8001614 <iqReadTimeout.4352+0x74>
      }
    }

    /* Getting the character from the queue.*/
    iqp->q_counter--;
    *bp++ = *iqp->q_rdptr++;
 80015d0:	69a3      	ldr	r3, [r4, #24]
        return r;
      }
    }

    /* Getting the character from the queue.*/
    iqp->q_counter--;
 80015d2:	68a1      	ldr	r1, [r4, #8]
    *bp++ = *iqp->q_rdptr++;
 80015d4:	1c5a      	adds	r2, r3, #1
        return r;
      }
    }

    /* Getting the character from the queue.*/
    iqp->q_counter--;
 80015d6:	3901      	subs	r1, #1
    *bp++ = *iqp->q_rdptr++;
 80015d8:	61a2      	str	r2, [r4, #24]
        return r;
      }
    }

    /* Getting the character from the queue.*/
    iqp->q_counter--;
 80015da:	60a1      	str	r1, [r4, #8]
    *bp++ = *iqp->q_rdptr++;
 80015dc:	781b      	ldrb	r3, [r3, #0]
 80015de:	f109 0a01 	add.w	sl, r9, #1
 80015e2:	f889 3000 	strb.w	r3, [r9]
    if (iqp->q_rdptr >= iqp->q_top) {
 80015e6:	6923      	ldr	r3, [r4, #16]
 80015e8:	69a2      	ldr	r2, [r4, #24]
 80015ea:	429a      	cmp	r2, r3
      iqp->q_rdptr = iqp->q_buffer;
 80015ec:	bf24      	itt	cs
 80015ee:	68e3      	ldrcs	r3, [r4, #12]
 80015f0:	61a3      	strcs	r3, [r4, #24]
    }

    /* Inform the low side that the queue has at least one slot available.*/
    if (nfy != NULL) {
 80015f2:	b10f      	cbz	r7, 80015f8 <iqReadTimeout.4352+0x58>
      nfy(iqp);
 80015f4:	4620      	mov	r0, r4
 80015f6:	47b8      	blx	r7
 80015f8:	2300      	movs	r3, #0
 80015fa:	f383 8811 	msr	BASEPRI, r3

    /* Giving a preemption chance in a controlled point.*/
    osalSysUnlock();

    r++;
    if (--n == 0U) {
 80015fe:	3d01      	subs	r5, #1
    }

    /* Giving a preemption chance in a controlled point.*/
    osalSysUnlock();

    r++;
 8001600:	f106 0601 	add.w	r6, r6, #1
    if (--n == 0U) {
 8001604:	d01a      	beq.n	800163c <iqReadTimeout.4352+0x9c>
 8001606:	2220      	movs	r2, #32
 8001608:	f382 8811 	msr	BASEPRI, r2
     the deadline is not used.*/
  deadline = osalOsGetSystemTimeX() + timeout;

  while (true) {
    /* Waiting until there is a character available or a timeout occurs.*/
    while (iqIsEmptyI(iqp)) {
 800160c:	68a3      	ldr	r3, [r4, #8]
      }
    }

    /* Getting the character from the queue.*/
    iqp->q_counter--;
    *bp++ = *iqp->q_rdptr++;
 800160e:	46d1      	mov	r9, sl
     the deadline is not used.*/
  deadline = osalOsGetSystemTimeX() + timeout;

  while (true) {
    /* Waiting until there is a character available or a timeout occurs.*/
    while (iqIsEmptyI(iqp)) {
 8001610:	2b00      	cmp	r3, #0
 8001612:	d1dd      	bne.n	80015d0 <iqReadTimeout.4352+0x30>
      msg_t msg;

      /* TIME_INFINITE and TIME_IMMEDIATE are handled differently, no
         deadline.*/
      if ((timeout == TIME_INFINITE) || (timeout == TIME_IMMEDIATE)) {
 8001614:	f64f 72fd 	movw	r2, #65533	; 0xfffd
 8001618:	4593      	cmp	fp, r2
 800161a:	d813      	bhi.n	8001644 <iqReadTimeout.4352+0xa4>
 800161c:	f04f 4280 	mov.w	r2, #1073741824	; 0x40000000
 8001620:	6a51      	ldr	r1, [r2, #36]	; 0x24
        msg = osalThreadEnqueueTimeoutS(&iqp->q_waiting, timeout);
      }
      else {
        systime_t next_timeout = deadline - osalOsGetSystemTimeX();
 8001622:	9a01      	ldr	r2, [sp, #4]
 8001624:	1a51      	subs	r1, r2, r1
 8001626:	b289      	uxth	r1, r1

        /* Handling the case where the system time went past the deadline,
           in this case next becomes a very high number because the system
           time is an unsigned type.*/
        if (next_timeout > timeout) {
 8001628:	4588      	cmp	r8, r1
 800162a:	d305      	bcc.n	8001638 <iqReadTimeout.4352+0x98>
 800162c:	4620      	mov	r0, r4
 800162e:	f7ff ff5f 	bl	80014f0 <chThdEnqueueTimeoutS.4393>

        msg = osalThreadEnqueueTimeoutS(&iqp->q_waiting, next_timeout);
      }

      /* Anything except MSG_OK causes the operation to stop.*/
      if (msg != MSG_OK) {
 8001632:	2800      	cmp	r0, #0
 8001634:	d0ca      	beq.n	80015cc <iqReadTimeout.4352+0x2c>
 8001636:	2300      	movs	r3, #0
 8001638:	f383 8811 	msr	BASEPRI, r3
      return r;
    }

    osalSysLock();
  }
}
 800163c:	4630      	mov	r0, r6
 800163e:	b003      	add	sp, #12
 8001640:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
 8001644:	4620      	mov	r0, r4
 8001646:	4641      	mov	r1, r8
 8001648:	f7ff ff52 	bl	80014f0 <chThdEnqueueTimeoutS.4393>

        msg = osalThreadEnqueueTimeoutS(&iqp->q_waiting, next_timeout);
      }

      /* Anything except MSG_OK causes the operation to stop.*/
      if (msg != MSG_OK) {
 800164c:	2800      	cmp	r0, #0
 800164e:	d0bd      	beq.n	80015cc <iqReadTimeout.4352+0x2c>
 8001650:	e7f1      	b.n	8001636 <iqReadTimeout.4352+0x96>
 8001652:	bf00      	nop
 8001654:	f3af 8000 	nop.w
 8001658:	f3af 8000 	nop.w
 800165c:	f3af 8000 	nop.w

08001660 <_readt.7819>:
  return oqWriteTimeout(&((SerialDriver *)ip)->oqueue, bp, n, timeout);
}

static size_t _readt(void *ip, uint8_t *bp, size_t n, systime_t timeout) {

  return iqReadTimeout(&((SerialDriver *)ip)->iqueue, bp, n, timeout);
 8001660:	300c      	adds	r0, #12
 8001662:	f7ff bf9d 	b.w	80015a0 <iqReadTimeout.4352>
 8001666:	bf00      	nop
 8001668:	f3af 8000 	nop.w
 800166c:	f3af 8000 	nop.w

08001670 <_read.7827>:
                        n, TIME_INFINITE);
}

static size_t _read(void *ip, uint8_t *bp, size_t n) {

  return iqReadTimeout(&((SerialDriver *)ip)->iqueue, bp,
 8001670:	300c      	adds	r0, #12
 8001672:	f64f 73ff 	movw	r3, #65535	; 0xffff
 8001676:	f7ff bf93 	b.w	80015a0 <iqReadTimeout.4352>
 800167a:	bf00      	nop
 800167c:	f3af 8000 	nop.w

08001680 <oqPutTimeout.4367>:
 * @retval MSG_TIMEOUT  if the specified time expired.
 * @retval MSG_RESET    if the queue has been reset.
 *
 * @api
 */
msg_t oqPutTimeout(output_queue_t *oqp, uint8_t b, systime_t timeout) {
 8001680:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 8001682:	4604      	mov	r4, r0
 8001684:	460f      	mov	r7, r1
 8001686:	4616      	mov	r6, r2
 8001688:	2320      	movs	r3, #32
 800168a:	f383 8811 	msr	BASEPRI, r3
 800168e:	e003      	b.n	8001698 <oqPutTimeout.4367+0x18>
 8001690:	f7ff ff2e 	bl	80014f0 <chThdEnqueueTimeoutS.4393>
  osalSysLock();

  /* Waiting until there is a slot available or a timeout occurs.*/
  while (oqIsFullI(oqp)) {
    msg_t msg = osalThreadEnqueueTimeoutS(&oqp->q_waiting, timeout);
    if (msg < MSG_OK) {
 8001694:	2800      	cmp	r0, #0
 8001696:	db1a      	blt.n	80016ce <oqPutTimeout.4367+0x4e>
msg_t oqPutTimeout(output_queue_t *oqp, uint8_t b, systime_t timeout) {

  osalSysLock();

  /* Waiting until there is a slot available or a timeout occurs.*/
  while (oqIsFullI(oqp)) {
 8001698:	68a5      	ldr	r5, [r4, #8]
 800169a:	4620      	mov	r0, r4
 800169c:	4631      	mov	r1, r6
 800169e:	2d00      	cmp	r5, #0
 80016a0:	d0f6      	beq.n	8001690 <oqPutTimeout.4367+0x10>
    }
  }

  /* Putting the character into the queue.*/
  oqp->q_counter--;
  *oqp->q_wrptr++ = b;
 80016a2:	6963      	ldr	r3, [r4, #20]
      return msg;
    }
  }

  /* Putting the character into the queue.*/
  oqp->q_counter--;
 80016a4:	68a1      	ldr	r1, [r4, #8]
  *oqp->q_wrptr++ = b;
 80016a6:	1c5a      	adds	r2, r3, #1
      return msg;
    }
  }

  /* Putting the character into the queue.*/
  oqp->q_counter--;
 80016a8:	3901      	subs	r1, #1
  *oqp->q_wrptr++ = b;
 80016aa:	6162      	str	r2, [r4, #20]
      return msg;
    }
  }

  /* Putting the character into the queue.*/
  oqp->q_counter--;
 80016ac:	60a1      	str	r1, [r4, #8]
  *oqp->q_wrptr++ = b;
 80016ae:	701f      	strb	r7, [r3, #0]
  if (oqp->q_wrptr >= oqp->q_top) {
 80016b0:	6923      	ldr	r3, [r4, #16]
 80016b2:	6962      	ldr	r2, [r4, #20]
 80016b4:	429a      	cmp	r2, r3
    oqp->q_wrptr = oqp->q_buffer;
 80016b6:	bf24      	itt	cs
 80016b8:	68e3      	ldrcs	r3, [r4, #12]
 80016ba:	6163      	strcs	r3, [r4, #20]
  }

  /* Inform the low side that the queue has at least one character available.*/
  if (oqp->q_notify != NULL) {
 80016bc:	69e3      	ldr	r3, [r4, #28]
 80016be:	b10b      	cbz	r3, 80016c4 <oqPutTimeout.4367+0x44>
    oqp->q_notify(oqp);
 80016c0:	4620      	mov	r0, r4
 80016c2:	4798      	blx	r3
 80016c4:	2300      	movs	r3, #0
 80016c6:	f383 8811 	msr	BASEPRI, r3
 80016ca:	2000      	movs	r0, #0
  }

  osalSysUnlock();

  return MSG_OK;
}
 80016cc:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
 80016ce:	f385 8811 	msr	BASEPRI, r5
 80016d2:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
 80016d4:	f3af 8000 	nop.w
 80016d8:	f3af 8000 	nop.w
 80016dc:	f3af 8000 	nop.w

080016e0 <_putt.7850>:
  return iqGetTimeout(&((SerialDriver *)ip)->iqueue, TIME_INFINITE);
}

static msg_t _putt(void *ip, uint8_t b, systime_t timeout) {

  return oqPutTimeout(&((SerialDriver *)ip)->oqueue, b, timeout);
 80016e0:	3030      	adds	r0, #48	; 0x30
 80016e2:	f7ff bfcd 	b.w	8001680 <oqPutTimeout.4367>
 80016e6:	bf00      	nop
 80016e8:	f3af 8000 	nop.w
 80016ec:	f3af 8000 	nop.w

080016f0 <_put.7855>:
                       n, TIME_INFINITE);
}

static msg_t _put(void *ip, uint8_t b) {

  return oqPutTimeout(&((SerialDriver *)ip)->oqueue, b, TIME_INFINITE);
 80016f0:	3030      	adds	r0, #48	; 0x30
 80016f2:	f64f 72ff 	movw	r2, #65535	; 0xffff
 80016f6:	f7ff bfc3 	b.w	8001680 <oqPutTimeout.4367>
 80016fa:	bf00      	nop
 80016fc:	f3af 8000 	nop.w

08001700 <oqWriteTimeout.4387>:
 * @return              The number of bytes effectively transferred.
 *
 * @api
 */
size_t oqWriteTimeout(output_queue_t *oqp, const uint8_t *bp,
                      size_t n, systime_t timeout) {
 8001700:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 8001704:	4698      	mov	r8, r3
 8001706:	b083      	sub	sp, #12
 8001708:	4604      	mov	r4, r0
 800170a:	4689      	mov	r9, r1
 800170c:	4615      	mov	r5, r2
  systime_t deadline;
  qnotify_t nfy = oqp->q_notify;
 800170e:	69c7      	ldr	r7, [r0, #28]
 8001710:	2320      	movs	r3, #32
 8001712:	f383 8811 	msr	BASEPRI, r3
 8001716:	f04f 4380 	mov.w	r3, #1073741824	; 0x40000000
 800171a:	6a5a      	ldr	r2, [r3, #36]	; 0x24
    msg_t msg;

    while (oqIsFullI(oqp)) {
      /* TIME_INFINITE and TIME_IMMEDIATE are handled differently, no
         deadline.*/
      if ((timeout == TIME_INFINITE) || (timeout == TIME_IMMEDIATE)) {
 800171c:	f108 3bff 	add.w	fp, r8, #4294967295
  osalSysLock();

  /* Time deadline for the whole operation, note the result is invalid
     when timeout is TIME_INFINITE or TIME_IMMEDIATE but in that case
     the deadline is not used.*/
  deadline = osalOsGetSystemTimeX() + timeout;
 8001720:	4442      	add	r2, r8
 */
size_t oqWriteTimeout(output_queue_t *oqp, const uint8_t *bp,
                      size_t n, systime_t timeout) {
  systime_t deadline;
  qnotify_t nfy = oqp->q_notify;
  size_t w = 0;
 8001722:	2600      	movs	r6, #0
  osalSysLock();

  /* Time deadline for the whole operation, note the result is invalid
     when timeout is TIME_INFINITE or TIME_IMMEDIATE but in that case
     the deadline is not used.*/
  deadline = osalOsGetSystemTimeX() + timeout;
 8001724:	b292      	uxth	r2, r2
 8001726:	9201      	str	r2, [sp, #4]
    msg_t msg;

    while (oqIsFullI(oqp)) {
      /* TIME_INFINITE and TIME_IMMEDIATE are handled differently, no
         deadline.*/
      if ((timeout == TIME_INFINITE) || (timeout == TIME_IMMEDIATE)) {
 8001728:	fa1f fb8b 	uxth.w	fp, fp
 800172c:	46b2      	mov	sl, r6
  deadline = osalOsGetSystemTimeX() + timeout;

  while (true) {
    msg_t msg;

    while (oqIsFullI(oqp)) {
 800172e:	68a3      	ldr	r3, [r4, #8]
 8001730:	b1fb      	cbz	r3, 8001772 <oqWriteTimeout.4387+0x72>
      }
    }

    /* Putting the character into the queue.*/
    oqp->q_counter--;
    *oqp->q_wrptr++ = *bp++;
 8001732:	6963      	ldr	r3, [r4, #20]
        return w;
      }
    }

    /* Putting the character into the queue.*/
    oqp->q_counter--;
 8001734:	68a1      	ldr	r1, [r4, #8]
    *oqp->q_wrptr++ = *bp++;
 8001736:	1c5a      	adds	r2, r3, #1
        return w;
      }
    }

    /* Putting the character into the queue.*/
    oqp->q_counter--;
 8001738:	3901      	subs	r1, #1
    *oqp->q_wrptr++ = *bp++;
 800173a:	6162      	str	r2, [r4, #20]
        return w;
      }
    }

    /* Putting the character into the queue.*/
    oqp->q_counter--;
 800173c:	60a1      	str	r1, [r4, #8]
    *oqp->q_wrptr++ = *bp++;
 800173e:	f899 2000 	ldrb.w	r2, [r9]
 8001742:	f109 0901 	add.w	r9, r9, #1
 8001746:	701a      	strb	r2, [r3, #0]
    if (oqp->q_wrptr >= oqp->q_top) {
 8001748:	6923      	ldr	r3, [r4, #16]
 800174a:	6962      	ldr	r2, [r4, #20]
 800174c:	429a      	cmp	r2, r3
      oqp->q_wrptr = oqp->q_buffer;
 800174e:	bf24      	itt	cs
 8001750:	68e3      	ldrcs	r3, [r4, #12]
 8001752:	6163      	strcs	r3, [r4, #20]
    }

    /* Inform the low side that the queue has at least one character available.*/
    if (nfy != NULL) {
 8001754:	b10f      	cbz	r7, 800175a <oqWriteTimeout.4387+0x5a>
      nfy(oqp);
 8001756:	4620      	mov	r0, r4
 8001758:	47b8      	blx	r7
 800175a:	f38a 8811 	msr	BASEPRI, sl

    /* Giving a preemption chance in a controlled point.*/
    osalSysUnlock();

    w++;
    if (--n == 0U) {
 800175e:	3d01      	subs	r5, #1
    }

    /* Giving a preemption chance in a controlled point.*/
    osalSysUnlock();

    w++;
 8001760:	f106 0601 	add.w	r6, r6, #1
    if (--n == 0U) {
 8001764:	d019      	beq.n	800179a <oqWriteTimeout.4387+0x9a>
 8001766:	2320      	movs	r3, #32
 8001768:	f383 8811 	msr	BASEPRI, r3
  deadline = osalOsGetSystemTimeX() + timeout;

  while (true) {
    msg_t msg;

    while (oqIsFullI(oqp)) {
 800176c:	68a3      	ldr	r3, [r4, #8]
 800176e:	2b00      	cmp	r3, #0
 8001770:	d1df      	bne.n	8001732 <oqWriteTimeout.4387+0x32>
      /* TIME_INFINITE and TIME_IMMEDIATE are handled differently, no
         deadline.*/
      if ((timeout == TIME_INFINITE) || (timeout == TIME_IMMEDIATE)) {
 8001772:	f64f 72fd 	movw	r2, #65533	; 0xfffd
 8001776:	4593      	cmp	fp, r2
 8001778:	d813      	bhi.n	80017a2 <oqWriteTimeout.4387+0xa2>
 800177a:	f04f 4280 	mov.w	r2, #1073741824	; 0x40000000
 800177e:	6a51      	ldr	r1, [r2, #36]	; 0x24
        msg = osalThreadEnqueueTimeoutS(&oqp->q_waiting, timeout);
      }
      else {
        systime_t next_timeout = deadline - osalOsGetSystemTimeX();
 8001780:	9a01      	ldr	r2, [sp, #4]
 8001782:	1a51      	subs	r1, r2, r1
 8001784:	b289      	uxth	r1, r1

        /* Handling the case where the system time went past the deadline,
           in this case next becomes a very high number because the system
           time is an unsigned type.*/
        if (next_timeout > timeout) {
 8001786:	4588      	cmp	r8, r1
 8001788:	d305      	bcc.n	8001796 <oqWriteTimeout.4387+0x96>
 800178a:	4620      	mov	r0, r4
 800178c:	f7ff feb0 	bl	80014f0 <chThdEnqueueTimeoutS.4393>

        msg = osalThreadEnqueueTimeoutS(&oqp->q_waiting, next_timeout);
      }

      /* Anything except MSG_OK causes the operation to stop.*/
      if (msg != MSG_OK) {
 8001790:	2800      	cmp	r0, #0
 8001792:	d0cc      	beq.n	800172e <oqWriteTimeout.4387+0x2e>
 8001794:	2300      	movs	r3, #0
 8001796:	f383 8811 	msr	BASEPRI, r3
      return w;
    }

    osalSysLock();
  }
}
 800179a:	4630      	mov	r0, r6
 800179c:	b003      	add	sp, #12
 800179e:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
 80017a2:	4620      	mov	r0, r4
 80017a4:	4641      	mov	r1, r8
 80017a6:	f7ff fea3 	bl	80014f0 <chThdEnqueueTimeoutS.4393>

        msg = osalThreadEnqueueTimeoutS(&oqp->q_waiting, next_timeout);
      }

      /* Anything except MSG_OK causes the operation to stop.*/
      if (msg != MSG_OK) {
 80017aa:	2800      	cmp	r0, #0
 80017ac:	d0bf      	beq.n	800172e <oqWriteTimeout.4387+0x2e>
 80017ae:	e7f1      	b.n	8001794 <oqWriteTimeout.4387+0x94>

080017b0 <_writet.7832>:
  return iqGetTimeout(&((SerialDriver *)ip)->iqueue, timeout);
}

static size_t _writet(void *ip, const uint8_t *bp, size_t n, systime_t timeout) {

  return oqWriteTimeout(&((SerialDriver *)ip)->oqueue, bp, n, timeout);
 80017b0:	3030      	adds	r0, #48	; 0x30
 80017b2:	f7ff bfa5 	b.w	8001700 <oqWriteTimeout.4387>
 80017b6:	bf00      	nop
 80017b8:	f3af 8000 	nop.w
 80017bc:	f3af 8000 	nop.w

080017c0 <_write.7838>:
 * queue-level function or macro.
 */

static size_t _write(void *ip, const uint8_t *bp, size_t n) {

  return oqWriteTimeout(&((SerialDriver *)ip)->oqueue, bp,
 80017c0:	3030      	adds	r0, #48	; 0x30
 80017c2:	f64f 73ff 	movw	r3, #65535	; 0xffff
 80017c6:	f7ff bf9b 	b.w	8001700 <oqWriteTimeout.4387>
 80017ca:	bf00      	nop
 80017cc:	f3af 8000 	nop.w

080017d0 <i2c_lld_master_transmit_timeout.constprop.11>:
 *                      timeout the driver must be stopped and restarted
 *                      because the bus is in an uncertain state</b>.
 *
 * @notapi
 */
msg_t i2c_lld_master_transmit_timeout(I2CDriver *i2cp, i2caddr_t addr,
 80017d0:	b5f8      	push	{r3, r4, r5, r6, r7, lr}

  /* Resetting error flags for this transfer.*/
  i2cp->errors = I2C_NO_ERROR;

  /* Initializes driver fields, LSB = 0 -> transmit.*/
  i2cp->addr = (addr << 1);
 80017d2:	24e0      	movs	r4, #224	; 0xe0
#if defined(STM32F1XX_I2C)
  osalDbgCheck((rxbytes == 0) || ((rxbytes > 1) && (rxbuf != NULL)));
#endif

  /* Resetting error flags for this transfer.*/
  i2cp->errors = I2C_NO_ERROR;
 80017d4:	2300      	movs	r3, #0

  /* Initializes driver fields, LSB = 0 -> transmit.*/
  i2cp->addr = (addr << 1);
 80017d6:	8404      	strh	r4, [r0, #32]
#if defined(STM32F1XX_I2C)
  osalDbgCheck((rxbytes == 0) || ((rxbytes > 1) && (rxbuf != NULL)));
#endif

  /* Resetting error flags for this transfer.*/
  i2cp->errors = I2C_NO_ERROR;
 80017d8:	6083      	str	r3, [r0, #8]
 */
msg_t i2c_lld_master_transmit_timeout(I2CDriver *i2cp, i2caddr_t addr,
                                      const uint8_t *txbuf, size_t txbytes,
                                      uint8_t *rxbuf, size_t rxbytes,
                                      systime_t timeout) {
  I2C_TypeDef *dp = i2cp->i2c;
 80017da:	6b44      	ldr	r4, [r0, #52]	; 0x34
 80017dc:	f383 8811 	msr	BASEPRI, r3

  /* Releases the lock from high level driver.*/
  osalSysUnlock();

  /* TX DMA setup.*/
  dmaStreamSetMode(i2cp->dmatx, i2cp->txdmamode);
 80017e0:	6b05      	ldr	r5, [r0, #48]	; 0x30
  dmaStreamSetMemory0(i2cp->dmatx, txbuf);
  dmaStreamSetTransactionSize(i2cp->dmatx, txbytes);

  /* RX DMA setup.*/
  dmaStreamSetMode(i2cp->dmarx, i2cp->rxdmamode);
 80017e2:	6ac3      	ldr	r3, [r0, #44]	; 0x2c

  /* Releases the lock from high level driver.*/
  osalSysUnlock();

  /* TX DMA setup.*/
  dmaStreamSetMode(i2cp->dmatx, i2cp->txdmamode);
 80017e4:	686d      	ldr	r5, [r5, #4]
 80017e6:	6a87      	ldr	r7, [r0, #40]	; 0x28
  dmaStreamSetMemory0(i2cp->dmatx, txbuf);
  dmaStreamSetTransactionSize(i2cp->dmatx, txbytes);

  /* RX DMA setup.*/
  dmaStreamSetMode(i2cp->dmarx, i2cp->rxdmamode);
 80017e8:	685b      	ldr	r3, [r3, #4]
 80017ea:	f8d0 c024 	ldr.w	ip, [r0, #36]	; 0x24
  dmaStreamSetMemory0(i2cp->dmarx, rxbuf);
 80017ee:	2600      	movs	r6, #0

  /* Releases the lock from high level driver.*/
  osalSysUnlock();

  /* TX DMA setup.*/
  dmaStreamSetMode(i2cp->dmatx, i2cp->txdmamode);
 80017f0:	602f      	str	r7, [r5, #0]
  dmaStreamSetMemory0(i2cp->dmatx, txbuf);
 80017f2:	60e9      	str	r1, [r5, #12]
 80017f4:	f04f 4780 	mov.w	r7, #1073741824	; 0x40000000
  dmaStreamSetTransactionSize(i2cp->dmatx, txbytes);
 80017f8:	606a      	str	r2, [r5, #4]

  /* RX DMA setup.*/
  dmaStreamSetMode(i2cp->dmarx, i2cp->rxdmamode);
 80017fa:	f8c3 c000 	str.w	ip, [r3]
  dmaStreamSetMemory0(i2cp->dmarx, rxbuf);
 80017fe:	60de      	str	r6, [r3, #12]
  dmaStreamSetTransactionSize(i2cp->dmarx, rxbytes);
 8001800:	605e      	str	r6, [r3, #4]
 8001802:	6a7d      	ldr	r5, [r7, #36]	; 0x24
 8001804:	4639      	mov	r1, r7
 8001806:	b2ad      	uxth	r5, r5
 8001808:	2220      	movs	r2, #32
 800180a:	e001      	b.n	8001810 <i2c_lld_master_transmit_timeout.constprop.11+0x40>
 800180c:	f386 8811 	msr	BASEPRI, r6
 8001810:	f382 8811 	msr	BASEPRI, r2
  while (true) {
    osalSysLock();

    /* If the bus is not busy then the operation can continue, note, the
       loop is exited in the locked state.*/
    if (!(dp->SR2 & I2C_SR2_BUSY) && !(dp->CR1 & I2C_CR1_STOP))
 8001814:	69a3      	ldr	r3, [r4, #24]
 8001816:	079b      	lsls	r3, r3, #30
 8001818:	d402      	bmi.n	8001820 <i2c_lld_master_transmit_timeout.constprop.11+0x50>
 800181a:	6823      	ldr	r3, [r4, #0]
 800181c:	059f      	lsls	r7, r3, #22
 800181e:	d507      	bpl.n	8001830 <i2c_lld_master_transmit_timeout.constprop.11+0x60>
 8001820:	6a4b      	ldr	r3, [r1, #36]	; 0x24
 */
static inline bool chVTIsTimeWithinX(systime_t time,
                                     systime_t start,
                                     systime_t end) {

  return (bool)((systime_t)(time - start) < (systime_t)(end - start));
 8001822:	1b5b      	subs	r3, r3, r5
      break;

    /* If the system time went outside the allowed window then a timeout
       condition is returned.*/
    if (!osalOsIsTimeWithinX(osalOsGetSystemTimeX(), start, end))
 8001824:	b29b      	uxth	r3, r3
 8001826:	2b31      	cmp	r3, #49	; 0x31
 8001828:	d9f0      	bls.n	800180c <i2c_lld_master_transmit_timeout.constprop.11+0x3c>
      return MSG_TIMEOUT;
 800182a:	f04f 30ff 	mov.w	r0, #4294967295
  dp->CR2 |= I2C_CR2_ITEVTEN;
  dp->CR1 |= I2C_CR1_START;

  /* Waits for the operation completion or a timeout.*/
  return osalThreadSuspendTimeoutS(&i2cp->thread, timeout);
}
 800182e:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}

    osalSysUnlock();
  }

  /* Starts the operation.*/
  dp->CR2 |= I2C_CR2_ITEVTEN;
 8001830:	6863      	ldr	r3, [r4, #4]
  *
  * @xclass
  */
static inline thread_t *chThdGetSelfX(void) {

  return ch.rlist.current;
 8001832:	f640 05d8 	movw	r5, #2264	; 0x8d8
 8001836:	f443 7300 	orr.w	r3, r3, #512	; 0x200
 800183a:	6063      	str	r3, [r4, #4]
  dp->CR1 |= I2C_CR1_START;
 800183c:	6822      	ldr	r2, [r4, #0]
 800183e:	f2c2 0500 	movt	r5, #8192	; 0x2000
 8001842:	69ab      	ldr	r3, [r5, #24]
 8001844:	f442 7280 	orr.w	r2, r2, #256	; 0x100
 8001848:	6022      	str	r2, [r4, #0]

  if (TIME_IMMEDIATE == timeout) {
    return MSG_TIMEOUT;
  }

  *trp = tp;
 800184a:	f840 3f1c 	str.w	r3, [r0, #28]!
  tp->u.wttrp = trp;
 800184e:	6258      	str	r0, [r3, #36]	; 0x24
    if (chVTIsArmedI(&vt)) {
      chVTDoResetI(&vt);
    }
  }
  else {
    chSchGoSleepS(newstate);
 8001850:	2003      	movs	r0, #3
 8001852:	f000 fcf5 	bl	8002240 <chSchGoSleepS>
  }

  return currp->u.rdymsg;
 8001856:	69ab      	ldr	r3, [r5, #24]
 8001858:	6a58      	ldr	r0, [r3, #36]	; 0x24
 800185a:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
 800185c:	f3af 8000 	nop.w

08001860 <chMtxUnlock.constprop.19>:
 *
 * @param[in] mp        pointer to the @p mutex_t structure
 *
 * @api
 */
void chMtxUnlock(mutex_t *mp) {
 8001860:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
  thread_t *ctp = currp;
 8001862:	f640 06d8 	movw	r6, #2264	; 0x8d8
 8001866:	f2c2 0600 	movt	r6, #8192	; 0x2000
 800186a:	69b0      	ldr	r0, [r6, #24]
 800186c:	2320      	movs	r3, #32
 800186e:	f383 8811 	msr	BASEPRI, r3
    chDbgAssert(ctp->mtxlist == mp, "not next in list");

    /* Removes the top mutex from the thread's owned mutexes list and marks
       it as not owned. Note, it is assumed to be the same mutex passed as
       parameter of this function.*/
    ctp->mtxlist = mp->next;
 8001872:	f640 2458 	movw	r4, #2648	; 0xa58
 8001876:	f2c2 0400 	movt	r4, #8192	; 0x2000
 *
 * @notapi
 */
static inline bool queue_notempty(const threads_queue_t *tqp) {

  return (bool)(tqp->next != (const thread_t *)tqp);
 800187a:	4627      	mov	r7, r4
 800187c:	f857 5f0c 	ldr.w	r5, [r7, #12]!
 8001880:	69a3      	ldr	r3, [r4, #24]

    /* If a thread is waiting on the mutex then the fun part begins.*/
    if (chMtxQueueNotEmptyS(mp)) {
 8001882:	42bd      	cmp	r5, r7
    chDbgAssert(ctp->mtxlist == mp, "not next in list");

    /* Removes the top mutex from the thread's owned mutexes list and marks
       it as not owned. Note, it is assumed to be the same mutex passed as
       parameter of this function.*/
    ctp->mtxlist = mp->next;
 8001884:	6383      	str	r3, [r0, #56]	; 0x38

    /* If a thread is waiting on the mutex then the fun part begins.*/
    if (chMtxQueueNotEmptyS(mp)) {
 8001886:	d03f      	beq.n	8001908 <chMtxUnlock.constprop.19+0xa8>
      thread_t *tp;

      /* Recalculates the optimal thread priority by scanning the owned
         mutexes list.*/
      tprio_t newprio = ctp->realprio;
 8001888:	6bc1      	ldr	r1, [r0, #60]	; 0x3c
      lmp = ctp->mtxlist;
      while (lmp != NULL) {
 800188a:	b14b      	cbz	r3, 80018a0 <chMtxUnlock.constprop.19+0x40>
 800188c:	681a      	ldr	r2, [r3, #0]
        /* If the highest priority thread waiting in the mutexes list has a
           greater priority than the current thread base priority then the
           final priority will have at least that priority.*/
        if (chMtxQueueNotEmptyS(lmp) &&
 800188e:	4293      	cmp	r3, r2
 8001890:	d003      	beq.n	800189a <chMtxUnlock.constprop.19+0x3a>
            (lmp->queue.next->prio > newprio)) {
 8001892:	6892      	ldr	r2, [r2, #8]
 8001894:	4291      	cmp	r1, r2
 8001896:	bf38      	it	cc
 8001898:	4611      	movcc	r1, r2
          newprio = lmp->queue.next->prio;
        }
        lmp = lmp->next;
 800189a:	68db      	ldr	r3, [r3, #12]

      /* Recalculates the optimal thread priority by scanning the owned
         mutexes list.*/
      tprio_t newprio = ctp->realprio;
      lmp = ctp->mtxlist;
      while (lmp != NULL) {
 800189c:	2b00      	cmp	r3, #0
 800189e:	d1f5      	bne.n	800188c <chMtxUnlock.constprop.19+0x2c>
}

static inline thread_t *queue_fifo_remove(threads_queue_t *tqp) {
  thread_t *tp = tqp->next;

  tqp->next             = tp->queue.next;
 80018a0:	682b      	ldr	r3, [r5, #0]
#if CH_CFG_USE_MUTEXES_RECURSIVE == TRUE
      mp->cnt = (cnt_t)1;
#endif
      tp = queue_fifo_remove(&mp->queue);
      mp->owner = tp;
      mp->next = tp->mtxlist;
 80018a2:	6baa      	ldr	r2, [r5, #56]	; 0x38
        lmp = lmp->next;
      }

      /* Assigns to the current thread the highest priority among all the
         waiting threads.*/
      ctp->prio = newprio;
 80018a4:	6081      	str	r1, [r0, #8]
 80018a6:	60e3      	str	r3, [r4, #12]

      /* Note, not using chSchWakeupS() becuase that function expects the
         current thread to have the higher or equal priority than the ones
         in the ready list. This is not necessarily true here because we
         just changed priority.*/
      (void) chSchReadyI(tp);
 80018a8:	4628      	mov	r0, r5
  tqp->next->queue.prev = (thread_t *)tqp;
 80018aa:	605f      	str	r7, [r3, #4]
         assigns the mutex to it.*/
#if CH_CFG_USE_MUTEXES_RECURSIVE == TRUE
      mp->cnt = (cnt_t)1;
#endif
      tp = queue_fifo_remove(&mp->queue);
      mp->owner = tp;
 80018ac:	6165      	str	r5, [r4, #20]
      mp->next = tp->mtxlist;
 80018ae:	61a2      	str	r2, [r4, #24]
      tp->mtxlist = mp;
 80018b0:	63af      	str	r7, [r5, #56]	; 0x38

      /* Note, not using chSchWakeupS() becuase that function expects the
         current thread to have the higher or equal priority than the ones
         in the ready list. This is not necessarily true here because we
         just changed priority.*/
      (void) chSchReadyI(tp);
 80018b2:	f000 fcdd 	bl	8002270 <chSchReadyI>
 */
static inline bool chSchIsRescRequiredI(void) {

  chDbgCheckClassI();

  return firstprio(&ch.rlist.queue) > currp->prio;
 80018b6:	6830      	ldr	r0, [r6, #0]
 80018b8:	69b5      	ldr	r5, [r6, #24]
 */
void chSchRescheduleS(void) {

  chDbgCheckClassS();

  if (chSchIsRescRequiredI()) {
 80018ba:	6883      	ldr	r3, [r0, #8]
 80018bc:	68ac      	ldr	r4, [r5, #8]
 80018be:	f640 02d8 	movw	r2, #2264	; 0x8d8
 80018c2:	42a3      	cmp	r3, r4
 80018c4:	f2c2 0200 	movt	r2, #8192	; 0x2000
 80018c8:	d803      	bhi.n	80018d2 <chMtxUnlock.constprop.19+0x72>
 80018ca:	2300      	movs	r3, #0
 80018cc:	f383 8811 	msr	BASEPRI, r3
 80018d0:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
}

static inline thread_t *queue_fifo_remove(threads_queue_t *tqp) {
  thread_t *tp = tqp->next;

  tqp->next             = tp->queue.next;
 80018d2:	6803      	ldr	r3, [r0, #0]
void chSchDoRescheduleAhead(void) {
  thread_t *otp = currp;

  /* Picks the first thread from the ready queue and makes it current.*/
  currp = queue_fifo_remove(&ch.rlist.queue);
  currp->state = CH_STATE_CURRENT;
 80018d4:	2601      	movs	r6, #1
  chDbgCheck(tp != NULL);
  chDbgAssert((tp->state != CH_STATE_READY) &&
              (tp->state != CH_STATE_FINAL),
              "invalid state");

  tp->state = CH_STATE_READY;
 80018d6:	2100      	movs	r1, #0
  tqp->next->queue.prev = (thread_t *)tqp;
 80018d8:	605a      	str	r2, [r3, #4]
}

static inline thread_t *queue_fifo_remove(threads_queue_t *tqp) {
  thread_t *tp = tqp->next;

  tqp->next             = tp->queue.next;
 80018da:	6013      	str	r3, [r2, #0]
void chSchDoRescheduleAhead(void) {
  thread_t *otp = currp;

  /* Picks the first thread from the ready queue and makes it current.*/
  currp = queue_fifo_remove(&ch.rlist.queue);
  currp->state = CH_STATE_CURRENT;
 80018dc:	f880 6020 	strb.w	r6, [r0, #32]
 */
void chSchDoRescheduleAhead(void) {
  thread_t *otp = currp;

  /* Picks the first thread from the ready queue and makes it current.*/
  currp = queue_fifo_remove(&ch.rlist.queue);
 80018e0:	6190      	str	r0, [r2, #24]
  chDbgCheck(tp != NULL);
  chDbgAssert((tp->state != CH_STATE_READY) &&
              (tp->state != CH_STATE_FINAL),
              "invalid state");

  tp->state = CH_STATE_READY;
 80018e2:	f885 1020 	strb.w	r1, [r5, #32]
 80018e6:	e000      	b.n	80018ea <chMtxUnlock.constprop.19+0x8a>
 80018e8:	681b      	ldr	r3, [r3, #0]
  cp = (thread_t *)&ch.rlist.queue;
  do {
    cp = cp->queue.next;
  } while (cp->prio > tp->prio);
 80018ea:	689a      	ldr	r2, [r3, #8]
 80018ec:	4294      	cmp	r4, r2
 80018ee:	d3fb      	bcc.n	80018e8 <chMtxUnlock.constprop.19+0x88>
  /* Insertion on prev.*/
  tp->queue.next             = cp;
  tp->queue.prev             = cp->queue.prev;
 80018f0:	685a      	ldr	r2, [r3, #4]

  /* Placing in ready list ahead of peers.*/
  otp = chSchReadyAheadI(otp);

  /* Swap operation as tail call.*/
  chSysSwitch(currp, otp);
 80018f2:	4629      	mov	r1, r5
  cp = (thread_t *)&ch.rlist.queue;
  do {
    cp = cp->queue.next;
  } while (cp->prio > tp->prio);
  /* Insertion on prev.*/
  tp->queue.next             = cp;
 80018f4:	602b      	str	r3, [r5, #0]
  tp->queue.prev             = cp->queue.prev;
 80018f6:	606a      	str	r2, [r5, #4]
  tp->queue.prev->queue.next = tp;
 80018f8:	6015      	str	r5, [r2, #0]
  cp->queue.prev             = tp;
 80018fa:	605d      	str	r5, [r3, #4]

  /* Placing in ready list ahead of peers.*/
  otp = chSchReadyAheadI(otp);

  /* Swap operation as tail call.*/
  chSysSwitch(currp, otp);
 80018fc:	f7fe fcaa 	bl	8000254 <_port_switch>
 8001900:	2300      	movs	r3, #0
 8001902:	f383 8811 	msr	BASEPRI, r3
 8001906:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
      chSchRescheduleS();
    }
    else {
      mp->owner = NULL;
 8001908:	2300      	movs	r3, #0
 800190a:	6163      	str	r3, [r4, #20]
 800190c:	2300      	movs	r3, #0
 800190e:	f383 8811 	msr	BASEPRI, r3
 8001912:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
 8001914:	f3af 8000 	nop.w
 8001918:	f3af 8000 	nop.w
 800191c:	f3af 8000 	nop.w

08001920 <long_to_string_with_divisor.11713.4304>:
#define FLOAT_PRECISION 9

static char *long_to_string_with_divisor(char *p,
                                         long num,
                                         unsigned radix,
                                         long divisor) {
 8001920:	b4f0      	push	{r4, r5, r6, r7}
  char *q;
  long l, ll;

  l = num;
  if (divisor == 0) {
    ll = num;
 8001922:	2b00      	cmp	r3, #0
 8001924:	bf08      	it	eq
 8001926:	460b      	moveq	r3, r1
  } else {
    ll = divisor;
  }

  q = p + MAX_FILLER;
 8001928:	f100 070b 	add.w	r7, r0, #11
 800192c:	f100 050a 	add.w	r5, r0, #10
  do {
    i = (int)(l % radix);
 8001930:	fbb1 f6f2 	udiv	r6, r1, r2
 8001934:	fb02 1116 	mls	r1, r2, r6, r1
    i += '0';
 8001938:	f101 0430 	add.w	r4, r1, #48	; 0x30
    if (i > '9')
 800193c:	2c39      	cmp	r4, #57	; 0x39
      i += 'A' - '0' - 10;
 800193e:	bfc8      	it	gt
 8001940:	f101 0437 	addgt.w	r4, r1, #55	; 0x37
    *--q = i;
 8001944:	b2e4      	uxtb	r4, r4
    l /= radix;
  } while ((ll /= radix) != 0);
 8001946:	fbb3 f3f2 	udiv	r3, r3, r2
    i = (int)(l % radix);
    i += '0';
    if (i > '9')
      i += 'A' - '0' - 10;
    *--q = i;
    l /= radix;
 800194a:	4631      	mov	r1, r6
  do {
    i = (int)(l % radix);
    i += '0';
    if (i > '9')
      i += 'A' - '0' - 10;
    *--q = i;
 800194c:	462e      	mov	r6, r5
 800194e:	f805 4901 	strb.w	r4, [r5], #-1
    l /= radix;
  } while ((ll /= radix) != 0);
 8001952:	2b00      	cmp	r3, #0
 8001954:	d1ec      	bne.n	8001930 <long_to_string_with_divisor.11713.4304+0x10>

  i = (int)(p + MAX_FILLER - q);
 8001956:	1bba      	subs	r2, r7, r6
 8001958:	4633      	mov	r3, r6
 800195a:	4402      	add	r2, r0
 800195c:	e001      	b.n	8001962 <long_to_string_with_divisor.11713.4304+0x42>
 800195e:	f813 4f01 	ldrb.w	r4, [r3, #1]!
  do
    *p++ = *q++;
 8001962:	f800 4b01 	strb.w	r4, [r0], #1
  while (--i);
 8001966:	4290      	cmp	r0, r2
 8001968:	d1f9      	bne.n	800195e <long_to_string_with_divisor.11713.4304+0x3e>

  return p;
}
 800196a:	bcf0      	pop	{r4, r5, r6, r7}
 800196c:	4770      	bx	lr
 800196e:	bf00      	nop

08001970 <notify3.8706>:

#if STM32_SERIAL_USE_USART3 || defined(__DOXYGEN__)
static void notify3(io_queue_t *qp) {

  (void)qp;
  USART3->CR1 |= USART_CR1_TXEIE;
 8001970:	f44f 4390 	mov.w	r3, #18432	; 0x4800
 8001974:	f2c4 0300 	movt	r3, #16384	; 0x4000
 8001978:	68da      	ldr	r2, [r3, #12]
 800197a:	f042 0280 	orr.w	r2, r2, #128	; 0x80
 800197e:	60da      	str	r2, [r3, #12]
 8001980:	4770      	bx	lr
 8001982:	bf00      	nop
 8001984:	f3af 8000 	nop.w
 8001988:	f3af 8000 	nop.w
 800198c:	f3af 8000 	nop.w

08001990 <notify2.8709>:

#if STM32_SERIAL_USE_USART2 || defined(__DOXYGEN__)
static void notify2(io_queue_t *qp) {

  (void)qp;
  USART2->CR1 |= USART_CR1_TXEIE;
 8001990:	f44f 4388 	mov.w	r3, #17408	; 0x4400
 8001994:	f2c4 0300 	movt	r3, #16384	; 0x4000
 8001998:	68da      	ldr	r2, [r3, #12]
 800199a:	f042 0280 	orr.w	r2, r2, #128	; 0x80
 800199e:	60da      	str	r2, [r3, #12]
 80019a0:	4770      	bx	lr
 80019a2:	bf00      	nop
 80019a4:	f3af 8000 	nop.w
 80019a8:	f3af 8000 	nop.w
 80019ac:	f3af 8000 	nop.w

080019b0 <SVC_Handler>:
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE uint32_t __get_PSP(void)
{
  register uint32_t result;

  __ASM volatile ("MRS %0, psp\n"  : "=r" (result) );
 80019b0:	f3ef 8309 	mrs	r3, PSP
  /* The port_extctx structure is pointed by the PSP register.*/
  ctxp = (struct port_extctx *)__get_PSP();

  /* Discarding the current exception context and positioning the stack to
     point to the real one.*/
  ctxp++;
 80019b4:	3320      	adds	r3, #32
  \details Assigns the given value to the Process Stack Pointer (PSP).
  \param [in]    topOfProcStack  Process Stack Pointer value to set
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __set_PSP(uint32_t topOfProcStack)
{
  __ASM volatile ("MSR psp, %0\n" : : "r" (topOfProcStack) : "sp");
 80019b6:	f383 8809 	msr	PSP, r3
  \details Assigns the given value to the Base Priority register.
  \param [in]    basePri  Base Priority value to set
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __set_BASEPRI(uint32_t value)
{
  __ASM volatile ("MSR basepri, %0" : : "r" (value) : "memory");
 80019ba:	2300      	movs	r3, #0
 80019bc:	f383 8811 	msr	BASEPRI, r3
 80019c0:	4770      	bx	lr
 80019c2:	bf00      	nop
 80019c4:	f3af 8000 	nop.w
 80019c8:	f3af 8000 	nop.w
 80019cc:	f3af 8000 	nop.w

080019d0 <chCoreAllocAlignedWithOffset>:
 *
 * @api
 */
void *chCoreAllocAlignedWithOffset(size_t size,
                                   unsigned align,
                                   size_t offset) {
 80019d0:	b430      	push	{r4, r5}
 80019d2:	2320      	movs	r3, #32
 80019d4:	f383 8811 	msr	BASEPRI, r3

  chDbgCheckClassI();
  chDbgCheck(MEM_IS_VALID_ALIGNMENT(align));

  size = MEM_ALIGN_NEXT(size, align);
  p = (uint8_t *)MEM_ALIGN_NEXT(ch_memcore.nextmem + offset, align);
 80019d8:	f640 1348 	movw	r3, #2376	; 0x948
 80019dc:	f2c2 0300 	movt	r3, #8192	; 0x2000
 80019e0:	681d      	ldr	r5, [r3, #0]
  uint8_t *p, *next;

  chDbgCheckClassI();
  chDbgCheck(MEM_IS_VALID_ALIGNMENT(align));

  size = MEM_ALIGN_NEXT(size, align);
 80019e2:	1e4c      	subs	r4, r1, #1
  p = (uint8_t *)MEM_ALIGN_NEXT(ch_memcore.nextmem + offset, align);
 80019e4:	442a      	add	r2, r5
 80019e6:	4422      	add	r2, r4
  uint8_t *p, *next;

  chDbgCheckClassI();
  chDbgCheck(MEM_IS_VALID_ALIGNMENT(align));

  size = MEM_ALIGN_NEXT(size, align);
 80019e8:	4249      	negs	r1, r1
 80019ea:	4404      	add	r4, r0
  p = (uint8_t *)MEM_ALIGN_NEXT(ch_memcore.nextmem + offset, align);
 80019ec:	ea02 0001 	and.w	r0, r2, r1
  uint8_t *p, *next;

  chDbgCheckClassI();
  chDbgCheck(MEM_IS_VALID_ALIGNMENT(align));

  size = MEM_ALIGN_NEXT(size, align);
 80019f0:	4021      	ands	r1, r4
  p = (uint8_t *)MEM_ALIGN_NEXT(ch_memcore.nextmem + offset, align);
  next = p + size;

  /* Considering also the case where there is numeric overflow.*/
  if ((next > ch_memcore.endmem) || (next < ch_memcore.nextmem)) {
 80019f2:	685a      	ldr	r2, [r3, #4]
  chDbgCheckClassI();
  chDbgCheck(MEM_IS_VALID_ALIGNMENT(align));

  size = MEM_ALIGN_NEXT(size, align);
  p = (uint8_t *)MEM_ALIGN_NEXT(ch_memcore.nextmem + offset, align);
  next = p + size;
 80019f4:	4401      	add	r1, r0

  /* Considering also the case where there is numeric overflow.*/
  if ((next > ch_memcore.endmem) || (next < ch_memcore.nextmem)) {
 80019f6:	4291      	cmp	r1, r2
 80019f8:	d807      	bhi.n	8001a0a <chCoreAllocAlignedWithOffset+0x3a>
 80019fa:	428d      	cmp	r5, r1
 80019fc:	d805      	bhi.n	8001a0a <chCoreAllocAlignedWithOffset+0x3a>
    return NULL;
  }

  ch_memcore.nextmem = next;
 80019fe:	6019      	str	r1, [r3, #0]
 8001a00:	2300      	movs	r3, #0
 8001a02:	f383 8811 	msr	BASEPRI, r3
  chSysLock();
  p = chCoreAllocAlignedWithOffsetI(size, align, offset);
  chSysUnlock();

  return p;
}
 8001a06:	bc30      	pop	{r4, r5}
 8001a08:	4770      	bx	lr
  p = (uint8_t *)MEM_ALIGN_NEXT(ch_memcore.nextmem + offset, align);
  next = p + size;

  /* Considering also the case where there is numeric overflow.*/
  if ((next > ch_memcore.endmem) || (next < ch_memcore.nextmem)) {
    return NULL;
 8001a0a:	2000      	movs	r0, #0
 8001a0c:	2300      	movs	r3, #0
 8001a0e:	f383 8811 	msr	BASEPRI, r3
  chSysLock();
  p = chCoreAllocAlignedWithOffsetI(size, align, offset);
  chSysUnlock();

  return p;
}
 8001a12:	bc30      	pop	{r4, r5}
 8001a14:	4770      	bx	lr
 8001a16:	bf00      	nop
 8001a18:	f3af 8000 	nop.w
 8001a1c:	f3af 8000 	nop.w

08001a20 <wakeup.4656>:
}

/*
 * Timeout wakeup callback.
 */
static void wakeup(void *p) {
 8001a20:	b410      	push	{r4}
 8001a22:	2320      	movs	r3, #32
 8001a24:	f383 8811 	msr	BASEPRI, r3
  thread_t *tp = (thread_t *)p;

  chSysLockFromISR();
  switch (tp->state) {
 8001a28:	f890 3020 	ldrb.w	r3, [r0, #32]
 8001a2c:	2b07      	cmp	r3, #7
 8001a2e:	d80e      	bhi.n	8001a4e <wakeup.4656+0x2e>
 8001a30:	e8df f003 	tbb	[pc, r3]
 8001a34:	270d0d2b 	.word	0x270d0d2b
 8001a38:	080d0408 	.word	0x080d0408
  case CH_STATE_SUSPENDED:
    *tp->u.wttrp = NULL;
    break;
#if CH_CFG_USE_SEMAPHORES == TRUE
  case CH_STATE_WTSEM:
    chSemFastSignalI(tp->u.wtsemp);
 8001a3c:	6a43      	ldr	r3, [r0, #36]	; 0x24
 */
static inline void chSemFastSignalI(semaphore_t *sp) {

  chDbgCheckClassI();

  sp->cnt++;
 8001a3e:	689a      	ldr	r2, [r3, #8]
 8001a40:	3201      	adds	r2, #1
 8001a42:	609a      	str	r2, [r3, #8]
  return tp;
}

static inline thread_t *queue_dequeue(thread_t *tp) {

  tp->queue.prev->queue.next = tp->queue.next;
 8001a44:	e890 000c 	ldmia.w	r0, {r2, r3}
 8001a48:	601a      	str	r2, [r3, #0]
  tp->queue.next->queue.prev = tp->queue.prev;
 8001a4a:	6802      	ldr	r2, [r0, #0]
 8001a4c:	6053      	str	r3, [r2, #4]
    break;
  default:
    /* Any other state, nothing to do.*/
    break;
  }
  tp->u.rdymsg = MSG_TIMEOUT;
 8001a4e:	f04f 34ff 	mov.w	r4, #4294967295
  chDbgCheck(tp != NULL);
  chDbgAssert((tp->state != CH_STATE_READY) &&
              (tp->state != CH_STATE_FINAL),
              "invalid state");

  tp->state = CH_STATE_READY;
 8001a52:	2200      	movs	r2, #0
  cp = (thread_t *)&ch.rlist.queue;
 8001a54:	f640 03d8 	movw	r3, #2264	; 0x8d8
 8001a58:	6881      	ldr	r1, [r0, #8]
    break;
  default:
    /* Any other state, nothing to do.*/
    break;
  }
  tp->u.rdymsg = MSG_TIMEOUT;
 8001a5a:	6244      	str	r4, [r0, #36]	; 0x24
  chDbgCheck(tp != NULL);
  chDbgAssert((tp->state != CH_STATE_READY) &&
              (tp->state != CH_STATE_FINAL),
              "invalid state");

  tp->state = CH_STATE_READY;
 8001a5c:	f880 2020 	strb.w	r2, [r0, #32]
  cp = (thread_t *)&ch.rlist.queue;
 8001a60:	f2c2 0300 	movt	r3, #8192	; 0x2000
  do {
    cp = cp->queue.next;
 8001a64:	681b      	ldr	r3, [r3, #0]
  } while (cp->prio >= tp->prio);
 8001a66:	689a      	ldr	r2, [r3, #8]
 8001a68:	428a      	cmp	r2, r1
 8001a6a:	d2fb      	bcs.n	8001a64 <wakeup.4656+0x44>
  /* Insertion on prev.*/
  tp->queue.next             = cp;
  tp->queue.prev             = cp->queue.prev;
 8001a6c:	685a      	ldr	r2, [r3, #4]
 8001a6e:	2100      	movs	r1, #0
  cp = (thread_t *)&ch.rlist.queue;
  do {
    cp = cp->queue.next;
  } while (cp->prio >= tp->prio);
  /* Insertion on prev.*/
  tp->queue.next             = cp;
 8001a70:	6003      	str	r3, [r0, #0]
  tp->queue.prev             = cp->queue.prev;
 8001a72:	6042      	str	r2, [r0, #4]
  tp->queue.prev->queue.next = tp;
 8001a74:	6010      	str	r0, [r2, #0]
  cp->queue.prev             = tp;
 8001a76:	6058      	str	r0, [r3, #4]
 8001a78:	f381 8811 	msr	BASEPRI, r1
    break;
  }
  tp->u.rdymsg = MSG_TIMEOUT;
  (void) chSchReadyI(tp);
  chSysUnlockFromISR();
}
 8001a7c:	f85d 4b04 	ldr.w	r4, [sp], #4
 8001a80:	4770      	bx	lr
    /* Handling the special case where the thread has been made ready by
       another thread with higher priority.*/
    chSysUnlockFromISR();
    return;
  case CH_STATE_SUSPENDED:
    *tp->u.wttrp = NULL;
 8001a82:	6a43      	ldr	r3, [r0, #36]	; 0x24
 8001a84:	2200      	movs	r2, #0
 8001a86:	601a      	str	r2, [r3, #0]
 8001a88:	e7e1      	b.n	8001a4e <wakeup.4656+0x2e>
 8001a8a:	2300      	movs	r3, #0
 8001a8c:	f383 8811 	msr	BASEPRI, r3
    break;
  }
  tp->u.rdymsg = MSG_TIMEOUT;
  (void) chSchReadyI(tp);
  chSysUnlockFromISR();
}
 8001a90:	f85d 4b04 	ldr.w	r4, [sp], #4
 8001a94:	4770      	bx	lr
 8001a96:	bf00      	nop
 8001a98:	f3af 8000 	nop.w
 8001a9c:	f3af 8000 	nop.w

08001aa0 <_idle_thread.4305>:
 *          that this thread is executed only if there are no other ready
 *          threads in the system.
 *
 * @param[in] p         the thread parameter, unused in this scenario
 */
static void _idle_thread(void *p) {
 8001aa0:	e7fe      	b.n	8001aa0 <_idle_thread.4305>
 8001aa2:	bf00      	nop
 8001aa4:	f3af 8000 	nop.w
 8001aa8:	f3af 8000 	nop.w
 8001aac:	f3af 8000 	nop.w

08001ab0 <sdObjectInit.constprop.16>:
 * @init
 */
#if !defined(SERIAL_ADVANCED_BUFFERING_SUPPORT) ||                          \
    (SERIAL_ADVANCED_BUFFERING_SUPPORT == FALSE) ||                         \
    defined(__DOXYGEN__)
void sdObjectInit(SerialDriver *sdp, qnotify_t inotify, qnotify_t onotify) {
 8001ab0:	e92d 03f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9}

  sdp->vmt = &vmt;
 8001ab4:	f642 5348 	movw	r3, #11592	; 0x2d48
 8001ab8:	4604      	mov	r4, r0
 8001aba:	f6c0 0300 	movt	r3, #2048	; 0x800
 8001abe:	f844 3b04 	str.w	r3, [r4], #4
 */
void iqObjectInit(input_queue_t *iqp, uint8_t *bp, size_t size,
                  qnotify_t infy, void *link) {

  osalThreadQueueObjectInit(&iqp->q_waiting);
  iqp->q_counter = 0;
 8001ac2:	2700      	movs	r7, #0
  iqp->q_buffer  = bp;
  iqp->q_rdptr   = bp;
  iqp->q_wrptr   = bp;
  iqp->q_top     = bp + size;
 8001ac4:	f100 0364 	add.w	r3, r0, #100	; 0x64
  osalEventObjectInit(&sdp->event);
  sdp->state = SD_STOP;
  iqObjectInit(&sdp->iqueue, sdp->ib, SERIAL_BUFFERS_SIZE, inotify, sdp);
 8001ac8:	f100 0254 	add.w	r2, r0, #84	; 0x54
 * @init
 */
void iqObjectInit(input_queue_t *iqp, uint8_t *bp, size_t size,
                  qnotify_t infy, void *link) {

  osalThreadQueueObjectInit(&iqp->q_waiting);
 8001acc:	f100 060c 	add.w	r6, r0, #12
 * @init
 */
void oqObjectInit(output_queue_t *oqp, uint8_t *bp, size_t size,
                  qnotify_t onfy, void *link) {

  osalThreadQueueObjectInit(&oqp->q_waiting);
 8001ad0:	f100 0530 	add.w	r5, r0, #48	; 0x30
    defined(__DOXYGEN__)
void sdObjectInit(SerialDriver *sdp, qnotify_t inotify, qnotify_t onotify) {

  sdp->vmt = &vmt;
  osalEventObjectInit(&sdp->event);
  sdp->state = SD_STOP;
 8001ad4:	f04f 0901 	mov.w	r9, #1
  oqp->q_counter = size;
 8001ad8:	f04f 0810 	mov.w	r8, #16
  oqp->q_buffer  = bp;
  oqp->q_rdptr   = bp;
  oqp->q_wrptr   = bp;
  oqp->q_top     = bp + size;
 8001adc:	f100 0c74 	add.w	ip, r0, #116	; 0x74
 */
void iqObjectInit(input_queue_t *iqp, uint8_t *bp, size_t size,
                  qnotify_t infy, void *link) {

  osalThreadQueueObjectInit(&iqp->q_waiting);
  iqp->q_counter = 0;
 8001ae0:	6147      	str	r7, [r0, #20]
 *
 * @init
 */
static inline void chEvtObjectInit(event_source_t *esp) {

  esp->next = (event_listener_t *)esp;
 8001ae2:	6044      	str	r4, [r0, #4]
 8001ae4:	f880 9008 	strb.w	r9, [r0, #8]
  iqp->q_buffer  = bp;
  iqp->q_rdptr   = bp;
  iqp->q_wrptr   = bp;
  iqp->q_top     = bp + size;
  iqp->q_notify  = infy;
 8001ae8:	6287      	str	r7, [r0, #40]	; 0x28
 */
void oqObjectInit(output_queue_t *oqp, uint8_t *bp, size_t size,
                  qnotify_t onfy, void *link) {

  osalThreadQueueObjectInit(&oqp->q_waiting);
  oqp->q_counter = size;
 8001aea:	f8c0 8038 	str.w	r8, [r0, #56]	; 0x38
 *
 * @notapi
 */
static inline void queue_init(threads_queue_t *tqp) {

  tqp->next = (thread_t *)tqp;
 8001aee:	60c6      	str	r6, [r0, #12]
  tqp->prev = (thread_t *)tqp;
 8001af0:	6106      	str	r6, [r0, #16]
 *
 * @notapi
 */
static inline void queue_init(threads_queue_t *tqp) {

  tqp->next = (thread_t *)tqp;
 8001af2:	6305      	str	r5, [r0, #48]	; 0x30
  tqp->prev = (thread_t *)tqp;
 8001af4:	6345      	str	r5, [r0, #52]	; 0x34
  iqp->q_buffer  = bp;
  iqp->q_rdptr   = bp;
  iqp->q_wrptr   = bp;
  iqp->q_top     = bp + size;
  iqp->q_notify  = infy;
  iqp->q_link    = link;
 8001af6:	62c0      	str	r0, [r0, #44]	; 0x2c
  oqp->q_counter = size;
  oqp->q_buffer  = bp;
  oqp->q_rdptr   = bp;
  oqp->q_wrptr   = bp;
  oqp->q_top     = bp + size;
  oqp->q_notify  = onfy;
 8001af8:	64c1      	str	r1, [r0, #76]	; 0x4c
  oqp->q_link    = link;
 8001afa:	6500      	str	r0, [r0, #80]	; 0x50
  osalThreadQueueObjectInit(&oqp->q_waiting);
  oqp->q_counter = size;
  oqp->q_buffer  = bp;
  oqp->q_rdptr   = bp;
  oqp->q_wrptr   = bp;
  oqp->q_top     = bp + size;
 8001afc:	f8c0 c040 	str.w	ip, [r0, #64]	; 0x40
void iqObjectInit(input_queue_t *iqp, uint8_t *bp, size_t size,
                  qnotify_t infy, void *link) {

  osalThreadQueueObjectInit(&iqp->q_waiting);
  iqp->q_counter = 0;
  iqp->q_buffer  = bp;
 8001b00:	6182      	str	r2, [r0, #24]
  iqp->q_rdptr   = bp;
 8001b02:	6242      	str	r2, [r0, #36]	; 0x24
  iqp->q_wrptr   = bp;
 8001b04:	6202      	str	r2, [r0, #32]
  iqp->q_top     = bp + size;
 8001b06:	61c3      	str	r3, [r0, #28]
void oqObjectInit(output_queue_t *oqp, uint8_t *bp, size_t size,
                  qnotify_t onfy, void *link) {

  osalThreadQueueObjectInit(&oqp->q_waiting);
  oqp->q_counter = size;
  oqp->q_buffer  = bp;
 8001b08:	63c3      	str	r3, [r0, #60]	; 0x3c
  oqp->q_rdptr   = bp;
 8001b0a:	6483      	str	r3, [r0, #72]	; 0x48
  oqp->q_wrptr   = bp;
 8001b0c:	6443      	str	r3, [r0, #68]	; 0x44
  iqObjectInit(&sdp->iqueue, sdp->ib, SERIAL_BUFFERS_SIZE, inotify, sdp);
  oqObjectInit(&sdp->oqueue, sdp->ob, SERIAL_BUFFERS_SIZE, onotify, sdp);
}
 8001b0e:	e8bd 03f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9}
 8001b12:	4770      	bx	lr
 8001b14:	f3af 8000 	nop.w
 8001b18:	f3af 8000 	nop.w
 8001b1c:	f3af 8000 	nop.w

08001b20 <dmaStreamAllocate.constprop.13>:
 * @retval false        no error, stream taken.
 * @retval true         error, stream already taken.
 *
 * @special
 */
bool dmaStreamAllocate(const stm32_dma_stream_t *dmastp,
 8001b20:	b4f0      	push	{r4, r5, r6, r7}
                       void *param) {

  osalDbgCheck(dmastp != NULL);

  /* Checks if the stream is already taken.*/
  if ((dma_streams_mask & (1U << dmastp->selfindex)) != 0U)
 8001b22:	7c45      	ldrb	r5, [r0, #17]
 8001b24:	2601      	movs	r6, #1
 8001b26:	fa06 f705 	lsl.w	r7, r6, r5
 8001b2a:	f640 03cc 	movw	r3, #2252	; 0x8cc
 8001b2e:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8001b32:	681c      	ldr	r4, [r3, #0]
 8001b34:	4227      	tst	r7, r4
    return true;
 8001b36:	bf18      	it	ne
 8001b38:	4630      	movne	r0, r6
                       void *param) {

  osalDbgCheck(dmastp != NULL);

  /* Checks if the stream is already taken.*/
  if ((dma_streams_mask & (1U << dmastp->selfindex)) != 0U)
 8001b3a:	d143      	bne.n	8001bc4 <dmaStreamAllocate.constprop.13+0xa4>
    return true;

  /* Installs the DMA handler.*/
  _stm32_dma_isr_redir[dmastp->selfindex].dma_func  = func;
 8001b3c:	f640 0618 	movw	r6, #2072	; 0x818
 8001b40:	f2c2 0600 	movt	r6, #8192	; 0x2000
  _stm32_dma_isr_redir[dmastp->selfindex].dma_param = param;
 8001b44:	eb06 07c5 	add.w	r7, r6, r5, lsl #3
  /* Checks if the stream is already taken.*/
  if ((dma_streams_mask & (1U << dmastp->selfindex)) != 0U)
    return true;

  /* Installs the DMA handler.*/
  _stm32_dma_isr_redir[dmastp->selfindex].dma_func  = func;
 8001b48:	f846 1035 	str.w	r1, [r6, r5, lsl #3]
  _stm32_dma_isr_redir[dmastp->selfindex].dma_param = param;
 8001b4c:	607a      	str	r2, [r7, #4]

  /* Enabling DMA clocks required by the current streams set.*/
  if ((dma_streams_mask & STM32_DMA1_STREAMS_MASK) == 0U) {
 8001b4e:	0662      	lsls	r2, r4, #25
    rccEnableDMA1(false);
 8001b50:	bf02      	ittt	eq
 8001b52:	f44f 5280 	moveq.w	r2, #4096	; 0x1000
 8001b56:	f2c4 0202 	movteq	r2, #16386	; 0x4002
 8001b5a:	6955      	ldreq	r5, [r2, #20]
    rccEnableDMA2(false);
  }
#endif

  /* Putting the stream in a safe state.*/
  dmaStreamDisable(dmastp);
 8001b5c:	6807      	ldr	r7, [r0, #0]
  _stm32_dma_isr_redir[dmastp->selfindex].dma_func  = func;
  _stm32_dma_isr_redir[dmastp->selfindex].dma_param = param;

  /* Enabling DMA clocks required by the current streams set.*/
  if ((dma_streams_mask & STM32_DMA1_STREAMS_MASK) == 0U) {
    rccEnableDMA1(false);
 8001b5e:	bf04      	itt	eq
 8001b60:	f045 0501 	orreq.w	r5, r5, #1
 8001b64:	6155      	streq	r5, [r2, #20]
    rccEnableDMA2(false);
  }
#endif

  /* Putting the stream in a safe state.*/
  dmaStreamDisable(dmastp);
 8001b66:	6842      	ldr	r2, [r0, #4]
 8001b68:	f04f 0c0e 	mov.w	ip, #14
 8001b6c:	6815      	ldr	r5, [r2, #0]
 8001b6e:	f025 050f 	bic.w	r5, r5, #15
 8001b72:	6015      	str	r5, [r2, #0]
 8001b74:	7c06      	ldrb	r6, [r0, #16]
  dmastp->channel->CCR = STM32_DMA_CCR_RESET_VALUE;

  /* Enables the associated IRQ vector if not alread enabled and if a
     callback is defined.*/
  if (((dma_streams_mask & dmastp->cmask) == 0U) &&
 8001b76:	6885      	ldr	r5, [r0, #8]
    rccEnableDMA2(false);
  }
#endif

  /* Putting the stream in a safe state.*/
  dmaStreamDisable(dmastp);
 8001b78:	fa0c fc06 	lsl.w	ip, ip, r6
  dmastp->channel->CCR = STM32_DMA_CCR_RESET_VALUE;

  /* Enables the associated IRQ vector if not alread enabled and if a
     callback is defined.*/
  if (((dma_streams_mask & dmastp->cmask) == 0U) &&
 8001b7c:	422c      	tst	r4, r5
  }
#endif

  /* Putting the stream in a safe state.*/
  dmaStreamDisable(dmastp);
  dmastp->channel->CCR = STM32_DMA_CCR_RESET_VALUE;
 8001b7e:	f04f 0600 	mov.w	r6, #0
    rccEnableDMA2(false);
  }
#endif

  /* Putting the stream in a safe state.*/
  dmaStreamDisable(dmastp);
 8001b82:	f8c7 c004 	str.w	ip, [r7, #4]
  dmastp->channel->CCR = STM32_DMA_CCR_RESET_VALUE;
 8001b86:	6016      	str	r6, [r2, #0]

  /* Enables the associated IRQ vector if not alread enabled and if a
     callback is defined.*/
  if (((dma_streams_mask & dmastp->cmask) == 0U) &&
 8001b88:	d115      	bne.n	8001bb6 <dmaStreamAllocate.constprop.13+0x96>
 8001b8a:	b1a1      	cbz	r1, 8001bb6 <dmaStreamAllocate.constprop.13+0x96>
      (func != NULL)) {
    nvicEnableVector(dmastp->vector, priority);
 8001b8c:	7c82      	ldrb	r2, [r0, #18]
  NVIC->IP[_IP_IDX(n)] = (NVIC->IP[_IP_IDX(n)] & ~(0xFFU << _BIT_SHIFT(n))) |
                         (NVIC_PRIORITY_MASK(prio) << _BIT_SHIFT(n));
#else
  NVIC->IP[n] = NVIC_PRIORITY_MASK(prio);
#endif
  NVIC->ICPR[n >> 5U] = 1U << (n & 0x1FU);
 8001b8e:	2501      	movs	r5, #1
 8001b90:	f002 011f 	and.w	r1, r2, #31
 8001b94:	408d      	lsls	r5, r1
 8001b96:	0951      	lsrs	r1, r2, #5
 8001b98:	0089      	lsls	r1, r1, #2
 8001b9a:	f101 4160 	add.w	r1, r1, #3758096384	; 0xe0000000

#if defined(__CORE_CM0_H_GENERIC)
  NVIC->IP[_IP_IDX(n)] = (NVIC->IP[_IP_IDX(n)] & ~(0xFFU << _BIT_SHIFT(n))) |
                         (NVIC_PRIORITY_MASK(prio) << _BIT_SHIFT(n));
#else
  NVIC->IP[n] = NVIC_PRIORITY_MASK(prio);
 8001b9e:	f102 4260 	add.w	r2, r2, #3758096384	; 0xe0000000
 8001ba2:	f501 4161 	add.w	r1, r1, #57600	; 0xe100
 8001ba6:	f502 4261 	add.w	r2, r2, #57600	; 0xe100
 8001baa:	2650      	movs	r6, #80	; 0x50
 8001bac:	f882 6300 	strb.w	r6, [r2, #768]	; 0x300
#endif
  NVIC->ICPR[n >> 5U] = 1U << (n & 0x1FU);
 8001bb0:	f8c1 5180 	str.w	r5, [r1, #384]	; 0x180
  NVIC->ISER[n >> 5U] = 1U << (n & 0x1FU);
 8001bb4:	600d      	str	r5, [r1, #0]
  }

  /* Marks the stream as allocated.*/
  dma_streams_mask |= (1U << dmastp->selfindex);
 8001bb6:	7c42      	ldrb	r2, [r0, #17]
 8001bb8:	2101      	movs	r1, #1
 8001bba:	fa01 f202 	lsl.w	r2, r1, r2
 8001bbe:	4314      	orrs	r4, r2
 8001bc0:	601c      	str	r4, [r3, #0]
 8001bc2:	2000      	movs	r0, #0

  return false;
}
 8001bc4:	bcf0      	pop	{r4, r5, r6, r7}
 8001bc6:	4770      	bx	lr
 8001bc8:	f3af 8000 	nop.w
 8001bcc:	f3af 8000 	nop.w

08001bd0 <_pal_lld_setgroupmode.constprop.4>:
  if (mode == PAL_MODE_INPUT_PULLUP)
    port->BSRR = mask;
  else if (mode == PAL_MODE_INPUT_PULLDOWN)
    port->BRR = mask;
  cfg = cfgtab[mode];
  mh = ml = crh = crl = 0;
 8001bd0:	2300      	movs	r3, #0
 * @param[in] mask      the group mask
 * @param[in] mode      the mode
 *
 * @notapi
 */
void _pal_lld_setgroupmode(ioportid_t port,
 8001bd2:	b430      	push	{r4, r5}
  if (mode == PAL_MODE_INPUT_PULLUP)
    port->BSRR = mask;
  else if (mode == PAL_MODE_INPUT_PULLDOWN)
    port->BRR = mask;
  cfg = cfgtab[mode];
  mh = ml = crh = crl = 0;
 8001bd4:	461a      	mov	r2, r3
 8001bd6:	461c      	mov	r4, r3
 8001bd8:	4619      	mov	r1, r3
 * @param[in] mask      the group mask
 * @param[in] mode      the mode
 *
 * @notapi
 */
void _pal_lld_setgroupmode(ioportid_t port,
 8001bda:	2508      	movs	r5, #8
  for (i = 0; i < 8; i++) {
    ml <<= 4;
    mh <<= 4;
    crl <<= 4;
    crh <<= 4;
    if ((mask & 0x0080) == 0)
 8001bdc:	f010 0f80 	tst.w	r0, #128	; 0x80
  else if (mode == PAL_MODE_INPUT_PULLDOWN)
    port->BRR = mask;
  cfg = cfgtab[mode];
  mh = ml = crh = crl = 0;
  for (i = 0; i < 8; i++) {
    ml <<= 4;
 8001be0:	ea4f 1101 	mov.w	r1, r1, lsl #4
    mh <<= 4;
    crl <<= 4;
 8001be4:	ea4f 1202 	mov.w	r2, r2, lsl #4
    port->BRR = mask;
  cfg = cfgtab[mode];
  mh = ml = crh = crl = 0;
  for (i = 0; i < 8; i++) {
    ml <<= 4;
    mh <<= 4;
 8001be8:	ea4f 1404 	mov.w	r4, r4, lsl #4
    crl <<= 4;
    crh <<= 4;
 8001bec:	ea4f 1303 	mov.w	r3, r3, lsl #4
    if ((mask & 0x0080) == 0)
      ml |= 0xf;
 8001bf0:	bf0c      	ite	eq
 8001bf2:	f041 010f 	orreq.w	r1, r1, #15
    else
      crl |= cfg;
 8001bf6:	f042 020f 	orrne.w	r2, r2, #15
    if ((mask & 0x8000) == 0)
 8001bfa:	f410 4f00 	tst.w	r0, #32768	; 0x8000
      mh |= 0xf;
 8001bfe:	bf0c      	ite	eq
 8001c00:	f044 040f 	orreq.w	r4, r4, #15
    else
      crh |= cfg;
 8001c04:	f043 030f 	orrne.w	r3, r3, #15
    port->BSRR = mask;
  else if (mode == PAL_MODE_INPUT_PULLDOWN)
    port->BRR = mask;
  cfg = cfgtab[mode];
  mh = ml = crh = crl = 0;
  for (i = 0; i < 8; i++) {
 8001c08:	3d01      	subs	r5, #1
      crl |= cfg;
    if ((mask & 0x8000) == 0)
      mh |= 0xf;
    else
      crh |= cfg;
    mask <<= 1;
 8001c0a:	ea4f 0040 	mov.w	r0, r0, lsl #1
    port->BSRR = mask;
  else if (mode == PAL_MODE_INPUT_PULLDOWN)
    port->BRR = mask;
  cfg = cfgtab[mode];
  mh = ml = crh = crl = 0;
  for (i = 0; i < 8; i++) {
 8001c0e:	d1e5      	bne.n	8001bdc <_pal_lld_setgroupmode.constprop.4+0xc>
      mh |= 0xf;
    else
      crh |= cfg;
    mask <<= 1;
  }
  port->CRH = (port->CRH & mh) | crh;
 8001c10:	f44f 6040 	mov.w	r0, #3072	; 0xc00
 8001c14:	f2c4 0001 	movt	r0, #16385	; 0x4001
 8001c18:	6845      	ldr	r5, [r0, #4]
 8001c1a:	402c      	ands	r4, r5
 8001c1c:	4323      	orrs	r3, r4
 8001c1e:	6043      	str	r3, [r0, #4]
  port->CRL = (port->CRL & ml) | crl;
 8001c20:	6803      	ldr	r3, [r0, #0]
}
 8001c22:	bc30      	pop	{r4, r5}
    else
      crh |= cfg;
    mask <<= 1;
  }
  port->CRH = (port->CRH & mh) | crh;
  port->CRL = (port->CRL & ml) | crl;
 8001c24:	4019      	ands	r1, r3
 8001c26:	430a      	orrs	r2, r1
 8001c28:	6002      	str	r2, [r0, #0]
}
 8001c2a:	4770      	bx	lr
 8001c2c:	f3af 8000 	nop.w

08001c30 <chprintf.constprop.0>:
 * @param[in] chp       pointer to a @p BaseSequentialStream implementing object
 * @param[in] fmt       formatting string
 *
 * @api
 */
int chprintf(BaseSequentialStream *chp, const char *fmt, ...) {
 8001c30:	b40e      	push	{r1, r2, r3}
 8001c32:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 8001c36:	b092      	sub	sp, #72	; 0x48
 8001c38:	ac0c      	add	r4, sp, #48	; 0x30
 8001c3a:	9403      	str	r4, [sp, #12]
 8001c3c:	9c03      	ldr	r4, [sp, #12]
 8001c3e:	f10d 0c31 	add.w	ip, sp, #49	; 0x31
 8001c42:	ab1b      	add	r3, sp, #108	; 0x6c
 8001c44:	f8cd c008 	str.w	ip, [sp, #8]
 8001c48:	ebc4 0c0c 	rsb	ip, r4, ip
 8001c4c:	f853 6b04 	ldr.w	r6, [r3], #4
 8001c50:	f8cd c01c 	str.w	ip, [sp, #28]
static char *ftoa(char *p, double num, unsigned long precision) {
  long l;

  if ((precision == 0) || (precision > FLOAT_PRECISION))
    precision = FLOAT_PRECISION;
  precision = pow10[precision - 1];
 8001c54:	f642 5c70 	movw	ip, #11632	; 0x2d70
 8001c58:	f640 0b50 	movw	fp, #2128	; 0x850
 8001c5c:	f6c0 0c00 	movt	ip, #2048	; 0x800
 * @api
 */
int chvprintf(BaseSequentialStream *chp, const char *fmt, va_list ap) {
  char *p, *s, c, filler;
  int i, precision, width;
  int n = 0;
 8001c60:	2400      	movs	r4, #0
 */
int chprintf(BaseSequentialStream *chp, const char *fmt, ...) {
  va_list ap;
  int formatted_bytes;

  va_start(ap, fmt);
 8001c62:	930b      	str	r3, [sp, #44]	; 0x2c
 8001c64:	469a      	mov	sl, r3
 8001c66:	f2c2 0b00 	movt	fp, #8192	; 0x2000
static char *ftoa(char *p, double num, unsigned long precision) {
  long l;

  if ((precision == 0) || (precision > FLOAT_PRECISION))
    precision = FLOAT_PRECISION;
  precision = pow10[precision - 1];
 8001c6a:	f8cd c018 	str.w	ip, [sp, #24]
 * @api
 */
int chvprintf(BaseSequentialStream *chp, const char *fmt, va_list ap) {
  char *p, *s, c, filler;
  int i, precision, width;
  int n = 0;
 8001c6e:	9404      	str	r4, [sp, #16]
#else
  char tmpbuf[MAX_FILLER + 1];
#endif

  while (true) {
    c = *fmt++;
 8001c70:	7831      	ldrb	r1, [r6, #0]
 8001c72:	1c73      	adds	r3, r6, #1
    if (c == 0)
 8001c74:	b1a1      	cbz	r1, 8001ca0 <chprintf.constprop.0+0x70>
      return n;
    if (c != '%') {
 8001c76:	2925      	cmp	r1, #37	; 0x25
 8001c78:	d018      	beq.n	8001cac <chprintf.constprop.0+0x7c>
      streamPut(chp, (uint8_t)c);
      n++;
 8001c7a:	f8dd c010 	ldr.w	ip, [sp, #16]
  while (true) {
    c = *fmt++;
    if (c == 0)
      return n;
    if (c != '%') {
      streamPut(chp, (uint8_t)c);
 8001c7e:	f8db 2000 	ldr.w	r2, [fp]
 8001c82:	f640 0050 	movw	r0, #2128	; 0x850
#else
  char tmpbuf[MAX_FILLER + 1];
#endif

  while (true) {
    c = *fmt++;
 8001c86:	461e      	mov	r6, r3
    if (c == 0)
      return n;
    if (c != '%') {
      streamPut(chp, (uint8_t)c);
      n++;
 8001c88:	f10c 0c01 	add.w	ip, ip, #1
  while (true) {
    c = *fmt++;
    if (c == 0)
      return n;
    if (c != '%') {
      streamPut(chp, (uint8_t)c);
 8001c8c:	6892      	ldr	r2, [r2, #8]
 8001c8e:	f2c2 0000 	movt	r0, #8192	; 0x2000
      n++;
 8001c92:	f8cd c010 	str.w	ip, [sp, #16]
  while (true) {
    c = *fmt++;
    if (c == 0)
      return n;
    if (c != '%') {
      streamPut(chp, (uint8_t)c);
 8001c96:	4790      	blx	r2
#else
  char tmpbuf[MAX_FILLER + 1];
#endif

  while (true) {
    c = *fmt++;
 8001c98:	7831      	ldrb	r1, [r6, #0]
 8001c9a:	1c73      	adds	r3, r6, #1
    if (c == 0)
 8001c9c:	2900      	cmp	r1, #0
 8001c9e:	d1ea      	bne.n	8001c76 <chprintf.constprop.0+0x46>
  va_start(ap, fmt);
  formatted_bytes = chvprintf(chp, fmt, ap);
  va_end(ap);

  return formatted_bytes;
}
 8001ca0:	9804      	ldr	r0, [sp, #16]
 8001ca2:	b012      	add	sp, #72	; 0x48
 8001ca4:	e8bd 4ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 8001ca8:	b003      	add	sp, #12
 8001caa:	4770      	bx	lr
      continue;
    }
    p = tmpbuf;
    s = tmpbuf;
    left_align = FALSE;
    if (*fmt == '-') {
 8001cac:	7872      	ldrb	r2, [r6, #1]
    filler = ' ';
    if (*fmt == '0') {
      fmt++;
      filler = '0';
    }
    width = 0;
 8001cae:	2400      	movs	r4, #0
      continue;
    }
    p = tmpbuf;
    s = tmpbuf;
    left_align = FALSE;
    if (*fmt == '-') {
 8001cb0:	2a2d      	cmp	r2, #45	; 0x2d
 8001cb2:	bf03      	ittte	eq
 8001cb4:	78b2      	ldrbeq	r2, [r6, #2]
      fmt++;
 8001cb6:	1cb3      	addeq	r3, r6, #2
      left_align = TRUE;
 8001cb8:	2701      	moveq	r7, #1
      n++;
      continue;
    }
    p = tmpbuf;
    s = tmpbuf;
    left_align = FALSE;
 8001cba:	2700      	movne	r7, #0
    if (*fmt == '-') {
      fmt++;
      left_align = TRUE;
    }
    filler = ' ';
    if (*fmt == '0') {
 8001cbc:	2a30      	cmp	r2, #48	; 0x30
 8001cbe:	bf03      	ittte	eq
 8001cc0:	785a      	ldrbeq	r2, [r3, #1]
      fmt++;
 8001cc2:	3301      	addeq	r3, #1
      filler = '0';
 8001cc4:	2530      	moveq	r5, #48	; 0x30
    left_align = FALSE;
    if (*fmt == '-') {
      fmt++;
      left_align = TRUE;
    }
    filler = ' ';
 8001cc6:	2520      	movne	r5, #32
    if (*fmt == '0') {
      fmt++;
      filler = '0';
 8001cc8:	461e      	mov	r6, r3
 8001cca:	e008      	b.n	8001cde <chprintf.constprop.0+0xae>
    while (TRUE) {
      c = *fmt++;
      if (c >= '0' && c <= '9')
        c -= '0';
      else if (c == '*')
        c = va_arg(ap, int);
 8001ccc:	f89a 3000 	ldrb.w	r3, [sl]
 8001cd0:	f10a 0a04 	add.w	sl, sl, #4
      else
        break;
      width = width * 10 + c;
 8001cd4:	eb04 0484 	add.w	r4, r4, r4, lsl #2
 8001cd8:	7832      	ldrb	r2, [r6, #0]
 8001cda:	eb03 0444 	add.w	r4, r3, r4, lsl #1
      filler = '0';
    }
    width = 0;
    while (TRUE) {
      c = *fmt++;
      if (c >= '0' && c <= '9')
 8001cde:	f1a2 0330 	sub.w	r3, r2, #48	; 0x30
 8001ce2:	b2db      	uxtb	r3, r3
 8001ce4:	2b09      	cmp	r3, #9
      fmt++;
      filler = '0';
    }
    width = 0;
    while (TRUE) {
      c = *fmt++;
 8001ce6:	f106 0601 	add.w	r6, r6, #1
      if (c >= '0' && c <= '9')
 8001cea:	d9f3      	bls.n	8001cd4 <chprintf.constprop.0+0xa4>
        c -= '0';
      else if (c == '*')
 8001cec:	2a2a      	cmp	r2, #42	; 0x2a
 8001cee:	d0ed      	beq.n	8001ccc <chprintf.constprop.0+0x9c>
      else
        break;
      width = width * 10 + c;
    }
    precision = 0;
    if (c == '.') {
 8001cf0:	2a2e      	cmp	r2, #46	; 0x2e
 8001cf2:	f04f 0300 	mov.w	r3, #0
 8001cf6:	d04b      	beq.n	8001d90 <chprintf.constprop.0+0x160>
        precision *= 10;
        precision += c;
      }
    }
    /* Long modifier.*/
    if (c == 'l' || c == 'L') {
 8001cf8:	f002 01df 	and.w	r1, r2, #223	; 0xdf
 8001cfc:	294c      	cmp	r1, #76	; 0x4c
 8001cfe:	d156      	bne.n	8001dae <chprintf.constprop.0+0x17e>
      is_long = TRUE;
      if (*fmt)
 8001d00:	7831      	ldrb	r1, [r6, #0]
        precision += c;
      }
    }
    /* Long modifier.*/
    if (c == 'l' || c == 'L') {
      is_long = TRUE;
 8001d02:	2001      	movs	r0, #1
      if (*fmt)
 8001d04:	b111      	cbz	r1, 8001d0c <chprintf.constprop.0+0xdc>
        c = *fmt++;
 8001d06:	3601      	adds	r6, #1
 8001d08:	460a      	mov	r2, r1
        precision += c;
      }
    }
    /* Long modifier.*/
    if (c == 'l' || c == 'L') {
      is_long = TRUE;
 8001d0a:	2001      	movs	r0, #1
    }
    else
      is_long = (c >= 'A') && (c <= 'Z');

    /* Command decoding.*/
    switch (c) {
 8001d0c:	f1a2 0144 	sub.w	r1, r2, #68	; 0x44
 8001d10:	2934      	cmp	r1, #52	; 0x34
 8001d12:	f200 8153 	bhi.w	8001fbc <chprintf.constprop.0+0x38c>
 8001d16:	e8df f011 	tbh	[pc, r1, lsl #1]
 8001d1a:	00b7      	.short	0x00b7
 8001d1c:	01510151 	.word	0x01510151
 8001d20:	01510151 	.word	0x01510151
 8001d24:	015100b7 	.word	0x015100b7
 8001d28:	01510151 	.word	0x01510151
 8001d2c:	01510151 	.word	0x01510151
 8001d30:	015100b5 	.word	0x015100b5
 8001d34:	01510151 	.word	0x01510151
 8001d38:	01510151 	.word	0x01510151
 8001d3c:	01510052 	.word	0x01510052
 8001d40:	014f0151 	.word	0x014f0151
 8001d44:	01510151 	.word	0x01510151
 8001d48:	01510151 	.word	0x01510151
 8001d4c:	01510151 	.word	0x01510151
 8001d50:	01510151 	.word	0x01510151
 8001d54:	01510151 	.word	0x01510151
 8001d58:	00b70142 	.word	0x00b70142
 8001d5c:	00ec0151 	.word	0x00ec0151
 8001d60:	01510151 	.word	0x01510151
 8001d64:	015100b7 	.word	0x015100b7
 8001d68:	01510151 	.word	0x01510151
 8001d6c:	01510151 	.word	0x01510151
 8001d70:	015100b5 	.word	0x015100b5
 8001d74:	01510151 	.word	0x01510151
 8001d78:	015100c7 	.word	0x015100c7
 8001d7c:	01510052 	.word	0x01510052
 8001d80:	014f0151 	.word	0x014f0151
      while (TRUE) {
        c = *fmt++;
        if (c >= '0' && c <= '9')
          c -= '0';
        else if (c == '*')
          c = va_arg(ap, int);
 8001d84:	f89a 1000 	ldrb.w	r1, [sl]
 8001d88:	f10a 0a04 	add.w	sl, sl, #4
        else
          break;
        precision *= 10;
        precision += c;
 8001d8c:	eb01 0340 	add.w	r3, r1, r0, lsl #1
      width = width * 10 + c;
    }
    precision = 0;
    if (c == '.') {
      while (TRUE) {
        c = *fmt++;
 8001d90:	f816 2b01 	ldrb.w	r2, [r6], #1
          c -= '0';
        else if (c == '*')
          c = va_arg(ap, int);
        else
          break;
        precision *= 10;
 8001d94:	eb03 0083 	add.w	r0, r3, r3, lsl #2
    }
    precision = 0;
    if (c == '.') {
      while (TRUE) {
        c = *fmt++;
        if (c >= '0' && c <= '9')
 8001d98:	f1a2 0130 	sub.w	r1, r2, #48	; 0x30
 8001d9c:	b2c9      	uxtb	r1, r1
 8001d9e:	2909      	cmp	r1, #9
 8001da0:	d9f4      	bls.n	8001d8c <chprintf.constprop.0+0x15c>
          c -= '0';
        else if (c == '*')
 8001da2:	2a2a      	cmp	r2, #42	; 0x2a
 8001da4:	d0ee      	beq.n	8001d84 <chprintf.constprop.0+0x154>
        precision *= 10;
        precision += c;
      }
    }
    /* Long modifier.*/
    if (c == 'l' || c == 'L') {
 8001da6:	f002 01df 	and.w	r1, r2, #223	; 0xdf
 8001daa:	294c      	cmp	r1, #76	; 0x4c
 8001dac:	d0a8      	beq.n	8001d00 <chprintf.constprop.0+0xd0>
      is_long = TRUE;
      if (*fmt)
        c = *fmt++;
    }
    else
      is_long = (c >= 'A') && (c <= 'Z');
 8001dae:	f1a2 0041 	sub.w	r0, r2, #65	; 0x41
 8001db2:	b2c0      	uxtb	r0, r0
 8001db4:	2819      	cmp	r0, #25
 8001db6:	bf8c      	ite	hi
 8001db8:	2000      	movhi	r0, #0
 8001dba:	2001      	movls	r0, #1
 8001dbc:	e7a6      	b.n	8001d0c <chprintf.constprop.0+0xdc>

    /* Command decoding.*/
    switch (c) {
 8001dbe:	220a      	movs	r2, #10
    case 'O':
    case 'o':
      c = 8;
unsigned_common:
      if (is_long)
        l = va_arg(ap, unsigned long);
 8001dc0:	f8da 1000 	ldr.w	r1, [sl]
  return p;
}

static char *ch_ltoa(char *p, long num, unsigned radix) {

  return long_to_string_with_divisor(p, num, radix, 0);
 8001dc4:	a80c      	add	r0, sp, #48	; 0x30
    case 'O':
    case 'o':
      c = 8;
unsigned_common:
      if (is_long)
        l = va_arg(ap, unsigned long);
 8001dc6:	f10a 0a04 	add.w	sl, sl, #4
  return p;
}

static char *ch_ltoa(char *p, long num, unsigned radix) {

  return long_to_string_with_divisor(p, num, radix, 0);
 8001dca:	2300      	movs	r3, #0
 8001dcc:	f7ff fda8 	bl	8001920 <long_to_string_with_divisor.11713.4304>
 8001dd0:	f8dd c00c 	ldr.w	ip, [sp, #12]
      streamPut(chp, (uint8_t)c);
      n++;
      continue;
    }
    p = tmpbuf;
    s = tmpbuf;
 8001dd4:	aa0c      	add	r2, sp, #48	; 0x30
 8001dd6:	ebcc 0000 	rsb	r0, ip, r0
 8001dda:	f100 39ff 	add.w	r9, r0, #4294967295
 8001dde:	9205      	str	r2, [sp, #20]
    default:
      *p++ = c;
      break;
    }
    i = (int)(p - s);
    if ((width -= i) < 0)
 8001de0:	1a24      	subs	r4, r4, r0
 8001de2:	ea24 74e4 	bic.w	r4, r4, r4, asr #31
      width = 0;
    if (left_align == FALSE)
 8001de6:	b9ff      	cbnz	r7, 8001e28 <chprintf.constprop.0+0x1f8>
      width = -width;
 8001de8:	4264      	negs	r4, r4
    if (width < 0) {
 8001dea:	b1ec      	cbz	r4, 8001e28 <chprintf.constprop.0+0x1f8>
      if (*s == '-' && filler == '0') {
 8001dec:	f8dd c014 	ldr.w	ip, [sp, #20]
        streamPut(chp, (uint8_t)*s++);
 8001df0:	f640 0850 	movw	r8, #2128	; 0x850
    if ((width -= i) < 0)
      width = 0;
    if (left_align == FALSE)
      width = -width;
    if (width < 0) {
      if (*s == '-' && filler == '0') {
 8001df4:	f89c 1000 	ldrb.w	r1, [ip]
 8001df8:	292d      	cmp	r1, #45	; 0x2d
 8001dfa:	f000 80e7 	beq.w	8001fcc <chprintf.constprop.0+0x39c>
 8001dfe:	f2c2 0800 	movt	r8, #8192	; 0x2000
    case 'c':
      filler = ' ';
      *p++ = va_arg(ap, int);
      break;
    case 's':
      filler = ' ';
 8001e02:	4627      	mov	r7, r4
        streamPut(chp, (uint8_t)*s++);
        n++;
        i--;
      }
      do {
        streamPut(chp, (uint8_t)filler);
 8001e04:	f8d8 3000 	ldr.w	r3, [r8]
 8001e08:	f640 0050 	movw	r0, #2128	; 0x850
 8001e0c:	689b      	ldr	r3, [r3, #8]
 8001e0e:	f2c2 0000 	movt	r0, #8192	; 0x2000
 8001e12:	4629      	mov	r1, r5
 8001e14:	4798      	blx	r3
        n++;
      } while (++width != 0);
 8001e16:	3701      	adds	r7, #1
 8001e18:	d1f4      	bne.n	8001e04 <chprintf.constprop.0+0x1d4>
 8001e1a:	f8dd c010 	ldr.w	ip, [sp, #16]
 8001e1e:	ebc4 0c0c 	rsb	ip, r4, ip
 8001e22:	f8cd c010 	str.w	ip, [sp, #16]
 8001e26:	463c      	mov	r4, r7
    }
    while (--i >= 0) {
 8001e28:	f1b9 0f00 	cmp.w	r9, #0
 8001e2c:	db15      	blt.n	8001e5a <chprintf.constprop.0+0x22a>
 8001e2e:	9a05      	ldr	r2, [sp, #20]
 8001e30:	4690      	mov	r8, r2
 8001e32:	1e57      	subs	r7, r2, #1
 8001e34:	44c8      	add	r8, r9
      streamPut(chp, (uint8_t)*s++);
 8001e36:	f8db 3000 	ldr.w	r3, [fp]
 8001e3a:	f817 1f01 	ldrb.w	r1, [r7, #1]!
 8001e3e:	f640 0050 	movw	r0, #2128	; 0x850
 8001e42:	689b      	ldr	r3, [r3, #8]
 8001e44:	f2c2 0000 	movt	r0, #8192	; 0x2000
 8001e48:	4798      	blx	r3
      do {
        streamPut(chp, (uint8_t)filler);
        n++;
      } while (++width != 0);
    }
    while (--i >= 0) {
 8001e4a:	4547      	cmp	r7, r8
 8001e4c:	d1f3      	bne.n	8001e36 <chprintf.constprop.0+0x206>
 8001e4e:	f8dd c010 	ldr.w	ip, [sp, #16]
 8001e52:	f10c 0301 	add.w	r3, ip, #1
 8001e56:	444b      	add	r3, r9
 8001e58:	9304      	str	r3, [sp, #16]
      streamPut(chp, (uint8_t)*s++);
      n++;
    }

    while (width) {
 8001e5a:	2c00      	cmp	r4, #0
 8001e5c:	f43f af08 	beq.w	8001c70 <chprintf.constprop.0+0x40>
 8001e60:	4627      	mov	r7, r4
      streamPut(chp, (uint8_t)filler);
 8001e62:	f8db 3000 	ldr.w	r3, [fp]
 8001e66:	f640 0050 	movw	r0, #2128	; 0x850
 8001e6a:	689b      	ldr	r3, [r3, #8]
 8001e6c:	f2c2 0000 	movt	r0, #8192	; 0x2000
 8001e70:	4629      	mov	r1, r5
 8001e72:	4798      	blx	r3
    while (--i >= 0) {
      streamPut(chp, (uint8_t)*s++);
      n++;
    }

    while (width) {
 8001e74:	3f01      	subs	r7, #1
 8001e76:	d1f4      	bne.n	8001e62 <chprintf.constprop.0+0x232>
 8001e78:	f8dd c010 	ldr.w	ip, [sp, #16]
 8001e7c:	44a4      	add	ip, r4
 8001e7e:	f8cd c010 	str.w	ip, [sp, #16]
 8001e82:	e6f5      	b.n	8001c70 <chprintf.constprop.0+0x40>
 8001e84:	2208      	movs	r2, #8
 8001e86:	e79b      	b.n	8001dc0 <chprintf.constprop.0+0x190>
    case 'D':
    case 'd':
    case 'I':
    case 'i':
      if (is_long)
        l = va_arg(ap, long);
 8001e88:	f8da 1000 	ldr.w	r1, [sl]
  return p;
}

static char *ch_ltoa(char *p, long num, unsigned radix) {

  return long_to_string_with_divisor(p, num, radix, 0);
 8001e8c:	220a      	movs	r2, #10
    case 'i':
      if (is_long)
        l = va_arg(ap, long);
      else
        l = va_arg(ap, int);
      if (l < 0) {
 8001e8e:	2900      	cmp	r1, #0
        *p++ = '-';
 8001e90:	bfb8      	it	lt
 8001e92:	232d      	movlt	r3, #45	; 0x2d
    case 'D':
    case 'd':
    case 'I':
    case 'i':
      if (is_long)
        l = va_arg(ap, long);
 8001e94:	f10a 0a04 	add.w	sl, sl, #4
      else
        l = va_arg(ap, int);
      if (l < 0) {
        *p++ = '-';
        l = -l;
 8001e98:	bfbd      	ittte	lt
 8001e9a:	4249      	neglt	r1, r1
      if (is_long)
        l = va_arg(ap, long);
      else
        l = va_arg(ap, int);
      if (l < 0) {
        *p++ = '-';
 8001e9c:	f88d 3030 	strblt.w	r3, [sp, #48]	; 0x30
 8001ea0:	f10d 0031 	addlt.w	r0, sp, #49	; 0x31
    if (c != '%') {
      streamPut(chp, (uint8_t)c);
      n++;
      continue;
    }
    p = tmpbuf;
 8001ea4:	a80c      	addge	r0, sp, #48	; 0x30
 8001ea6:	e790      	b.n	8001dca <chprintf.constprop.0+0x19a>
      filler = ' ';
      *p++ = va_arg(ap, int);
      break;
    case 's':
      filler = ' ';
      if ((s = va_arg(ap, char *)) == 0)
 8001ea8:	f8da 0000 	ldr.w	r0, [sl]
        s = "(null)";
 8001eac:	f642 5268 	movw	r2, #11624	; 0x2d68
 8001eb0:	f6c0 0200 	movt	r2, #2048	; 0x800
 8001eb4:	2800      	cmp	r0, #0
 8001eb6:	bf08      	it	eq
 8001eb8:	4610      	moveq	r0, r2
 8001eba:	9005      	str	r0, [sp, #20]
      if (precision == 0)
        precision = 32767;
      for (p = s; *p && (--precision >= 0); p++)
 8001ebc:	7800      	ldrb	r0, [r0, #0]
    case 's':
      filler = ' ';
      if ((s = va_arg(ap, char *)) == 0)
        s = "(null)";
      if (precision == 0)
        precision = 32767;
 8001ebe:	f647 72ff 	movw	r2, #32767	; 0x7fff
      filler = ' ';
      *p++ = va_arg(ap, int);
      break;
    case 's':
      filler = ' ';
      if ((s = va_arg(ap, char *)) == 0)
 8001ec2:	f10a 0a04 	add.w	sl, sl, #4
        s = "(null)";
      if (precision == 0)
        precision = 32767;
 8001ec6:	2b00      	cmp	r3, #0
 8001ec8:	bf08      	it	eq
 8001eca:	4613      	moveq	r3, r2
      for (p = s; *p && (--precision >= 0); p++)
 8001ecc:	2800      	cmp	r0, #0
 8001ece:	f000 80a1 	beq.w	8002014 <chprintf.constprop.0+0x3e4>
 8001ed2:	9a05      	ldr	r2, [sp, #20]
 8001ed4:	4413      	add	r3, r2
 8001ed6:	e002      	b.n	8001ede <chprintf.constprop.0+0x2ae>
 8001ed8:	4293      	cmp	r3, r2
 8001eda:	f000 808d 	beq.w	8001ff8 <chprintf.constprop.0+0x3c8>
 8001ede:	7851      	ldrb	r1, [r2, #1]
 8001ee0:	3201      	adds	r2, #1
 8001ee2:	2900      	cmp	r1, #0
 8001ee4:	d1f8      	bne.n	8001ed8 <chprintf.constprop.0+0x2a8>
 8001ee6:	9b05      	ldr	r3, [sp, #20]
    case 'c':
      filler = ' ';
      *p++ = va_arg(ap, int);
      break;
    case 's':
      filler = ' ';
 8001ee8:	2520      	movs	r5, #32
 8001eea:	1ad0      	subs	r0, r2, r3
 8001eec:	f100 39ff 	add.w	r9, r0, #4294967295
 8001ef0:	e776      	b.n	8001de0 <chprintf.constprop.0+0x1b0>
      }
      p = ch_ltoa(p, l, 10);
      break;
#if CHPRINTF_USE_FLOAT
    case 'f':
      f = (float) va_arg(ap, double);
 8001ef2:	f10a 0a07 	add.w	sl, sl, #7
 8001ef6:	f02a 0a07 	bic.w	sl, sl, #7
 8001efa:	e9da 0100 	ldrd	r0, r1, [sl]
 8001efe:	9301      	str	r3, [sp, #4]
 8001f00:	f7fe fdae 	bl	8000a60 <__aeabi_d2f>
      if (f < 0) {
 8001f04:	2100      	movs	r1, #0
      }
      p = ch_ltoa(p, l, 10);
      break;
#if CHPRINTF_USE_FLOAT
    case 'f':
      f = (float) va_arg(ap, double);
 8001f06:	4681      	mov	r9, r0
      if (f < 0) {
 8001f08:	f7fe fe48 	bl	8000b9c <__aeabi_fcmplt>
      }
      p = ch_ltoa(p, l, 10);
      break;
#if CHPRINTF_USE_FLOAT
    case 'f':
      f = (float) va_arg(ap, double);
 8001f0c:	f10a 0a08 	add.w	sl, sl, #8
      if (f < 0) {
 8001f10:	9b01      	ldr	r3, [sp, #4]
    if (c != '%') {
      streamPut(chp, (uint8_t)c);
      n++;
      continue;
    }
    p = tmpbuf;
 8001f12:	f10d 0830 	add.w	r8, sp, #48	; 0x30
      p = ch_ltoa(p, l, 10);
      break;
#if CHPRINTF_USE_FLOAT
    case 'f':
      f = (float) va_arg(ap, double);
      if (f < 0) {
 8001f16:	2800      	cmp	r0, #0
 8001f18:	d174      	bne.n	8002004 <chprintf.constprop.0+0x3d4>
static char *ftoa(char *p, double num, unsigned long precision) {
  long l;

  if ((precision == 0) || (precision > FLOAT_PRECISION))
    precision = FLOAT_PRECISION;
  precision = pow10[precision - 1];
 8001f1a:	f8dd c018 	ldr.w	ip, [sp, #24]
};

static char *ftoa(char *p, double num, unsigned long precision) {
  long l;

  if ((precision == 0) || (precision > FLOAT_PRECISION))
 8001f1e:	3b01      	subs	r3, #1
 8001f20:	2b08      	cmp	r3, #8
 8001f22:	bf28      	it	cs
 8001f24:	2308      	movcs	r3, #8
    precision = FLOAT_PRECISION;
  precision = pow10[precision - 1];
 8001f26:	f85c 3023 	ldr.w	r3, [ip, r3, lsl #2]

  l = (long)num;
 8001f2a:	4648      	mov	r0, r9
static char *ftoa(char *p, double num, unsigned long precision) {
  long l;

  if ((precision == 0) || (precision > FLOAT_PRECISION))
    precision = FLOAT_PRECISION;
  precision = pow10[precision - 1];
 8001f2c:	9305      	str	r3, [sp, #20]

  l = (long)num;
 8001f2e:	f7fe fe5d 	bl	8000bec <__aeabi_f2iz>
 8001f32:	4684      	mov	ip, r0
  p = long_to_string_with_divisor(p, l, 10, 0);
 8001f34:	220a      	movs	r2, #10
 8001f36:	4661      	mov	r1, ip
 8001f38:	4640      	mov	r0, r8
 8001f3a:	2300      	movs	r3, #0
 8001f3c:	f7ff fcf0 	bl	8001920 <long_to_string_with_divisor.11713.4304>
  *p++ = '.';
 8001f40:	232e      	movs	r3, #46	; 0x2e
 8001f42:	4680      	mov	r8, r0
 8001f44:	f808 3b01 	strb.w	r3, [r8], #1
      f = (float) va_arg(ap, double);
      if (f < 0) {
        *p++ = '-';
        f = -f;
      }
      p = ftoa(p, f, precision);
 8001f48:	4648      	mov	r0, r9
 8001f4a:	f8cd c004 	str.w	ip, [sp, #4]
 8001f4e:	f7fe faf9 	bl	8000544 <__aeabi_f2d>
  precision = pow10[precision - 1];

  l = (long)num;
  p = long_to_string_with_divisor(p, l, 10, 0);
  *p++ = '.';
  l = (long)((num - l) * precision);
 8001f52:	f8dd c004 	ldr.w	ip, [sp, #4]
      f = (float) va_arg(ap, double);
      if (f < 0) {
        *p++ = '-';
        f = -f;
      }
      p = ftoa(p, f, precision);
 8001f56:	e9cd 0108 	strd	r0, r1, [sp, #32]
  precision = pow10[precision - 1];

  l = (long)num;
  p = long_to_string_with_divisor(p, l, 10, 0);
  *p++ = '.';
  l = (long)((num - l) * precision);
 8001f5a:	4660      	mov	r0, ip
 8001f5c:	f7fe fae0 	bl	8000520 <__aeabi_i2d>
 8001f60:	4602      	mov	r2, r0
 8001f62:	460b      	mov	r3, r1
 8001f64:	e9dd 0108 	ldrd	r0, r1, [sp, #32]
 8001f68:	f7fe f98c 	bl	8000284 <__aeabi_dsub>
 8001f6c:	e9cd 0108 	strd	r0, r1, [sp, #32]
 8001f70:	9805      	ldr	r0, [sp, #20]
 8001f72:	f7fe fac5 	bl	8000500 <__aeabi_ui2d>
 8001f76:	4602      	mov	r2, r0
 8001f78:	460b      	mov	r3, r1
 8001f7a:	e9dd 0108 	ldrd	r0, r1, [sp, #32]
 8001f7e:	f7fe fb35 	bl	80005ec <__aeabi_dmul>
 8001f82:	f7fe fd45 	bl	8000a10 <__aeabi_d2iz>
  return long_to_string_with_divisor(p, l, 10, precision / 10);
 8001f86:	f64c 43cd 	movw	r3, #52429	; 0xcccd
  precision = pow10[precision - 1];

  l = (long)num;
  p = long_to_string_with_divisor(p, l, 10, 0);
  *p++ = '.';
  l = (long)((num - l) * precision);
 8001f8a:	4601      	mov	r1, r0
  return long_to_string_with_divisor(p, l, 10, precision / 10);
 8001f8c:	9805      	ldr	r0, [sp, #20]
 8001f8e:	f6cc 43cc 	movt	r3, #52428	; 0xcccc
 8001f92:	fba3 0300 	umull	r0, r3, r3, r0
 8001f96:	220a      	movs	r2, #10
 8001f98:	4640      	mov	r0, r8
 8001f9a:	08db      	lsrs	r3, r3, #3
 8001f9c:	e716      	b.n	8001dcc <chprintf.constprop.0+0x19c>

    /* Command decoding.*/
    switch (c) {
    case 'c':
      filler = ' ';
      *p++ = va_arg(ap, int);
 8001f9e:	f8da 3000 	ldr.w	r3, [sl]
 8001fa2:	9807      	ldr	r0, [sp, #28]
      streamPut(chp, (uint8_t)c);
      n++;
      continue;
    }
    p = tmpbuf;
    s = tmpbuf;
 8001fa4:	aa0c      	add	r2, sp, #48	; 0x30

    /* Command decoding.*/
    switch (c) {
    case 'c':
      filler = ' ';
      *p++ = va_arg(ap, int);
 8001fa6:	f88d 3030 	strb.w	r3, [sp, #48]	; 0x30
 8001faa:	f10a 0a04 	add.w	sl, sl, #4
 8001fae:	f100 39ff 	add.w	r9, r0, #4294967295
      is_long = (c >= 'A') && (c <= 'Z');

    /* Command decoding.*/
    switch (c) {
    case 'c':
      filler = ' ';
 8001fb2:	2520      	movs	r5, #32
      streamPut(chp, (uint8_t)c);
      n++;
      continue;
    }
    p = tmpbuf;
    s = tmpbuf;
 8001fb4:	9205      	str	r2, [sp, #20]
 8001fb6:	e713      	b.n	8001de0 <chprintf.constprop.0+0x1b0>
    }
    else
      is_long = (c >= 'A') && (c <= 'Z');

    /* Command decoding.*/
    switch (c) {
 8001fb8:	2210      	movs	r2, #16
 8001fba:	e701      	b.n	8001dc0 <chprintf.constprop.0+0x190>
 8001fbc:	9807      	ldr	r0, [sp, #28]
      streamPut(chp, (uint8_t)c);
      n++;
      continue;
    }
    p = tmpbuf;
    s = tmpbuf;
 8001fbe:	ab0c      	add	r3, sp, #48	; 0x30
      else
        l = va_arg(ap, unsigned int);
      p = ch_ltoa(p, l, c);
      break;
    default:
      *p++ = c;
 8001fc0:	f88d 2030 	strb.w	r2, [sp, #48]	; 0x30
 8001fc4:	f100 39ff 	add.w	r9, r0, #4294967295
      streamPut(chp, (uint8_t)c);
      n++;
      continue;
    }
    p = tmpbuf;
    s = tmpbuf;
 8001fc8:	9305      	str	r3, [sp, #20]
 8001fca:	e709      	b.n	8001de0 <chprintf.constprop.0+0x1b0>
    if ((width -= i) < 0)
      width = 0;
    if (left_align == FALSE)
      width = -width;
    if (width < 0) {
      if (*s == '-' && filler == '0') {
 8001fcc:	2d30      	cmp	r5, #48	; 0x30
 8001fce:	f47f af16 	bne.w	8001dfe <chprintf.constprop.0+0x1ce>
        streamPut(chp, (uint8_t)*s++);
 8001fd2:	f8db 3000 	ldr.w	r3, [fp]
 8001fd6:	f2c2 0800 	movt	r8, #8192	; 0x2000
 8001fda:	4640      	mov	r0, r8
 8001fdc:	689b      	ldr	r3, [r3, #8]
 8001fde:	4798      	blx	r3
 8001fe0:	9a05      	ldr	r2, [sp, #20]
        n++;
 8001fe2:	f8dd c010 	ldr.w	ip, [sp, #16]
      width = 0;
    if (left_align == FALSE)
      width = -width;
    if (width < 0) {
      if (*s == '-' && filler == '0') {
        streamPut(chp, (uint8_t)*s++);
 8001fe6:	3201      	adds	r2, #1
        n++;
 8001fe8:	f10c 0c01 	add.w	ip, ip, #1
      width = 0;
    if (left_align == FALSE)
      width = -width;
    if (width < 0) {
      if (*s == '-' && filler == '0') {
        streamPut(chp, (uint8_t)*s++);
 8001fec:	9205      	str	r2, [sp, #20]
        n++;
 8001fee:	f8cd c010 	str.w	ip, [sp, #16]
 8001ff2:	f109 39ff 	add.w	r9, r9, #4294967295
 8001ff6:	e704      	b.n	8001e02 <chprintf.constprop.0+0x1d2>
 8001ff8:	9a05      	ldr	r2, [sp, #20]
    case 'c':
      filler = ' ';
      *p++ = va_arg(ap, int);
      break;
    case 's':
      filler = ' ';
 8001ffa:	2520      	movs	r5, #32
 8001ffc:	1a98      	subs	r0, r3, r2
 8001ffe:	f100 39ff 	add.w	r9, r0, #4294967295
 8002002:	e6ed      	b.n	8001de0 <chprintf.constprop.0+0x1b0>
      break;
#if CHPRINTF_USE_FLOAT
    case 'f':
      f = (float) va_arg(ap, double);
      if (f < 0) {
        *p++ = '-';
 8002004:	222d      	movs	r2, #45	; 0x2d
        f = -f;
 8002006:	f109 4900 	add.w	r9, r9, #2147483648	; 0x80000000
      break;
#if CHPRINTF_USE_FLOAT
    case 'f':
      f = (float) va_arg(ap, double);
      if (f < 0) {
        *p++ = '-';
 800200a:	f88d 2030 	strb.w	r2, [sp, #48]	; 0x30
 800200e:	f10d 0831 	add.w	r8, sp, #49	; 0x31
 8002012:	e782      	b.n	8001f1a <chprintf.constprop.0+0x2ea>
      filler = ' ';
      if ((s = va_arg(ap, char *)) == 0)
        s = "(null)";
      if (precision == 0)
        precision = 32767;
      for (p = s; *p && (--precision >= 0); p++)
 8002014:	f04f 39ff 	mov.w	r9, #4294967295
    case 'c':
      filler = ' ';
      *p++ = va_arg(ap, int);
      break;
    case 's':
      filler = ' ';
 8002018:	2520      	movs	r5, #32
 800201a:	e6e1      	b.n	8001de0 <chprintf.constprop.0+0x1b0>
 800201c:	f3af 8000 	nop.w

08002020 <_port_irq_epilogue>:
 8002020:	2320      	movs	r3, #32
 8002022:	f383 8811 	msr	BASEPRI, r3
 * @brief   Exception exit redirection to _port_switch_from_isr().
 */
void _port_irq_epilogue(void) {

  port_lock_from_isr();
  if ((SCB->ICSR & SCB_ICSR_RETTOBASE_Msk) != 0U) {
 8002026:	f44f 436d 	mov.w	r3, #60672	; 0xed00
 800202a:	f2ce 0300 	movt	r3, #57344	; 0xe000
 800202e:	685b      	ldr	r3, [r3, #4]
 8002030:	f413 6300 	ands.w	r3, r3, #2048	; 0x800
 8002034:	d102      	bne.n	800203c <_port_irq_epilogue+0x1c>
 8002036:	f383 8811 	msr	BASEPRI, r3
 800203a:	4770      	bx	lr
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE uint32_t __get_PSP(void)
{
  register uint32_t result;

  __ASM volatile ("MRS %0, psp\n"  : "=r" (result) );
 800203c:	f3ef 8209 	mrs	r2, PSP
    /* Adding an artificial exception return context, there is no need to
       populate it fully.*/
    ctxp--;

    /* Setting up a fake XPSR register value.*/
    ctxp->xpsr = (regarm_t)0x01000000;
 8002040:	f04f 7380 	mov.w	r3, #16777216	; 0x1000000
 8002044:	f842 3c04 	str.w	r3, [r2, #-4]
    /* The port_extctx structure is pointed by the PSP register.*/
    ctxp = (struct port_extctx *)__get_PSP();

    /* Adding an artificial exception return context, there is no need to
       populate it fully.*/
    ctxp--;
 8002048:	f1a2 0320 	sub.w	r3, r2, #32
  \details Assigns the given value to the Process Stack Pointer (PSP).
  \param [in]    topOfProcStack  Process Stack Pointer value to set
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __set_PSP(uint32_t topOfProcStack)
{
  __ASM volatile ("MSR psp, %0\n" : : "r" (topOfProcStack) : "sp");
 800204c:	f383 8809 	msr	PSP, r3
 * @retval false        if preemption is not required.
 *
 * @special
 */
bool chSchIsPreemptionRequired(void) {
  tprio_t p1 = firstprio(&ch.rlist.queue);
 8002050:	f640 03d8 	movw	r3, #2264	; 0x8d8
 8002054:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8002058:	6819      	ldr	r1, [r3, #0]
  tprio_t p2 = currp->prio;
 800205a:	699b      	ldr	r3, [r3, #24]
    /* Writing back the modified PSP value.*/
    __set_PSP((uint32_t)ctxp);

    /* The exit sequence is different depending on if a preemption is
       required or not.*/
    if (chSchIsPreemptionRequired()) {
 800205c:	6889      	ldr	r1, [r1, #8]
 800205e:	689b      	ldr	r3, [r3, #8]
 8002060:	4299      	cmp	r1, r3
      /* Preemption is required we need to enforce a context switch.*/
      ctxp->pc = (regarm_t)_port_switch_from_isr;
 8002062:	bf8b      	itete	hi
 8002064:	f240 2375 	movwhi	r3, #629	; 0x275
    }
    else {
      /* Preemption not required, we just need to exit the exception
         atomically.*/
      ctxp->pc = (regarm_t)_port_exit_from_isr;
 8002068:	f240 2378 	movwls	r3, #632	; 0x278

    /* The exit sequence is different depending on if a preemption is
       required or not.*/
    if (chSchIsPreemptionRequired()) {
      /* Preemption is required we need to enforce a context switch.*/
      ctxp->pc = (regarm_t)_port_switch_from_isr;
 800206c:	f6c0 0300 	movthi	r3, #2048	; 0x800
    }
    else {
      /* Preemption not required, we just need to exit the exception
         atomically.*/
      ctxp->pc = (regarm_t)_port_exit_from_isr;
 8002070:	f6c0 0300 	movtls	r3, #2048	; 0x800
 8002074:	f842 3c08 	str.w	r3, [r2, #-8]
 8002078:	4770      	bx	lr
 800207a:	bf00      	nop
 800207c:	f3af 8000 	nop.w

08002080 <Vector84>:
 */
OSAL_IRQ_HANDLER(STM32_DMA1_CH7_HANDLER) {

  OSAL_IRQ_PROLOGUE();

  dmaServeInterrupt(STM32_DMA1_STREAM7);
 8002080:	2300      	movs	r3, #0
 8002082:	f2c4 0302 	movt	r3, #16386	; 0x4002
 8002086:	6819      	ldr	r1, [r3, #0]
 8002088:	2280      	movs	r2, #128	; 0x80
 800208a:	f2c4 0202 	movt	r2, #16386	; 0x4002
 800208e:	0e09      	lsrs	r1, r1, #24
 8002090:	6812      	ldr	r2, [r2, #0]
 8002092:	f001 010e 	and.w	r1, r1, #14
 8002096:	4211      	tst	r1, r2
/**
 * @brief   DMA1 stream 7 shared ISR.
 *
 * @isr
 */
OSAL_IRQ_HANDLER(STM32_DMA1_CH7_HANDLER) {
 8002098:	b510      	push	{r4, lr}

  OSAL_IRQ_PROLOGUE();

  dmaServeInterrupt(STM32_DMA1_STREAM7);
 800209a:	d009      	beq.n	80020b0 <Vector84+0x30>
 800209c:	f640 0218 	movw	r2, #2072	; 0x818
 80020a0:	f2c2 0200 	movt	r2, #8192	; 0x2000
 80020a4:	6b14      	ldr	r4, [r2, #48]	; 0x30
 80020a6:	0608      	lsls	r0, r1, #24
 80020a8:	6058      	str	r0, [r3, #4]
 80020aa:	b10c      	cbz	r4, 80020b0 <Vector84+0x30>
 80020ac:	6b50      	ldr	r0, [r2, #52]	; 0x34
 80020ae:	47a0      	blx	r4

  OSAL_IRQ_EPILOGUE();
}
 80020b0:	e8bd 4010 	ldmia.w	sp!, {r4, lr}

  OSAL_IRQ_PROLOGUE();

  dmaServeInterrupt(STM32_DMA1_STREAM7);

  OSAL_IRQ_EPILOGUE();
 80020b4:	f7ff bfb4 	b.w	8002020 <_port_irq_epilogue>
 80020b8:	f3af 8000 	nop.w
 80020bc:	f3af 8000 	nop.w

080020c0 <Vector80>:
 */
OSAL_IRQ_HANDLER(STM32_DMA1_CH6_HANDLER) {

  OSAL_IRQ_PROLOGUE();

  dmaServeInterrupt(STM32_DMA1_STREAM6);
 80020c0:	2300      	movs	r3, #0
 80020c2:	f2c4 0302 	movt	r3, #16386	; 0x4002
 80020c6:	6819      	ldr	r1, [r3, #0]
 80020c8:	226c      	movs	r2, #108	; 0x6c
 80020ca:	f2c4 0202 	movt	r2, #16386	; 0x4002
 80020ce:	0d09      	lsrs	r1, r1, #20
 80020d0:	6812      	ldr	r2, [r2, #0]
 80020d2:	f001 010e 	and.w	r1, r1, #14
 80020d6:	4211      	tst	r1, r2
/**
 * @brief   DMA1 stream 6 shared ISR.
 *
 * @isr
 */
OSAL_IRQ_HANDLER(STM32_DMA1_CH6_HANDLER) {
 80020d8:	b510      	push	{r4, lr}

  OSAL_IRQ_PROLOGUE();

  dmaServeInterrupt(STM32_DMA1_STREAM6);
 80020da:	d009      	beq.n	80020f0 <Vector80+0x30>
 80020dc:	f640 0218 	movw	r2, #2072	; 0x818
 80020e0:	f2c2 0200 	movt	r2, #8192	; 0x2000
 80020e4:	6a94      	ldr	r4, [r2, #40]	; 0x28
 80020e6:	0508      	lsls	r0, r1, #20
 80020e8:	6058      	str	r0, [r3, #4]
 80020ea:	b10c      	cbz	r4, 80020f0 <Vector80+0x30>
 80020ec:	6ad0      	ldr	r0, [r2, #44]	; 0x2c
 80020ee:	47a0      	blx	r4

  OSAL_IRQ_EPILOGUE();
}
 80020f0:	e8bd 4010 	ldmia.w	sp!, {r4, lr}

  OSAL_IRQ_PROLOGUE();

  dmaServeInterrupt(STM32_DMA1_STREAM6);

  OSAL_IRQ_EPILOGUE();
 80020f4:	f7ff bf94 	b.w	8002020 <_port_irq_epilogue>
 80020f8:	f3af 8000 	nop.w
 80020fc:	f3af 8000 	nop.w

08002100 <Vector7C>:
 */
OSAL_IRQ_HANDLER(STM32_DMA1_CH5_HANDLER) {

  OSAL_IRQ_PROLOGUE();

  dmaServeInterrupt(STM32_DMA1_STREAM5);
 8002100:	2300      	movs	r3, #0
 8002102:	f2c4 0302 	movt	r3, #16386	; 0x4002
 8002106:	6819      	ldr	r1, [r3, #0]
 8002108:	2258      	movs	r2, #88	; 0x58
 800210a:	f2c4 0202 	movt	r2, #16386	; 0x4002
 800210e:	0c09      	lsrs	r1, r1, #16
 8002110:	6812      	ldr	r2, [r2, #0]
 8002112:	f001 010e 	and.w	r1, r1, #14
 8002116:	4211      	tst	r1, r2
/**
 * @brief   DMA1 stream 5 shared ISR.
 *
 * @isr
 */
OSAL_IRQ_HANDLER(STM32_DMA1_CH5_HANDLER) {
 8002118:	b510      	push	{r4, lr}

  OSAL_IRQ_PROLOGUE();

  dmaServeInterrupt(STM32_DMA1_STREAM5);
 800211a:	d009      	beq.n	8002130 <Vector7C+0x30>
 800211c:	f640 0218 	movw	r2, #2072	; 0x818
 8002120:	f2c2 0200 	movt	r2, #8192	; 0x2000
 8002124:	6a14      	ldr	r4, [r2, #32]
 8002126:	0408      	lsls	r0, r1, #16
 8002128:	6058      	str	r0, [r3, #4]
 800212a:	b10c      	cbz	r4, 8002130 <Vector7C+0x30>
 800212c:	6a50      	ldr	r0, [r2, #36]	; 0x24
 800212e:	47a0      	blx	r4

  OSAL_IRQ_EPILOGUE();
}
 8002130:	e8bd 4010 	ldmia.w	sp!, {r4, lr}

  OSAL_IRQ_PROLOGUE();

  dmaServeInterrupt(STM32_DMA1_STREAM5);

  OSAL_IRQ_EPILOGUE();
 8002134:	f7ff bf74 	b.w	8002020 <_port_irq_epilogue>
 8002138:	f3af 8000 	nop.w
 800213c:	f3af 8000 	nop.w

08002140 <Vector78>:
 */
OSAL_IRQ_HANDLER(STM32_DMA1_CH4_HANDLER) {

  OSAL_IRQ_PROLOGUE();

  dmaServeInterrupt(STM32_DMA1_STREAM4);
 8002140:	2300      	movs	r3, #0
 8002142:	f2c4 0302 	movt	r3, #16386	; 0x4002
 8002146:	6819      	ldr	r1, [r3, #0]
 8002148:	2244      	movs	r2, #68	; 0x44
 800214a:	f2c4 0202 	movt	r2, #16386	; 0x4002
 800214e:	0b09      	lsrs	r1, r1, #12
 8002150:	6812      	ldr	r2, [r2, #0]
 8002152:	f001 010e 	and.w	r1, r1, #14
 8002156:	4211      	tst	r1, r2
/**
 * @brief   DMA1 stream 4 shared ISR.
 *
 * @isr
 */
OSAL_IRQ_HANDLER(STM32_DMA1_CH4_HANDLER) {
 8002158:	b510      	push	{r4, lr}

  OSAL_IRQ_PROLOGUE();

  dmaServeInterrupt(STM32_DMA1_STREAM4);
 800215a:	d009      	beq.n	8002170 <Vector78+0x30>
 800215c:	f640 0218 	movw	r2, #2072	; 0x818
 8002160:	f2c2 0200 	movt	r2, #8192	; 0x2000
 8002164:	6994      	ldr	r4, [r2, #24]
 8002166:	0308      	lsls	r0, r1, #12
 8002168:	6058      	str	r0, [r3, #4]
 800216a:	b10c      	cbz	r4, 8002170 <Vector78+0x30>
 800216c:	69d0      	ldr	r0, [r2, #28]
 800216e:	47a0      	blx	r4

  OSAL_IRQ_EPILOGUE();
}
 8002170:	e8bd 4010 	ldmia.w	sp!, {r4, lr}

  OSAL_IRQ_PROLOGUE();

  dmaServeInterrupt(STM32_DMA1_STREAM4);

  OSAL_IRQ_EPILOGUE();
 8002174:	f7ff bf54 	b.w	8002020 <_port_irq_epilogue>
 8002178:	f3af 8000 	nop.w
 800217c:	f3af 8000 	nop.w

08002180 <Vector74>:
 */
OSAL_IRQ_HANDLER(STM32_DMA1_CH3_HANDLER) {

  OSAL_IRQ_PROLOGUE();

  dmaServeInterrupt(STM32_DMA1_STREAM3);
 8002180:	2300      	movs	r3, #0
 8002182:	f2c4 0302 	movt	r3, #16386	; 0x4002
 8002186:	6819      	ldr	r1, [r3, #0]
 8002188:	2230      	movs	r2, #48	; 0x30
 800218a:	f2c4 0202 	movt	r2, #16386	; 0x4002
 800218e:	0a09      	lsrs	r1, r1, #8
 8002190:	6812      	ldr	r2, [r2, #0]
 8002192:	f001 010e 	and.w	r1, r1, #14
 8002196:	4211      	tst	r1, r2
/**
 * @brief   DMA1 stream 3 shared ISR.
 *
 * @isr
 */
OSAL_IRQ_HANDLER(STM32_DMA1_CH3_HANDLER) {
 8002198:	b510      	push	{r4, lr}

  OSAL_IRQ_PROLOGUE();

  dmaServeInterrupt(STM32_DMA1_STREAM3);
 800219a:	d009      	beq.n	80021b0 <Vector74+0x30>
 800219c:	f640 0218 	movw	r2, #2072	; 0x818
 80021a0:	f2c2 0200 	movt	r2, #8192	; 0x2000
 80021a4:	6914      	ldr	r4, [r2, #16]
 80021a6:	0208      	lsls	r0, r1, #8
 80021a8:	6058      	str	r0, [r3, #4]
 80021aa:	b10c      	cbz	r4, 80021b0 <Vector74+0x30>
 80021ac:	6950      	ldr	r0, [r2, #20]
 80021ae:	47a0      	blx	r4

  OSAL_IRQ_EPILOGUE();
}
 80021b0:	e8bd 4010 	ldmia.w	sp!, {r4, lr}

  OSAL_IRQ_PROLOGUE();

  dmaServeInterrupt(STM32_DMA1_STREAM3);

  OSAL_IRQ_EPILOGUE();
 80021b4:	f7ff bf34 	b.w	8002020 <_port_irq_epilogue>
 80021b8:	f3af 8000 	nop.w
 80021bc:	f3af 8000 	nop.w

080021c0 <Vector70>:
 */
OSAL_IRQ_HANDLER(STM32_DMA1_CH2_HANDLER) {

  OSAL_IRQ_PROLOGUE();

  dmaServeInterrupt(STM32_DMA1_STREAM2);
 80021c0:	2300      	movs	r3, #0
 80021c2:	f2c4 0302 	movt	r3, #16386	; 0x4002
 80021c6:	6819      	ldr	r1, [r3, #0]
 80021c8:	221c      	movs	r2, #28
 80021ca:	f2c4 0202 	movt	r2, #16386	; 0x4002
 80021ce:	0909      	lsrs	r1, r1, #4
 80021d0:	6812      	ldr	r2, [r2, #0]
 80021d2:	f001 010e 	and.w	r1, r1, #14
 80021d6:	4211      	tst	r1, r2
/**
 * @brief   DMA1 stream 2 shared ISR.
 *
 * @isr
 */
OSAL_IRQ_HANDLER(STM32_DMA1_CH2_HANDLER) {
 80021d8:	b510      	push	{r4, lr}

  OSAL_IRQ_PROLOGUE();

  dmaServeInterrupt(STM32_DMA1_STREAM2);
 80021da:	d009      	beq.n	80021f0 <Vector70+0x30>
 80021dc:	f640 0218 	movw	r2, #2072	; 0x818
 80021e0:	f2c2 0200 	movt	r2, #8192	; 0x2000
 80021e4:	6894      	ldr	r4, [r2, #8]
 80021e6:	0108      	lsls	r0, r1, #4
 80021e8:	6058      	str	r0, [r3, #4]
 80021ea:	b10c      	cbz	r4, 80021f0 <Vector70+0x30>
 80021ec:	68d0      	ldr	r0, [r2, #12]
 80021ee:	47a0      	blx	r4

  OSAL_IRQ_EPILOGUE();
}
 80021f0:	e8bd 4010 	ldmia.w	sp!, {r4, lr}

  OSAL_IRQ_PROLOGUE();

  dmaServeInterrupt(STM32_DMA1_STREAM2);

  OSAL_IRQ_EPILOGUE();
 80021f4:	f7ff bf14 	b.w	8002020 <_port_irq_epilogue>
 80021f8:	f3af 8000 	nop.w
 80021fc:	f3af 8000 	nop.w

08002200 <Vector6C>:
 */
OSAL_IRQ_HANDLER(STM32_DMA1_CH1_HANDLER) {

  OSAL_IRQ_PROLOGUE();

  dmaServeInterrupt(STM32_DMA1_STREAM1);
 8002200:	2300      	movs	r3, #0
 8002202:	f2c4 0302 	movt	r3, #16386	; 0x4002
 8002206:	2208      	movs	r2, #8
 8002208:	6819      	ldr	r1, [r3, #0]
 800220a:	f2c4 0202 	movt	r2, #16386	; 0x4002
 800220e:	6812      	ldr	r2, [r2, #0]
 8002210:	f001 010e 	and.w	r1, r1, #14
 8002214:	4211      	tst	r1, r2
/**
 * @brief   DMA1 stream 1 shared ISR.
 *
 * @isr
 */
OSAL_IRQ_HANDLER(STM32_DMA1_CH1_HANDLER) {
 8002216:	b510      	push	{r4, lr}

  OSAL_IRQ_PROLOGUE();

  dmaServeInterrupt(STM32_DMA1_STREAM1);
 8002218:	d008      	beq.n	800222c <Vector6C+0x2c>
 800221a:	f640 0218 	movw	r2, #2072	; 0x818
 800221e:	f2c2 0200 	movt	r2, #8192	; 0x2000
 8002222:	6814      	ldr	r4, [r2, #0]
 8002224:	6059      	str	r1, [r3, #4]
 8002226:	b10c      	cbz	r4, 800222c <Vector6C+0x2c>
 8002228:	6850      	ldr	r0, [r2, #4]
 800222a:	47a0      	blx	r4

  OSAL_IRQ_EPILOGUE();
}
 800222c:	e8bd 4010 	ldmia.w	sp!, {r4, lr}

  OSAL_IRQ_PROLOGUE();

  dmaServeInterrupt(STM32_DMA1_STREAM1);

  OSAL_IRQ_EPILOGUE();
 8002230:	f7ff bef6 	b.w	8002020 <_port_irq_epilogue>
 8002234:	f3af 8000 	nop.w
 8002238:	f3af 8000 	nop.w
 800223c:	f3af 8000 	nop.w

08002240 <chSchGoSleepS>:
 * @param[in] newstate  the new thread state
 *
 * @sclass
 */
void chSchGoSleepS(tstate_t newstate) {
  thread_t *otp = currp;
 8002240:	f640 03d8 	movw	r3, #2264	; 0x8d8
 8002244:	f2c2 0300 	movt	r3, #8192	; 0x2000
 *
 * @param[in] newstate  the new thread state
 *
 * @sclass
 */
void chSchGoSleepS(tstate_t newstate) {
 8002248:	b430      	push	{r4, r5}
  tp->queue.prev->queue.next = tp;
  tqp->prev                  = tp;
}

static inline thread_t *queue_fifo_remove(threads_queue_t *tqp) {
  thread_t *tp = tqp->next;
 800224a:	681a      	ldr	r2, [r3, #0]
  thread_t *otp = currp;
 800224c:	6999      	ldr	r1, [r3, #24]

  tqp->next             = tp->queue.next;
 800224e:	6814      	ldr	r4, [r2, #0]
  otp->preempt = (tslices_t)CH_CFG_TIME_QUANTUM;
#endif

  /* Next thread in ready list becomes current.*/
  currp = queue_fifo_remove(&ch.rlist.queue);
  currp->state = CH_STATE_CURRENT;
 8002250:	2501      	movs	r5, #1
  thread_t *otp = currp;

  chDbgCheckClassS();

  /* New state.*/
  otp->state = newstate;
 8002252:	f881 0020 	strb.w	r0, [r1, #32]
  tqp->next->queue.prev = (thread_t *)tqp;
 8002256:	6063      	str	r3, [r4, #4]
  otp->preempt = (tslices_t)CH_CFG_TIME_QUANTUM;
#endif

  /* Next thread in ready list becomes current.*/
  currp = queue_fifo_remove(&ch.rlist.queue);
  currp->state = CH_STATE_CURRENT;
 8002258:	f882 5020 	strb.w	r5, [r2, #32]
}

static inline thread_t *queue_fifo_remove(threads_queue_t *tqp) {
  thread_t *tp = tqp->next;

  tqp->next             = tp->queue.next;
 800225c:	601c      	str	r4, [r3, #0]
  if (currp->prio == IDLEPRIO) {
    CH_CFG_IDLE_ENTER_HOOK();
  }

  /* Swap operation as tail call.*/
  chSysSwitch(currp, otp);
 800225e:	4610      	mov	r0, r2
}
 8002260:	bc30      	pop	{r4, r5}
     time quantum when it will wakeup.*/
  otp->preempt = (tslices_t)CH_CFG_TIME_QUANTUM;
#endif

  /* Next thread in ready list becomes current.*/
  currp = queue_fifo_remove(&ch.rlist.queue);
 8002262:	619a      	str	r2, [r3, #24]
  if (currp->prio == IDLEPRIO) {
    CH_CFG_IDLE_ENTER_HOOK();
  }

  /* Swap operation as tail call.*/
  chSysSwitch(currp, otp);
 8002264:	f7fd bff6 	b.w	8000254 <_port_switch>
 8002268:	f3af 8000 	nop.w
 800226c:	f3af 8000 	nop.w

08002270 <chSchReadyI>:
  chDbgCheck(tp != NULL);
  chDbgAssert((tp->state != CH_STATE_READY) &&
              (tp->state != CH_STATE_FINAL),
              "invalid state");

  tp->state = CH_STATE_READY;
 8002270:	2200      	movs	r2, #0
  cp = (thread_t *)&ch.rlist.queue;
 8002272:	f640 03d8 	movw	r3, #2264	; 0x8d8
 8002276:	6881      	ldr	r1, [r0, #8]
 * @param[in] tp        the thread to be made ready
 * @return              The thread pointer.
 *
 * @iclass
 */
thread_t *chSchReadyI(thread_t *tp) {
 8002278:	b410      	push	{r4}
  chDbgAssert((tp->state != CH_STATE_READY) &&
              (tp->state != CH_STATE_FINAL),
              "invalid state");

  tp->state = CH_STATE_READY;
  cp = (thread_t *)&ch.rlist.queue;
 800227a:	f2c2 0300 	movt	r3, #8192	; 0x2000
 * @param[in] tp        the thread to be made ready
 * @return              The thread pointer.
 *
 * @iclass
 */
thread_t *chSchReadyI(thread_t *tp) {
 800227e:	4604      	mov	r4, r0
  chDbgCheck(tp != NULL);
  chDbgAssert((tp->state != CH_STATE_READY) &&
              (tp->state != CH_STATE_FINAL),
              "invalid state");

  tp->state = CH_STATE_READY;
 8002280:	f880 2020 	strb.w	r2, [r0, #32]
  cp = (thread_t *)&ch.rlist.queue;
  do {
    cp = cp->queue.next;
 8002284:	681b      	ldr	r3, [r3, #0]
  } while (cp->prio >= tp->prio);
 8002286:	689a      	ldr	r2, [r3, #8]
 8002288:	428a      	cmp	r2, r1
 800228a:	d2fb      	bcs.n	8002284 <chSchReadyI+0x14>
  /* Insertion on prev.*/
  tp->queue.next             = cp;
  tp->queue.prev             = cp->queue.prev;
 800228c:	685a      	ldr	r2, [r3, #4]
  tp->queue.prev->queue.next = tp;
  cp->queue.prev             = tp;

  return tp;
}
 800228e:	4620      	mov	r0, r4
  cp = (thread_t *)&ch.rlist.queue;
  do {
    cp = cp->queue.next;
  } while (cp->prio >= tp->prio);
  /* Insertion on prev.*/
  tp->queue.next             = cp;
 8002290:	6023      	str	r3, [r4, #0]
  tp->queue.prev             = cp->queue.prev;
 8002292:	6062      	str	r2, [r4, #4]
  tp->queue.prev->queue.next = tp;
 8002294:	6014      	str	r4, [r2, #0]
  cp->queue.prev             = tp;
 8002296:	605c      	str	r4, [r3, #4]

  return tp;
}
 8002298:	f85d 4b04 	ldr.w	r4, [sp], #4
 800229c:	4770      	bx	lr
 800229e:	bf00      	nop

080022a0 <VectorBC>:
/**
 * @brief   I2C1 event interrupt handler.
 *
 * @notapi
 */
OSAL_IRQ_HANDLER(STM32_I2C1_EVENT_HANDLER) {
 80022a0:	b538      	push	{r3, r4, r5, lr}
 * @param[in] i2cp      pointer to the @p I2CDriver object
 *
 * @notapi
 */
static void i2c_lld_serve_event_interrupt(I2CDriver *i2cp) {
  I2C_TypeDef *dp = i2cp->i2c;
 80022a2:	f640 2358 	movw	r3, #2648	; 0xa58
 80022a6:	f2c2 0300 	movt	r3, #8192	; 0x2000
 80022aa:	6b5c      	ldr	r4, [r3, #52]	; 0x34
  uint32_t event = dp->SR1;

  /* Interrupts are disabled just before dmaStreamEnable() because there
     is no need of interrupts until next transaction begin. All the work is
     done by the DMA.*/
  switch (I2C_EV_MASK & (event | (regSR2 << 16))) {
 80022ac:	2108      	movs	r1, #8
 *
 * @notapi
 */
static void i2c_lld_serve_event_interrupt(I2CDriver *i2cp) {
  I2C_TypeDef *dp = i2cp->i2c;
  uint32_t regSR2 = dp->SR2;
 80022ae:	69a2      	ldr	r2, [r4, #24]
  uint32_t event = dp->SR1;
 80022b0:	6965      	ldr	r5, [r4, #20]

  /* Interrupts are disabled just before dmaStreamEnable() because there
     is no need of interrupts until next transaction begin. All the work is
     done by the DMA.*/
  switch (I2C_EV_MASK & (event | (regSR2 << 16))) {
 80022b2:	f2c0 0103 	movt	r1, #3
 80022b6:	ea45 4202 	orr.w	r2, r5, r2, lsl #16
 80022ba:	f022 427f 	bic.w	r2, r2, #4278190080	; 0xff000000
 80022be:	428a      	cmp	r2, r1
 80022c0:	d054      	beq.n	800236c <VectorBC+0xcc>
 80022c2:	d822      	bhi.n	800230a <VectorBC+0x6a>
 80022c4:	2101      	movs	r1, #1
 80022c6:	f2c0 0103 	movt	r1, #3
 80022ca:	428a      	cmp	r2, r1
 80022cc:	d042      	beq.n	8002354 <VectorBC+0xb4>
 80022ce:	2102      	movs	r1, #2
 80022d0:	f2c0 0103 	movt	r1, #3
 80022d4:	428a      	cmp	r2, r1
 80022d6:	d110      	bne.n	80022fa <VectorBC+0x5a>
  case I2C_EV9_MASTER_ADD10:
    /* Set second addr byte (10-bit addressing)*/
    dp->DR = (0xFF & (i2cp->addr >> 1));
    break;
  case I2C_EV6_MASTER_REC_MODE_SELECTED:
    dp->CR2 &= ~I2C_CR2_ITEVTEN;
 80022d8:	6862      	ldr	r2, [r4, #4]
    dmaStreamEnable(i2cp->dmarx);
 80022da:	6adb      	ldr	r3, [r3, #44]	; 0x2c
  case I2C_EV9_MASTER_ADD10:
    /* Set second addr byte (10-bit addressing)*/
    dp->DR = (0xFF & (i2cp->addr >> 1));
    break;
  case I2C_EV6_MASTER_REC_MODE_SELECTED:
    dp->CR2 &= ~I2C_CR2_ITEVTEN;
 80022dc:	f422 7200 	bic.w	r2, r2, #512	; 0x200
    dmaStreamEnable(i2cp->dmarx);
 80022e0:	685b      	ldr	r3, [r3, #4]
  case I2C_EV9_MASTER_ADD10:
    /* Set second addr byte (10-bit addressing)*/
    dp->DR = (0xFF & (i2cp->addr >> 1));
    break;
  case I2C_EV6_MASTER_REC_MODE_SELECTED:
    dp->CR2 &= ~I2C_CR2_ITEVTEN;
 80022e2:	6062      	str	r2, [r4, #4]
    dmaStreamEnable(i2cp->dmarx);
 80022e4:	681a      	ldr	r2, [r3, #0]
 80022e6:	f042 0201 	orr.w	r2, r2, #1
 80022ea:	601a      	str	r2, [r3, #0]
    dp->CR2 |= I2C_CR2_LAST;                 /* Needed in receiver mode. */
 80022ec:	6862      	ldr	r2, [r4, #4]
 80022ee:	f442 5280 	orr.w	r2, r2, #4096	; 0x1000
 80022f2:	6062      	str	r2, [r4, #4]
    if (dmaStreamGetTransactionSize(i2cp->dmarx) < 2)
 80022f4:	685b      	ldr	r3, [r3, #4]
 80022f6:	2b01      	cmp	r3, #1
 80022f8:	d957      	bls.n	80023aa <VectorBC+0x10a>
    break;
  default:
    break;
  }
  /* Clear ADDR flag. */
  if (event & (I2C_SR1_ADDR | I2C_SR1_ADD10))
 80022fa:	f015 0f0a 	tst.w	r5, #10
    (void)dp->SR2;
 80022fe:	bf18      	it	ne
 8002300:	69a3      	ldrne	r3, [r4, #24]
  OSAL_IRQ_PROLOGUE();

  i2c_lld_serve_event_interrupt(&I2CD1);

  OSAL_IRQ_EPILOGUE();
}
 8002302:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}

  OSAL_IRQ_PROLOGUE();

  i2c_lld_serve_event_interrupt(&I2CD1);

  OSAL_IRQ_EPILOGUE();
 8002306:	f7ff be8b 	b.w	8002020 <_port_irq_epilogue>
  uint32_t event = dp->SR1;

  /* Interrupts are disabled just before dmaStreamEnable() because there
     is no need of interrupts until next transaction begin. All the work is
     done by the DMA.*/
  switch (I2C_EV_MASK & (event | (regSR2 << 16))) {
 800230a:	2182      	movs	r1, #130	; 0x82
 800230c:	f2c0 0107 	movt	r1, #7
 8002310:	428a      	cmp	r2, r1
 8002312:	d014      	beq.n	800233e <VectorBC+0x9e>
 8002314:	2184      	movs	r1, #132	; 0x84
 8002316:	f2c0 0107 	movt	r1, #7
 800231a:	428a      	cmp	r2, r1
 800231c:	d1ed      	bne.n	80022fa <VectorBC+0x5a>
    dp->CR2 &= ~I2C_CR2_ITEVTEN;
    dmaStreamEnable(i2cp->dmatx);
    break;
  case I2C_EV8_2_MASTER_BYTE_TRANSMITTED:
    /* Catches BTF event after the end of transmission.*/
    if (dmaStreamGetTransactionSize(i2cp->dmarx) > 0) {
 800231e:	6ada      	ldr	r2, [r3, #44]	; 0x2c
 8002320:	6852      	ldr	r2, [r2, #4]
 8002322:	6852      	ldr	r2, [r2, #4]
 8002324:	b33a      	cbz	r2, 8002376 <VectorBC+0xd6>
      /* Starts "read after write" operation, LSB = 1 -> receive.*/
      i2cp->addr |= 0x01;
 8002326:	8c19      	ldrh	r1, [r3, #32]
      dp->CR1 |= I2C_CR1_START | I2C_CR1_ACK;
 8002328:	6822      	ldr	r2, [r4, #0]
    break;
  case I2C_EV8_2_MASTER_BYTE_TRANSMITTED:
    /* Catches BTF event after the end of transmission.*/
    if (dmaStreamGetTransactionSize(i2cp->dmarx) > 0) {
      /* Starts "read after write" operation, LSB = 1 -> receive.*/
      i2cp->addr |= 0x01;
 800232a:	f041 0101 	orr.w	r1, r1, #1
      dp->CR1 |= I2C_CR1_START | I2C_CR1_ACK;
 800232e:	f442 62a0 	orr.w	r2, r2, #1280	; 0x500
    break;
  case I2C_EV8_2_MASTER_BYTE_TRANSMITTED:
    /* Catches BTF event after the end of transmission.*/
    if (dmaStreamGetTransactionSize(i2cp->dmarx) > 0) {
      /* Starts "read after write" operation, LSB = 1 -> receive.*/
      i2cp->addr |= 0x01;
 8002332:	8419      	strh	r1, [r3, #32]
      dp->CR1 |= I2C_CR1_START | I2C_CR1_ACK;
 8002334:	6022      	str	r2, [r4, #0]
  OSAL_IRQ_PROLOGUE();

  i2c_lld_serve_event_interrupt(&I2CD1);

  OSAL_IRQ_EPILOGUE();
}
 8002336:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}

  OSAL_IRQ_PROLOGUE();

  i2c_lld_serve_event_interrupt(&I2CD1);

  OSAL_IRQ_EPILOGUE();
 800233a:	f7ff be71 	b.w	8002020 <_port_irq_epilogue>
    dp->CR2 |= I2C_CR2_LAST;                 /* Needed in receiver mode. */
    if (dmaStreamGetTransactionSize(i2cp->dmarx) < 2)
      dp->CR1 &= ~I2C_CR1_ACK;
    break;
  case I2C_EV6_MASTER_TRA_MODE_SELECTED:
    dp->CR2 &= ~I2C_CR2_ITEVTEN;
 800233e:	6862      	ldr	r2, [r4, #4]
    dmaStreamEnable(i2cp->dmatx);
 8002340:	6b1b      	ldr	r3, [r3, #48]	; 0x30
    dp->CR2 |= I2C_CR2_LAST;                 /* Needed in receiver mode. */
    if (dmaStreamGetTransactionSize(i2cp->dmarx) < 2)
      dp->CR1 &= ~I2C_CR1_ACK;
    break;
  case I2C_EV6_MASTER_TRA_MODE_SELECTED:
    dp->CR2 &= ~I2C_CR2_ITEVTEN;
 8002342:	f422 7200 	bic.w	r2, r2, #512	; 0x200
    dmaStreamEnable(i2cp->dmatx);
 8002346:	685b      	ldr	r3, [r3, #4]
    dp->CR2 |= I2C_CR2_LAST;                 /* Needed in receiver mode. */
    if (dmaStreamGetTransactionSize(i2cp->dmarx) < 2)
      dp->CR1 &= ~I2C_CR1_ACK;
    break;
  case I2C_EV6_MASTER_TRA_MODE_SELECTED:
    dp->CR2 &= ~I2C_CR2_ITEVTEN;
 8002348:	6062      	str	r2, [r4, #4]
    dmaStreamEnable(i2cp->dmatx);
 800234a:	681a      	ldr	r2, [r3, #0]
 800234c:	f042 0201 	orr.w	r2, r2, #1
 8002350:	601a      	str	r2, [r3, #0]
 8002352:	e7d2      	b.n	80022fa <VectorBC+0x5a>
  /* Interrupts are disabled just before dmaStreamEnable() because there
     is no need of interrupts until next transaction begin. All the work is
     done by the DMA.*/
  switch (I2C_EV_MASK & (event | (regSR2 << 16))) {
  case I2C_EV5_MASTER_MODE_SELECT:
    if ((i2cp->addr >> 8) > 0) { 
 8002354:	8c1b      	ldrh	r3, [r3, #32]
 8002356:	0a1a      	lsrs	r2, r3, #8
 8002358:	d00b      	beq.n	8002372 <VectorBC+0xd2>
      /* 10-bit address: 1 1 1 1 0 X X R/W */
      dp->DR = 0xF0 | (0x6 & (i2cp->addr >> 8)) | (0x1 & i2cp->addr);
 800235a:	f003 0301 	and.w	r3, r3, #1
 800235e:	f043 03f0 	orr.w	r3, r3, #240	; 0xf0
 8002362:	f002 0206 	and.w	r2, r2, #6
 8002366:	431a      	orrs	r2, r3
 8002368:	6122      	str	r2, [r4, #16]
 800236a:	e7c6      	b.n	80022fa <VectorBC+0x5a>
      dp->DR = i2cp->addr;
    }
    break;
  case I2C_EV9_MASTER_ADD10:
    /* Set second addr byte (10-bit addressing)*/
    dp->DR = (0xFF & (i2cp->addr >> 1));
 800236c:	8c1b      	ldrh	r3, [r3, #32]
 800236e:	f3c3 0347 	ubfx	r3, r3, #1, #8
 8002372:	6123      	str	r3, [r4, #16]
 8002374:	e7c1      	b.n	80022fa <VectorBC+0x5a>
      /* Starts "read after write" operation, LSB = 1 -> receive.*/
      i2cp->addr |= 0x01;
      dp->CR1 |= I2C_CR1_START | I2C_CR1_ACK;
      return;
    }
    dp->CR2 &= ~I2C_CR2_ITEVTEN;
 8002376:	6861      	ldr	r1, [r4, #4]
  \details Assigns the given value to the Base Priority register.
  \param [in]    basePri  Base Priority value to set
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __set_BASEPRI(uint32_t value)
{
  __ASM volatile ("MSR basepri, %0" : : "r" (value) : "memory");
 8002378:	2220      	movs	r2, #32
 800237a:	f421 7100 	bic.w	r1, r1, #512	; 0x200
 800237e:	6061      	str	r1, [r4, #4]
    dp->CR1 |= I2C_CR1_STOP;
 8002380:	6821      	ldr	r1, [r4, #0]
 8002382:	f441 7100 	orr.w	r1, r1, #512	; 0x200
 8002386:	6021      	str	r1, [r4, #0]
 8002388:	f382 8811 	msr	BASEPRI, r2
 *
 * @iclass
 */
void chThdResumeI(thread_reference_t *trp, msg_t msg) {

  if (*trp != NULL) {
 800238c:	69d8      	ldr	r0, [r3, #28]
 800238e:	f640 2358 	movw	r3, #2648	; 0xa58
 8002392:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8002396:	b120      	cbz	r0, 80023a2 <VectorBC+0x102>
    thread_t *tp = *trp;

    chDbgAssert(tp->state == CH_STATE_SUSPENDED, "not CH_STATE_SUSPENDED");

    *trp = NULL;
 8002398:	2200      	movs	r2, #0
    tp->u.rdymsg = msg;
 800239a:	6242      	str	r2, [r0, #36]	; 0x24
  if (*trp != NULL) {
    thread_t *tp = *trp;

    chDbgAssert(tp->state == CH_STATE_SUSPENDED, "not CH_STATE_SUSPENDED");

    *trp = NULL;
 800239c:	61da      	str	r2, [r3, #28]
    tp->u.rdymsg = msg;
    (void) chSchReadyI(tp);
 800239e:	f7ff ff67 	bl	8002270 <chSchReadyI>
 80023a2:	2300      	movs	r3, #0
 80023a4:	f383 8811 	msr	BASEPRI, r3
 80023a8:	e7a7      	b.n	80022fa <VectorBC+0x5a>
  case I2C_EV6_MASTER_REC_MODE_SELECTED:
    dp->CR2 &= ~I2C_CR2_ITEVTEN;
    dmaStreamEnable(i2cp->dmarx);
    dp->CR2 |= I2C_CR2_LAST;                 /* Needed in receiver mode. */
    if (dmaStreamGetTransactionSize(i2cp->dmarx) < 2)
      dp->CR1 &= ~I2C_CR1_ACK;
 80023aa:	6823      	ldr	r3, [r4, #0]
 80023ac:	f423 6380 	bic.w	r3, r3, #1024	; 0x400
 80023b0:	6023      	str	r3, [r4, #0]
 80023b2:	e7a2      	b.n	80022fa <VectorBC+0x5a>
 80023b4:	f3af 8000 	nop.w
 80023b8:	f3af 8000 	nop.w
 80023bc:	f3af 8000 	nop.w

080023c0 <chEvtBroadcastFlagsI>:
 * @param[in] esp       pointer to the @p event_source_t structure
 * @param[in] flags     the flags set to be added to the listener flags mask
 *
 * @iclass
 */
void chEvtBroadcastFlagsI(event_source_t *esp, eventflags_t flags) {
 80023c0:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
  event_listener_t *elp;

  chDbgCheckClassI();
  chDbgCheck(esp != NULL);

  elp = esp->next;
 80023c2:	6804      	ldr	r4, [r0, #0]
 * @param[in] esp       pointer to the @p event_source_t structure
 * @param[in] flags     the flags set to be added to the listener flags mask
 *
 * @iclass
 */
void chEvtBroadcastFlagsI(event_source_t *esp, eventflags_t flags) {
 80023c4:	4607      	mov	r7, r0
  chDbgCheckClassI();
  chDbgCheck(esp != NULL);

  elp = esp->next;
  /*lint -save -e9087 -e740 [11.3, 1.3] Cast required by list handling.*/
  while (elp != (event_listener_t *)esp) {
 80023c6:	42a0      	cmp	r0, r4
 * @param[in] esp       pointer to the @p event_source_t structure
 * @param[in] flags     the flags set to be added to the listener flags mask
 *
 * @iclass
 */
void chEvtBroadcastFlagsI(event_source_t *esp, eventflags_t flags) {
 80023c8:	460d      	mov	r5, r1
  chDbgCheckClassI();
  chDbgCheck(esp != NULL);

  elp = esp->next;
  /*lint -save -e9087 -e740 [11.3, 1.3] Cast required by list handling.*/
  while (elp != (event_listener_t *)esp) {
 80023ca:	d020      	beq.n	800240e <chEvtBroadcastFlagsI+0x4e>
  /* Test on the AND/OR conditions wait states.*/
  if (((tp->state == CH_STATE_WTOREVT) &&
       ((tp->epending & tp->u.ewmask) != (eventmask_t)0)) ||
      ((tp->state == CH_STATE_WTANDEVT) &&
       ((tp->epending & tp->u.ewmask) == tp->u.ewmask))) {
    tp->u.rdymsg = MSG_OK;
 80023cc:	2600      	movs	r6, #0
 80023ce:	e002      	b.n	80023d6 <chEvtBroadcastFlagsI+0x16>
       source does not emit any flag.*/
    if ((flags == (eventflags_t)0) ||
        ((elp->flags & elp->wflags) != (eventflags_t)0)) {
      chEvtSignalI(elp->listener, elp->events);
    }
    elp = elp->next;
 80023d0:	6824      	ldr	r4, [r4, #0]
  chDbgCheckClassI();
  chDbgCheck(esp != NULL);

  elp = esp->next;
  /*lint -save -e9087 -e740 [11.3, 1.3] Cast required by list handling.*/
  while (elp != (event_listener_t *)esp) {
 80023d2:	42a7      	cmp	r7, r4
 80023d4:	d01b      	beq.n	800240e <chEvtBroadcastFlagsI+0x4e>
  /*lint -restore*/
    elp->flags |= flags;
 80023d6:	68e3      	ldr	r3, [r4, #12]
 80023d8:	432b      	orrs	r3, r5
 80023da:	60e3      	str	r3, [r4, #12]
    /* When flags == 0 the thread will always be signaled because the
       source does not emit any flag.*/
    if ((flags == (eventflags_t)0) ||
 80023dc:	b115      	cbz	r5, 80023e4 <chEvtBroadcastFlagsI+0x24>
        ((elp->flags & elp->wflags) != (eventflags_t)0)) {
 80023de:	6922      	ldr	r2, [r4, #16]
  while (elp != (event_listener_t *)esp) {
  /*lint -restore*/
    elp->flags |= flags;
    /* When flags == 0 the thread will always be signaled because the
       source does not emit any flag.*/
    if ((flags == (eventflags_t)0) ||
 80023e0:	4213      	tst	r3, r2
 80023e2:	d0f5      	beq.n	80023d0 <chEvtBroadcastFlagsI+0x10>
        ((elp->flags & elp->wflags) != (eventflags_t)0)) {
      chEvtSignalI(elp->listener, elp->events);
 80023e4:	6860      	ldr	r0, [r4, #4]
void chEvtSignalI(thread_t *tp, eventmask_t events) {

  chDbgCheckClassI();
  chDbgCheck(tp != NULL);

  tp->epending |= events;
 80023e6:	68a2      	ldr	r2, [r4, #8]
 80023e8:	6b41      	ldr	r1, [r0, #52]	; 0x34
  /* Test on the AND/OR conditions wait states.*/
  if (((tp->state == CH_STATE_WTOREVT) &&
 80023ea:	f890 3020 	ldrb.w	r3, [r0, #32]
void chEvtSignalI(thread_t *tp, eventmask_t events) {

  chDbgCheckClassI();
  chDbgCheck(tp != NULL);

  tp->epending |= events;
 80023ee:	430a      	orrs	r2, r1
  /* Test on the AND/OR conditions wait states.*/
  if (((tp->state == CH_STATE_WTOREVT) &&
 80023f0:	2b0a      	cmp	r3, #10
void chEvtSignalI(thread_t *tp, eventmask_t events) {

  chDbgCheckClassI();
  chDbgCheck(tp != NULL);

  tp->epending |= events;
 80023f2:	6342      	str	r2, [r0, #52]	; 0x34
  /* Test on the AND/OR conditions wait states.*/
  if (((tp->state == CH_STATE_WTOREVT) &&
 80023f4:	d00c      	beq.n	8002410 <chEvtBroadcastFlagsI+0x50>
       ((tp->epending & tp->u.ewmask) != (eventmask_t)0)) ||
 80023f6:	2b0b      	cmp	r3, #11
 80023f8:	d1ea      	bne.n	80023d0 <chEvtBroadcastFlagsI+0x10>
      ((tp->state == CH_STATE_WTANDEVT) &&
       ((tp->epending & tp->u.ewmask) == tp->u.ewmask))) {
 80023fa:	6a43      	ldr	r3, [r0, #36]	; 0x24
 80023fc:	401a      	ands	r2, r3

  tp->epending |= events;
  /* Test on the AND/OR conditions wait states.*/
  if (((tp->state == CH_STATE_WTOREVT) &&
       ((tp->epending & tp->u.ewmask) != (eventmask_t)0)) ||
      ((tp->state == CH_STATE_WTANDEVT) &&
 80023fe:	4293      	cmp	r3, r2
 8002400:	d1e6      	bne.n	80023d0 <chEvtBroadcastFlagsI+0x10>
       ((tp->epending & tp->u.ewmask) == tp->u.ewmask))) {
    tp->u.rdymsg = MSG_OK;
 8002402:	6246      	str	r6, [r0, #36]	; 0x24
    (void) chSchReadyI(tp);
 8002404:	f7ff ff34 	bl	8002270 <chSchReadyI>
       source does not emit any flag.*/
    if ((flags == (eventflags_t)0) ||
        ((elp->flags & elp->wflags) != (eventflags_t)0)) {
      chEvtSignalI(elp->listener, elp->events);
    }
    elp = elp->next;
 8002408:	6824      	ldr	r4, [r4, #0]
  chDbgCheckClassI();
  chDbgCheck(esp != NULL);

  elp = esp->next;
  /*lint -save -e9087 -e740 [11.3, 1.3] Cast required by list handling.*/
  while (elp != (event_listener_t *)esp) {
 800240a:	42a7      	cmp	r7, r4
 800240c:	d1e3      	bne.n	80023d6 <chEvtBroadcastFlagsI+0x16>
 800240e:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
  chDbgCheck(tp != NULL);

  tp->epending |= events;
  /* Test on the AND/OR conditions wait states.*/
  if (((tp->state == CH_STATE_WTOREVT) &&
       ((tp->epending & tp->u.ewmask) != (eventmask_t)0)) ||
 8002410:	6a43      	ldr	r3, [r0, #36]	; 0x24
  chDbgCheckClassI();
  chDbgCheck(tp != NULL);

  tp->epending |= events;
  /* Test on the AND/OR conditions wait states.*/
  if (((tp->state == CH_STATE_WTOREVT) &&
 8002412:	421a      	tst	r2, r3
 8002414:	d0dc      	beq.n	80023d0 <chEvtBroadcastFlagsI+0x10>
       ((tp->epending & tp->u.ewmask) != (eventmask_t)0)) ||
      ((tp->state == CH_STATE_WTANDEVT) &&
       ((tp->epending & tp->u.ewmask) == tp->u.ewmask))) {
    tp->u.rdymsg = MSG_OK;
 8002416:	6246      	str	r6, [r0, #36]	; 0x24
    (void) chSchReadyI(tp);
 8002418:	f7ff ff2a 	bl	8002270 <chSchReadyI>
 800241c:	e7f4      	b.n	8002408 <chEvtBroadcastFlagsI+0x48>
 800241e:	bf00      	nop

08002420 <chMtxLockS>:
 *
 * @param[in] mp        pointer to the @p mutex_t structure
 *
 * @sclass
 */
void chMtxLockS(mutex_t *mp) {
 8002420:	b5f8      	push	{r3, r4, r5, r6, r7, lr}

  chDbgCheckClassS();
  chDbgCheck(mp != NULL);

  /* Is the mutex already locked? */
  if (mp->owner != NULL) {
 8002422:	6882      	ldr	r2, [r0, #8]
 * @param[in] mp        pointer to the @p mutex_t structure
 *
 * @sclass
 */
void chMtxLockS(mutex_t *mp) {
  thread_t *ctp = currp;
 8002424:	f640 03d8 	movw	r3, #2264	; 0x8d8
 8002428:	f2c2 0300 	movt	r3, #8192	; 0x2000
 *
 * @param[in] mp        pointer to the @p mutex_t structure
 *
 * @sclass
 */
void chMtxLockS(mutex_t *mp) {
 800242c:	4605      	mov	r5, r0
  thread_t *ctp = currp;
 800242e:	699c      	ldr	r4, [r3, #24]

  chDbgCheckClassS();
  chDbgCheck(mp != NULL);

  /* Is the mutex already locked? */
  if (mp->owner != NULL) {
 8002430:	2a00      	cmp	r2, #0
 8002432:	d055      	beq.n	80024e0 <chMtxLockS+0xc0>
         priority of the running thread requesting the mutex.*/
      thread_t *tp = mp->owner;

      /* Does the running thread have higher priority than the mutex
         owning thread? */
      while (tp->prio < ctp->prio) {
 8002434:	68a1      	ldr	r1, [r4, #8]
 8002436:	6893      	ldr	r3, [r2, #8]
 8002438:	428b      	cmp	r3, r1
 800243a:	d207      	bcs.n	800244c <chMtxLockS+0x2c>
        /* Make priority of thread tp match the running thread's priority.*/
        tp->prio = ctp->prio;

        /* The following states need priority queues reordering.*/
        switch (tp->state) {
 800243c:	f892 3020 	ldrb.w	r3, [r2, #32]

      /* Does the running thread have higher priority than the mutex
         owning thread? */
      while (tp->prio < ctp->prio) {
        /* Make priority of thread tp match the running thread's priority.*/
        tp->prio = ctp->prio;
 8002440:	6091      	str	r1, [r2, #8]

        /* The following states need priority queues reordering.*/
        switch (tp->state) {
 8002442:	2b06      	cmp	r3, #6
 8002444:	d033      	beq.n	80024ae <chMtxLockS+0x8e>
 8002446:	2b07      	cmp	r3, #7
 8002448:	d01d      	beq.n	8002486 <chMtxLockS+0x66>
 800244a:	b19b      	cbz	r3, 8002474 <chMtxLockS+0x54>
  return tp;
}

static inline void queue_prio_insert(thread_t *tp, threads_queue_t *tqp) {

  thread_t *cp = (thread_t *)tqp;
 800244c:	462b      	mov	r3, r5
 800244e:	e003      	b.n	8002458 <chMtxLockS+0x38>
  do {
    cp = cp->queue.next;
  } while ((cp != (thread_t *)tqp) && (cp->prio >= tp->prio));
 8002450:	6899      	ldr	r1, [r3, #8]
 8002452:	68a2      	ldr	r2, [r4, #8]
 8002454:	4291      	cmp	r1, r2
 8002456:	d302      	bcc.n	800245e <chMtxLockS+0x3e>

static inline void queue_prio_insert(thread_t *tp, threads_queue_t *tqp) {

  thread_t *cp = (thread_t *)tqp;
  do {
    cp = cp->queue.next;
 8002458:	681b      	ldr	r3, [r3, #0]
  } while ((cp != (thread_t *)tqp) && (cp->prio >= tp->prio));
 800245a:	429d      	cmp	r5, r3
 800245c:	d1f8      	bne.n	8002450 <chMtxLockS+0x30>
  tp->queue.next             = cp;
  tp->queue.prev             = cp->queue.prev;
 800245e:	685a      	ldr	r2, [r3, #4]

  thread_t *cp = (thread_t *)tqp;
  do {
    cp = cp->queue.next;
  } while ((cp != (thread_t *)tqp) && (cp->prio >= tp->prio));
  tp->queue.next             = cp;
 8002460:	6023      	str	r3, [r4, #0]
  tp->queue.prev             = cp->queue.prev;
 8002462:	6062      	str	r2, [r4, #4]
  tp->queue.prev->queue.next = tp;
 8002464:	6014      	str	r4, [r2, #0]
  cp->queue.prev             = tp;
 8002466:	605c      	str	r4, [r3, #4]
        break;
      }

      /* Sleep on the mutex.*/
      queue_prio_insert(ctp, &mp->queue);
      ctp->u.wtmtxp = mp;
 8002468:	6265      	str	r5, [r4, #36]	; 0x24
      chSchGoSleepS(CH_STATE_WTMTX);
 800246a:	2006      	movs	r0, #6
    /* It was not owned, inserted in the owned mutexes list.*/
    mp->owner = ctp;
    mp->next = ctp->mtxlist;
    ctp->mtxlist = mp;
  }
}
 800246c:	e8bd 40f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, lr}
      }

      /* Sleep on the mutex.*/
      queue_prio_insert(ctp, &mp->queue);
      ctp->u.wtmtxp = mp;
      chSchGoSleepS(CH_STATE_WTMTX);
 8002470:	f7ff bee6 	b.w	8002240 <chSchGoSleepS>
  return tp;
}

static inline thread_t *queue_dequeue(thread_t *tp) {

  tp->queue.prev->queue.next = tp->queue.next;
 8002474:	e892 000a 	ldmia.w	r2, {r1, r3}
 8002478:	6019      	str	r1, [r3, #0]
#if CH_DBG_ENABLE_ASSERTS == TRUE
          /* Prevents an assertion in chSchReadyI().*/
          tp->state = CH_STATE_CURRENT;
#endif
          /* Re-enqueues tp with its new priority on the ready list.*/
          (void) chSchReadyI(queue_dequeue(tp));
 800247a:	4610      	mov	r0, r2
  tp->queue.next->queue.prev = tp->queue.prev;
 800247c:	6812      	ldr	r2, [r2, #0]
 800247e:	6053      	str	r3, [r2, #4]
 8002480:	f7ff fef6 	bl	8002270 <chSchReadyI>
 8002484:	e7e2      	b.n	800244c <chMtxLockS+0x2c>
  return tp;
}

static inline thread_t *queue_dequeue(thread_t *tp) {

  tp->queue.prev->queue.next = tp->queue.next;
 8002486:	6813      	ldr	r3, [r2, #0]
 8002488:	6850      	ldr	r0, [r2, #4]
#endif
#if (CH_CFG_USE_MESSAGES == TRUE) && (CH_CFG_USE_MESSAGES_PRIORITY == TRUE)
        case CH_STATE_SNDMSGQ:
#endif
          /* Re-enqueues tp with its new priority on the queue.*/
          queue_prio_insert(queue_dequeue(tp), &tp->u.wtmtxp->queue);
 800248a:	6a56      	ldr	r6, [r2, #36]	; 0x24
 800248c:	6003      	str	r3, [r0, #0]
  tp->queue.next->queue.prev = tp->queue.prev;
 800248e:	6817      	ldr	r7, [r2, #0]
  return tp;
}

static inline void queue_prio_insert(thread_t *tp, threads_queue_t *tqp) {

  thread_t *cp = (thread_t *)tqp;
 8002490:	4633      	mov	r3, r6
}

static inline thread_t *queue_dequeue(thread_t *tp) {

  tp->queue.prev->queue.next = tp->queue.next;
  tp->queue.next->queue.prev = tp->queue.prev;
 8002492:	6078      	str	r0, [r7, #4]
 8002494:	e002      	b.n	800249c <chMtxLockS+0x7c>
static inline void queue_prio_insert(thread_t *tp, threads_queue_t *tqp) {

  thread_t *cp = (thread_t *)tqp;
  do {
    cp = cp->queue.next;
  } while ((cp != (thread_t *)tqp) && (cp->prio >= tp->prio));
 8002496:	6898      	ldr	r0, [r3, #8]
 8002498:	4288      	cmp	r0, r1
 800249a:	d302      	bcc.n	80024a2 <chMtxLockS+0x82>

static inline void queue_prio_insert(thread_t *tp, threads_queue_t *tqp) {

  thread_t *cp = (thread_t *)tqp;
  do {
    cp = cp->queue.next;
 800249c:	681b      	ldr	r3, [r3, #0]
  } while ((cp != (thread_t *)tqp) && (cp->prio >= tp->prio));
 800249e:	429e      	cmp	r6, r3
 80024a0:	d1f9      	bne.n	8002496 <chMtxLockS+0x76>
  tp->queue.next             = cp;
  tp->queue.prev             = cp->queue.prev;
 80024a2:	6859      	ldr	r1, [r3, #4]

  thread_t *cp = (thread_t *)tqp;
  do {
    cp = cp->queue.next;
  } while ((cp != (thread_t *)tqp) && (cp->prio >= tp->prio));
  tp->queue.next             = cp;
 80024a4:	6013      	str	r3, [r2, #0]
  tp->queue.prev             = cp->queue.prev;
 80024a6:	6051      	str	r1, [r2, #4]
  tp->queue.prev->queue.next = tp;
 80024a8:	600a      	str	r2, [r1, #0]
  cp->queue.prev             = tp;
 80024aa:	605a      	str	r2, [r3, #4]
 80024ac:	e7ce      	b.n	800244c <chMtxLockS+0x2c>
  return tp;
}

static inline thread_t *queue_dequeue(thread_t *tp) {

  tp->queue.prev->queue.next = tp->queue.next;
 80024ae:	6813      	ldr	r3, [r2, #0]
 80024b0:	6850      	ldr	r0, [r2, #4]

        /* The following states need priority queues reordering.*/
        switch (tp->state) {
        case CH_STATE_WTMTX:
          /* Re-enqueues the mutex owner with its new priority.*/
          queue_prio_insert(queue_dequeue(tp), &tp->u.wtmtxp->queue);
 80024b2:	6a56      	ldr	r6, [r2, #36]	; 0x24
 80024b4:	6003      	str	r3, [r0, #0]
  tp->queue.next->queue.prev = tp->queue.prev;
 80024b6:	6817      	ldr	r7, [r2, #0]
  return tp;
}

static inline void queue_prio_insert(thread_t *tp, threads_queue_t *tqp) {

  thread_t *cp = (thread_t *)tqp;
 80024b8:	4633      	mov	r3, r6
}

static inline thread_t *queue_dequeue(thread_t *tp) {

  tp->queue.prev->queue.next = tp->queue.next;
  tp->queue.next->queue.prev = tp->queue.prev;
 80024ba:	6078      	str	r0, [r7, #4]
 80024bc:	e002      	b.n	80024c4 <chMtxLockS+0xa4>
static inline void queue_prio_insert(thread_t *tp, threads_queue_t *tqp) {

  thread_t *cp = (thread_t *)tqp;
  do {
    cp = cp->queue.next;
  } while ((cp != (thread_t *)tqp) && (cp->prio >= tp->prio));
 80024be:	6898      	ldr	r0, [r3, #8]
 80024c0:	4288      	cmp	r0, r1
 80024c2:	d302      	bcc.n	80024ca <chMtxLockS+0xaa>

static inline void queue_prio_insert(thread_t *tp, threads_queue_t *tqp) {

  thread_t *cp = (thread_t *)tqp;
  do {
    cp = cp->queue.next;
 80024c4:	681b      	ldr	r3, [r3, #0]
  } while ((cp != (thread_t *)tqp) && (cp->prio >= tp->prio));
 80024c6:	429e      	cmp	r6, r3
 80024c8:	d1f9      	bne.n	80024be <chMtxLockS+0x9e>
  tp->queue.next             = cp;
  tp->queue.prev             = cp->queue.prev;
 80024ca:	6859      	ldr	r1, [r3, #4]

  thread_t *cp = (thread_t *)tqp;
  do {
    cp = cp->queue.next;
  } while ((cp != (thread_t *)tqp) && (cp->prio >= tp->prio));
  tp->queue.next             = cp;
 80024cc:	6013      	str	r3, [r2, #0]
  tp->queue.prev             = cp->queue.prev;
 80024ce:	6051      	str	r1, [r2, #4]
  tp->queue.prev->queue.next = tp;
 80024d0:	600a      	str	r2, [r1, #0]
  cp->queue.prev             = tp;
 80024d2:	605a      	str	r2, [r3, #4]
          tp = tp->u.wtmtxp->owner;
 80024d4:	68b2      	ldr	r2, [r6, #8]
         priority of the running thread requesting the mutex.*/
      thread_t *tp = mp->owner;

      /* Does the running thread have higher priority than the mutex
         owning thread? */
      while (tp->prio < ctp->prio) {
 80024d6:	68a1      	ldr	r1, [r4, #8]
 80024d8:	6893      	ldr	r3, [r2, #8]
 80024da:	428b      	cmp	r3, r1
 80024dc:	d3ae      	bcc.n	800243c <chMtxLockS+0x1c>
 80024de:	e7b5      	b.n	800244c <chMtxLockS+0x2c>

    mp->cnt++;
#endif
    /* It was not owned, inserted in the owned mutexes list.*/
    mp->owner = ctp;
    mp->next = ctp->mtxlist;
 80024e0:	6ba3      	ldr	r3, [r4, #56]	; 0x38
    chDbgAssert(mp->cnt == (cnt_t)0, "counter is not zero");

    mp->cnt++;
#endif
    /* It was not owned, inserted in the owned mutexes list.*/
    mp->owner = ctp;
 80024e2:	6084      	str	r4, [r0, #8]
    mp->next = ctp->mtxlist;
 80024e4:	60c3      	str	r3, [r0, #12]
    ctp->mtxlist = mp;
 80024e6:	63a0      	str	r0, [r4, #56]	; 0x38
 80024e8:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
 80024ea:	bf00      	nop
 80024ec:	f3af 8000 	nop.w

080024f0 <BusFault_Handler>:
 *
 * @notapi
 */
/*lint -save -e9075 [8.4] All symbols are invoked from asm context.*/
__attribute__((weak))
void _unhandled_exception(void) {
 80024f0:	e7fe      	b.n	80024f0 <BusFault_Handler>
 80024f2:	bf00      	nop
 80024f4:	f3af 8000 	nop.w
 80024f8:	f3af 8000 	nop.w
 80024fc:	f3af 8000 	nop.w

08002500 <main>:
 * @notapi
 */
void hal_lld_init(void) {

  /* Reset of all peripherals.*/
  rccResetAPB1(0xFFFFFFFF);
 8002500:	f44f 5380 	mov.w	r3, #4096	; 0x1000
 8002504:	f2c4 0302 	movt	r3, #16386	; 0x4002
 8002508:	2200      	movs	r2, #0
 800250a:	f04f 31ff 	mov.w	r1, #4294967295
 800250e:	6918      	ldr	r0, [r3, #16]


/*
 * Application entry point.
 */
int main(void) {
 8002510:	e92d 4880 	stmdb	sp!, {r7, fp, lr}
 8002514:	6119      	str	r1, [r3, #16]
 8002516:	611a      	str	r2, [r3, #16]
  rccResetAPB2(0xFFFFFFFF);
 8002518:	68d8      	ldr	r0, [r3, #12]
 800251a:	60d9      	str	r1, [r3, #12]
 800251c:	60da      	str	r2, [r3, #12]

  /* PWR and BD clocks enabled.*/
  rccEnablePWRInterface(FALSE);
 800251e:	69d8      	ldr	r0, [r3, #28]
 *          of the whole BKP domain.
 */
static void hal_lld_backup_domain_init(void) {

  /* Backup domain access enabled and left open.*/
  PWR->CR |= PWR_CR_DBP;
 8002520:	f44f 41e0 	mov.w	r1, #28672	; 0x7000
  /* Reset of all peripherals.*/
  rccResetAPB1(0xFFFFFFFF);
  rccResetAPB2(0xFFFFFFFF);

  /* PWR and BD clocks enabled.*/
  rccEnablePWRInterface(FALSE);
 8002524:	f040 5080 	orr.w	r0, r0, #268435456	; 0x10000000
 8002528:	61d8      	str	r0, [r3, #28]
  rccEnableBKPInterface(FALSE);
 800252a:	69d8      	ldr	r0, [r3, #28]
 *          of the whole BKP domain.
 */
static void hal_lld_backup_domain_init(void) {

  /* Backup domain access enabled and left open.*/
  PWR->CR |= PWR_CR_DBP;
 800252c:	f2c4 0100 	movt	r1, #16384	; 0x4000
  rccResetAPB1(0xFFFFFFFF);
  rccResetAPB2(0xFFFFFFFF);

  /* PWR and BD clocks enabled.*/
  rccEnablePWRInterface(FALSE);
  rccEnableBKPInterface(FALSE);
 8002530:	f040 6000 	orr.w	r0, r0, #134217728	; 0x8000000
 8002534:	61d8      	str	r0, [r3, #28]
 *          of the whole BKP domain.
 */
static void hal_lld_backup_domain_init(void) {

  /* Backup domain access enabled and left open.*/
  PWR->CR |= PWR_CR_DBP;
 8002536:	680e      	ldr	r6, [r1, #0]
 * @init
 */
void dmaInit(void) {
  int i;

  dma_streams_mask = 0U;
 8002538:	f640 05cc 	movw	r5, #2252	; 0x8cc
 800253c:	f446 7680 	orr.w	r6, r6, #256	; 0x100
 8002540:	f2c2 0500 	movt	r5, #8192	; 0x2000
 8002544:	f642 6410 	movw	r4, #11792	; 0x2e10
 8002548:	f640 0018 	movw	r0, #2072	; 0x818
 800254c:	600e      	str	r6, [r1, #0]
 800254e:	b083      	sub	sp, #12
 8002550:	4613      	mov	r3, r2
 8002552:	4611      	mov	r1, r2
 8002554:	602a      	str	r2, [r5, #0]
 8002556:	f6c0 0400 	movt	r4, #2048	; 0x800
 800255a:	f2c2 0000 	movt	r0, #8192	; 0x2000
 800255e:	1865      	adds	r5, r4, r1
  for (i = 0; i < STM32_DMA_STREAMS; i++) {
    _stm32_dma_streams[i].channel->CCR = 0U;
 8002560:	686d      	ldr	r5, [r5, #4]
 8002562:	3114      	adds	r1, #20
 */
void dmaInit(void) {
  int i;

  dma_streams_mask = 0U;
  for (i = 0; i < STM32_DMA_STREAMS; i++) {
 8002564:	298c      	cmp	r1, #140	; 0x8c
    _stm32_dma_streams[i].channel->CCR = 0U;
 8002566:	602a      	str	r2, [r5, #0]
    _stm32_dma_isr_redir[i].dma_func = NULL;
 8002568:	50c2      	str	r2, [r0, r3]
void dmaInit(void) {
  int i;

  dma_streams_mask = 0U;
  for (i = 0; i < STM32_DMA_STREAMS; i++) {
    _stm32_dma_streams[i].channel->CCR = 0U;
 800256a:	f04f 0500 	mov.w	r5, #0
 800256e:	f103 0308 	add.w	r3, r3, #8
 */
void dmaInit(void) {
  int i;

  dma_streams_mask = 0U;
  for (i = 0; i < STM32_DMA_STREAMS; i++) {
 8002572:	d1f4      	bne.n	800255e <main+0x5e>
    _stm32_dma_streams[i].channel->CCR = 0U;
    _stm32_dma_isr_redir[i].dma_func = NULL;
  }
  DMA1->IFCR = 0xFFFFFFFFU;
 8002574:	462b      	mov	r3, r5
 8002576:	f04f 36ff 	mov.w	r6, #4294967295
 800257a:	f2c4 0302 	movt	r3, #16386	; 0x4002
void _pal_lld_init(const PALConfig *config) {

  /*
   * Enables the GPIO related clocks.
   */
  rccEnableAPB2(APB2_EN_MASK, FALSE);
 800257e:	f44f 5980 	mov.w	r9, #4096	; 0x1000
 8002582:	605e      	str	r6, [r3, #4]
 8002584:	f2c4 0902 	movt	r9, #16386	; 0x4002
 8002588:	f8d9 3018 	ldr.w	r3, [r9, #24]
   */
  GPIOA->ODR = config->PAData.odr;
  GPIOA->CRH = config->PAData.crh;
  GPIOA->CRL = config->PAData.crl;
  GPIOB->ODR = config->PBData.odr;
  GPIOB->CRH = config->PBData.crh;
 800258c:	f648 0b88 	movw	fp, #34952	; 0x8888
  rccEnableAPB2(APB2_EN_MASK, FALSE);

  /*
   * Initial GPIO setup.
   */
  GPIOA->ODR = config->PAData.odr;
 8002590:	f44f 6000 	mov.w	r0, #2048	; 0x800
  GPIOA->CRH = config->PAData.crh;
 8002594:	f248 4ab8 	movw	sl, #33976	; 0x84b8
  GPIOA->CRL = config->PAData.crl;
 8002598:	f644 3e84 	movw	lr, #19332	; 0x4b84
  GPIOB->ODR = config->PBData.odr;
 800259c:	f44f 6140 	mov.w	r1, #3072	; 0xc00
  GPIOC->ODR = config->PCData.odr;
  GPIOC->CRH = config->PCData.crh;
  GPIOC->CRL = config->PCData.crl;
  GPIOD->ODR = config->PDData.odr;
  GPIOD->CRH = config->PDData.crh;
  GPIOD->CRL = config->PDData.crl;
 80025a0:	f648 0444 	movw	r4, #34884	; 0x8844
  rccEnableAPB2(APB2_EN_MASK, FALSE);

  /*
   * Initial GPIO setup.
   */
  GPIOA->ODR = config->PAData.odr;
 80025a4:	f2c4 0001 	movt	r0, #16385	; 0x4001
  GPIOA->CRH = config->PAData.crh;
  GPIOA->CRL = config->PAData.crl;
  GPIOB->ODR = config->PBData.odr;
 80025a8:	f2c4 0101 	movt	r1, #16385	; 0x4001
  GPIOB->CRH = config->PBData.crh;
  GPIOB->CRL = config->PBData.crl;
 80025ac:	46dc      	mov	ip, fp
void _pal_lld_init(const PALConfig *config) {

  /*
   * Enables the GPIO related clocks.
   */
  rccEnableAPB2(APB2_EN_MASK, FALSE);
 80025ae:	f043 037d 	orr.w	r3, r3, #125	; 0x7d

  /*
   * Initial GPIO setup.
   */
  GPIOA->ODR = config->PAData.odr;
  GPIOA->CRH = config->PAData.crh;
 80025b2:	f6c8 0a88 	movt	sl, #34952	; 0x8888
  GPIOA->CRL = config->PAData.crl;
 80025b6:	f2cb 4eb3 	movt	lr, #46259	; 0xb4b3
  GPIOB->ODR = config->PBData.odr;
  GPIOB->CRH = config->PBData.crh;
 80025ba:	f2cb 4bb3 	movt	fp, #46259	; 0xb4b3
  GPIOC->ODR = config->PCData.odr;
  GPIOC->CRH = config->PCData.crh;
  GPIOC->CRL = config->PCData.crl;
  GPIOD->ODR = config->PDData.odr;
  GPIOD->CRH = config->PDData.crh;
  GPIOD->CRL = config->PDData.crl;
 80025be:	f6c8 0488 	movt	r4, #34952	; 0x8888
  GPIOA->CRH = config->PAData.crh;
  GPIOA->CRL = config->PAData.crl;
  GPIOB->ODR = config->PBData.odr;
  GPIOB->CRH = config->PBData.crh;
  GPIOB->CRL = config->PBData.crl;
  GPIOC->ODR = config->PCData.odr;
 80025c2:	f44f 5780 	mov.w	r7, #4096	; 0x1000
  GPIOC->CRH = config->PCData.crh;
 80025c6:	f648 0833 	movw	r8, #34867	; 0x8833
  GPIOC->CRL = config->PCData.crl;
  GPIOD->ODR = config->PDData.odr;
  GPIOD->CRH = config->PDData.crh;
  GPIOD->CRL = config->PDData.crl;
 80025ca:	9401      	str	r4, [sp, #4]
  GPIOA->CRH = config->PAData.crh;
  GPIOA->CRL = config->PAData.crl;
  GPIOB->ODR = config->PBData.odr;
  GPIOB->CRH = config->PBData.crh;
  GPIOB->CRL = config->PBData.crl;
  GPIOC->ODR = config->PCData.odr;
 80025cc:	f2c4 0701 	movt	r7, #16385	; 0x4001
void _pal_lld_init(const PALConfig *config) {

  /*
   * Enables the GPIO related clocks.
   */
  rccEnableAPB2(APB2_EN_MASK, FALSE);
 80025d0:	f8c9 3018 	str.w	r3, [r9, #24]
  GPIOA->ODR = config->PAData.odr;
  GPIOA->CRH = config->PAData.crh;
  GPIOA->CRL = config->PAData.crl;
  GPIOB->ODR = config->PBData.odr;
  GPIOB->CRH = config->PBData.crh;
  GPIOB->CRL = config->PBData.crl;
 80025d4:	f6ce 6c88 	movt	ip, #61064	; 0xee88
  rccEnableAPB2(APB2_EN_MASK, FALSE);

  /*
   * Initial GPIO setup.
   */
  GPIOA->ODR = config->PAData.odr;
 80025d8:	60c6      	str	r6, [r0, #12]
  GPIOA->CRL = config->PAData.crl;
  GPIOB->ODR = config->PBData.odr;
  GPIOB->CRH = config->PBData.crh;
  GPIOB->CRL = config->PBData.crl;
  GPIOC->ODR = config->PCData.odr;
  GPIOC->CRH = config->PCData.crh;
 80025da:	f6c8 0888 	movt	r8, #34952	; 0x8888

  /*
   * Initial GPIO setup.
   */
  GPIOA->ODR = config->PAData.odr;
  GPIOA->CRH = config->PAData.crh;
 80025de:	f8c0 a004 	str.w	sl, [r0, #4]
  GPIOA->CRL = config->PAData.crl;
 80025e2:	f8c0 e000 	str.w	lr, [r0]
  GPIOB->ODR = config->PBData.odr;
 80025e6:	60ce      	str	r6, [r1, #12]
  GPIOB->CRH = config->PBData.crh;
  GPIOB->CRL = config->PBData.crl;
  GPIOC->ODR = config->PCData.odr;
  GPIOC->CRH = config->PCData.crh;
  GPIOC->CRL = config->PCData.crl;
 80025e8:	f04f 3088 	mov.w	r0, #2290649224	; 0x88888888
   */
  GPIOA->ODR = config->PAData.odr;
  GPIOA->CRH = config->PAData.crh;
  GPIOA->CRL = config->PAData.crl;
  GPIOB->ODR = config->PBData.odr;
  GPIOB->CRH = config->PBData.crh;
 80025ec:	f8c1 b004 	str.w	fp, [r1, #4]
  GPIOB->CRL = config->PBData.crl;
  GPIOC->ODR = config->PCData.odr;
 80025f0:	f46f 7b40 	mvn.w	fp, #768	; 0x300
  GPIOA->ODR = config->PAData.odr;
  GPIOA->CRH = config->PAData.crh;
  GPIOA->CRL = config->PAData.crl;
  GPIOB->ODR = config->PBData.odr;
  GPIOB->CRH = config->PBData.crh;
  GPIOB->CRL = config->PBData.crl;
 80025f4:	f8c1 c000 	str.w	ip, [r1]
  GPIOC->ODR = config->PCData.odr;
  GPIOC->CRH = config->PCData.crh;
  GPIOC->CRL = config->PCData.crl;
  GPIOD->ODR = config->PDData.odr;
 80025f8:	f44f 52a0 	mov.w	r2, #5120	; 0x1400
  GPIOA->CRH = config->PAData.crh;
  GPIOA->CRL = config->PAData.crl;
  GPIOB->ODR = config->PBData.odr;
  GPIOB->CRH = config->PBData.crh;
  GPIOB->CRL = config->PBData.crl;
  GPIOC->ODR = config->PCData.odr;
 80025fc:	f8c7 b00c 	str.w	fp, [r7, #12]
 *
 * @init
 */
void i2cObjectInit(I2CDriver *i2cp) {

  i2cp->state  = I2C_STOP;
 8002600:	f640 2458 	movw	r4, #2648	; 0xa58
  GPIOC->CRH = config->PCData.crh;
 8002604:	f8c7 8004 	str.w	r8, [r7, #4]
  GPIOC->CRL = config->PCData.crl;
 8002608:	6038      	str	r0, [r7, #0]
  GPIOD->ODR = config->PDData.odr;
  GPIOD->CRH = config->PDData.crh;
  GPIOD->CRL = config->PDData.crl;
 800260a:	9f01      	ldr	r7, [sp, #4]
 800260c:	f2c2 0400 	movt	r4, #8192	; 0x2000

#if STM32_I2C_USE_I2C1
  i2cObjectInit(&I2CD1);
  I2CD1.thread = NULL;
  I2CD1.i2c    = I2C1;
  I2CD1.dmarx  = STM32_DMA_STREAM(STM32_I2C_I2C1_RX_DMA_STREAM);
 8002610:	f8df e690 	ldr.w	lr, [pc, #1680]	; 8002ca4 <main+0x7a4>
  GPIOB->CRH = config->PBData.crh;
  GPIOB->CRL = config->PBData.crl;
  GPIOC->ODR = config->PCData.odr;
  GPIOC->CRH = config->PCData.crh;
  GPIOC->CRL = config->PCData.crl;
  GPIOD->ODR = config->PDData.odr;
 8002614:	f2c4 0201 	movt	r2, #16385	; 0x4001
  GPIOD->CRH = config->PDData.crh;
  GPIOD->CRL = config->PDData.crl;
#if STM32_HAS_GPIOE || defined(__DOXYGEN__)
  GPIOE->ODR = config->PEData.odr;
 8002618:	f44f 53c0 	mov.w	r3, #6144	; 0x1800
  sdObjectInit(&SD1, NULL, notify1);
  SD1.usart = USART1;
#endif

#if STM32_SERIAL_USE_USART2
  sdObjectInit(&SD2, NULL, notify2);
 800261c:	f640 0a50 	movw	sl, #2128	; 0x850
  GPIOB->CRH = config->PBData.crh;
  GPIOB->CRL = config->PBData.crl;
  GPIOC->ODR = config->PCData.odr;
  GPIOC->CRH = config->PCData.crh;
  GPIOC->CRL = config->PCData.crl;
  GPIOD->ODR = config->PDData.odr;
 8002620:	60d6      	str	r6, [r2, #12]
  GPIOD->CRH = config->PDData.crh;
  GPIOD->CRL = config->PDData.crl;
#if STM32_HAS_GPIOE || defined(__DOXYGEN__)
  GPIOE->ODR = config->PEData.odr;
 8002622:	f2c4 0301 	movt	r3, #16385	; 0x4001
  GPIOB->CRL = config->PBData.crl;
  GPIOC->ODR = config->PCData.odr;
  GPIOC->CRH = config->PCData.crh;
  GPIOC->CRL = config->PCData.crl;
  GPIOD->ODR = config->PDData.odr;
  GPIOD->CRH = config->PDData.crh;
 8002626:	6050      	str	r0, [r2, #4]
 8002628:	f2c2 0a00 	movt	sl, #8192	; 0x2000
  GPIOD->CRL = config->PDData.crl;
 800262c:	6017      	str	r7, [r2, #0]
void i2c_lld_init(void) {

#if STM32_I2C_USE_I2C1
  i2cObjectInit(&I2CD1);
  I2CD1.thread = NULL;
  I2CD1.i2c    = I2C1;
 800262e:	f44f 4ca8 	mov.w	ip, #21504	; 0x5400
 *
 * @notapi
 */
static inline void queue_init(threads_queue_t *tqp) {

  tqp->next = (thread_t *)tqp;
 8002632:	f104 020c 	add.w	r2, r4, #12
 8002636:	f641 1191 	movw	r1, #6545	; 0x1991
#if STM32_HAS_GPIOE || defined(__DOXYGEN__)
  GPIOE->ODR = config->PEData.odr;
 800263a:	60de      	str	r6, [r3, #12]
 800263c:	2701      	movs	r7, #1
  GPIOE->CRH = config->PEData.crh;
 800263e:	6058      	str	r0, [r3, #4]
  I2CD1.dmarx  = STM32_DMA_STREAM(STM32_I2C_I2C1_RX_DMA_STREAM);
  I2CD1.dmatx  = STM32_DMA_STREAM(STM32_I2C_I2C1_TX_DMA_STREAM);
 8002640:	f1ae 0b14 	sub.w	fp, lr, #20
  GPIOE->CRL = config->PEData.crl;
 8002644:	6018      	str	r0, [r3, #0]
void i2c_lld_init(void) {

#if STM32_I2C_USE_I2C1
  i2cObjectInit(&I2CD1);
  I2CD1.thread = NULL;
  I2CD1.i2c    = I2C1;
 8002646:	f2c4 0c00 	movt	ip, #16384	; 0x4000
 800264a:	60e2      	str	r2, [r4, #12]
  tqp->prev = (thread_t *)tqp;
 800264c:	6122      	str	r2, [r4, #16]
 800264e:	4650      	mov	r0, sl
 8002650:	f6c0 0100 	movt	r1, #2048	; 0x800
void chMtxObjectInit(mutex_t *mp) {

  chDbgCheck(mp != NULL);

  queue_init(&mp->queue);
  mp->owner = NULL;
 8002654:	6165      	str	r5, [r4, #20]
  SD2.usart = USART2;
#endif

#if STM32_SERIAL_USE_USART3
  sdObjectInit(&SD3, NULL, notify3);
 8002656:	f640 2890 	movw	r8, #2704	; 0xa90
 800265a:	f8c4 c034 	str.w	ip, [r4, #52]	; 0x34
  I2CD1.dmarx  = STM32_DMA_STREAM(STM32_I2C_I2C1_RX_DMA_STREAM);
 800265e:	f8c4 e02c 	str.w	lr, [r4, #44]	; 0x2c
  I2CD1.dmatx  = STM32_DMA_STREAM(STM32_I2C_I2C1_TX_DMA_STREAM);
 8002662:	f8c4 b030 	str.w	fp, [r4, #48]	; 0x30
 8002666:	7027      	strb	r7, [r4, #0]
 8002668:	f2c2 0800 	movt	r8, #8192	; 0x2000
  i2cp->config = NULL;
 800266c:	6065      	str	r5, [r4, #4]
 */
void i2c_lld_init(void) {

#if STM32_I2C_USE_I2C1
  i2cObjectInit(&I2CD1);
  I2CD1.thread = NULL;
 800266e:	61e5      	str	r5, [r4, #28]
  sdObjectInit(&SD1, NULL, notify1);
  SD1.usart = USART1;
#endif

#if STM32_SERIAL_USE_USART2
  sdObjectInit(&SD2, NULL, notify2);
 8002670:	f7ff fa1e 	bl	8001ab0 <sdObjectInit.constprop.16>
  SD2.usart = USART2;
 8002674:	f44f 4388 	mov.w	r3, #17408	; 0x4400
#endif

#if STM32_SERIAL_USE_USART3
  sdObjectInit(&SD3, NULL, notify3);
 8002678:	f641 1171 	movw	r1, #6513	; 0x1971
  SD1.usart = USART1;
#endif

#if STM32_SERIAL_USE_USART2
  sdObjectInit(&SD2, NULL, notify2);
  SD2.usart = USART2;
 800267c:	f2c4 0300 	movt	r3, #16384	; 0x4000
#endif

#if STM32_SERIAL_USE_USART3
  sdObjectInit(&SD3, NULL, notify3);
 8002680:	4640      	mov	r0, r8
 8002682:	f6c0 0100 	movt	r1, #2048	; 0x800
  SD1.usart = USART1;
#endif

#if STM32_SERIAL_USE_USART2
  sdObjectInit(&SD2, NULL, notify2);
  SD2.usart = USART2;
 8002686:	f8ca 3074 	str.w	r3, [sl, #116]	; 0x74
#endif

#if STM32_SERIAL_USE_USART3
  sdObjectInit(&SD3, NULL, notify3);
 800268a:	f7ff fa11 	bl	8001ab0 <sdObjectInit.constprop.16>

#if OSAL_ST_MODE == OSAL_ST_MODE_FREERUNNING
  /* Free running counter mode.*/

  /* Enabling timer clock.*/
  ST_ENABLE_CLOCK();
 800268e:	f8d9 201c 	ldr.w	r2, [r9, #28]
  SD3.usart = USART3;
 8002692:	f44f 4390 	mov.w	r3, #18432	; 0x4800
 8002696:	433a      	orrs	r2, r7
 8002698:	f2c4 0300 	movt	r3, #16384	; 0x4000

  /* Enabling the stop mode during debug for this timer.*/
  ST_ENABLE_STOP();
 800269c:	f44f 5100 	mov.w	r1, #8192	; 0x2000
 80026a0:	f8c8 3074 	str.w	r3, [r8, #116]	; 0x74
 80026a4:	f2ce 0104 	movt	r1, #57348	; 0xe004

#if OSAL_ST_MODE == OSAL_ST_MODE_FREERUNNING
  /* Free running counter mode.*/

  /* Enabling timer clock.*/
  ST_ENABLE_CLOCK();
 80026a8:	f8c9 201c 	str.w	r2, [r9, #28]

  /* Enabling the stop mode during debug for this timer.*/
  ST_ENABLE_STOP();
 80026ac:	f8d1 e004 	ldr.w	lr, [r1, #4]
 *
 * @notapi
 */
static inline void queue_init(threads_queue_t *tqp) {

  tqp->next = (thread_t *)tqp;
 80026b0:	f640 03d8 	movw	r3, #2264	; 0x8d8
 80026b4:	f44e 6e00 	orr.w	lr, lr, #2048	; 0x800
 80026b8:	f8c1 e004 	str.w	lr, [r1, #4]

  /* Initializing the counter in free running mode.*/
  STM32_ST_TIM->PSC    = (ST_CLOCK_SRC / OSAL_ST_FREQUENCY) - 1;
 80026bc:	f04f 4180 	mov.w	r1, #1073741824	; 0x40000000
 80026c0:	f645 5ebf 	movw	lr, #23999	; 0x5dbf
 80026c4:	f8c1 e028 	str.w	lr, [r1, #40]	; 0x28
 *
 * @notapi
 */
void _heap_init(void) {

  default_heap.provider = chCoreAllocAlignedWithOffset;
 80026c8:	f640 2238 	movw	r2, #2616	; 0xa38
  STM32_ST_TIM->ARR    = ST_ARR_INIT;
 80026cc:	f64f 7eff 	movw	lr, #65535	; 0xffff

#if defined(__CORE_CM0_H_GENERIC)
  NVIC->IP[_IP_IDX(n)] = (NVIC->IP[_IP_IDX(n)] & ~(0xFFU << _BIT_SHIFT(n))) |
                         (NVIC_PRIORITY_MASK(prio) << _BIT_SHIFT(n));
#else
  NVIC->IP[n] = NVIC_PRIORITY_MASK(prio);
 80026d0:	f44f 4b61 	mov.w	fp, #57600	; 0xe100
 80026d4:	f2c2 0300 	movt	r3, #8192	; 0x2000
 80026d8:	f8c1 e02c 	str.w	lr, [r1, #44]	; 0x2c
 80026dc:	f2c2 0200 	movt	r2, #8192	; 0x2000
  STM32_ST_TIM->CCMR1  = 0;
 80026e0:	618d      	str	r5, [r1, #24]
 80026e2:	f2ce 0b00 	movt	fp, #57344	; 0xe000
  STM32_ST_TIM->CCR[0] = 0;
 80026e6:	634d      	str	r5, [r1, #52]	; 0x34
 80026e8:	f04f 0e80 	mov.w	lr, #128	; 0x80
  STM32_ST_TIM->DIER   = 0;
 80026ec:	60cd      	str	r5, [r1, #12]
 80026ee:	f641 1ad1 	movw	sl, #6609	; 0x19d1
  STM32_ST_TIM->CR2    = 0;
 80026f2:	604d      	str	r5, [r1, #4]
#if CH_CFG_MEMCORE_SIZE == 0
  extern uint8_t __heap_base__[];
  extern uint8_t __heap_end__[];

  /*lint -save -e9033 [10.8] Required cast operations.*/
  ch_memcore.nextmem = __heap_base__;
 80026f4:	f640 1048 	movw	r0, #2376	; 0x948
  STM32_ST_TIM->EGR    = TIM_EGR_UG;
 80026f8:	614f      	str	r7, [r1, #20]
 80026fa:	f640 3910 	movw	r9, #2832	; 0xb10
  STM32_ST_TIM->CR1    = TIM_CR1_CEN;
 80026fe:	600f      	str	r7, [r1, #0]
  ch_memcore.endmem  = __heap_end__;
 8002700:	f242 0c00 	movw	ip, #8192	; 0x2000
#endif
  NVIC->ICPR[n >> 5U] = 1U << (n & 0x1FU);
 8002704:	f04f 5180 	mov.w	r1, #268435456	; 0x10000000

#if defined(__CORE_CM0_H_GENERIC)
  NVIC->IP[_IP_IDX(n)] = (NVIC->IP[_IP_IDX(n)] & ~(0xFFU << _BIT_SHIFT(n))) |
                         (NVIC_PRIORITY_MASK(prio) << _BIT_SHIFT(n));
#else
  NVIC->IP[n] = NVIC_PRIORITY_MASK(prio);
 8002708:	f88b e31c 	strb.w	lr, [fp, #796]	; 0x31c
 800270c:	f6c0 0a00 	movt	sl, #2048	; 0x800
#endif
  NVIC->ICPR[n >> 5U] = 1U << (n & 0x1FU);
 8002710:	f8cb 1180 	str.w	r1, [fp, #384]	; 0x180
#if CH_CFG_MEMCORE_SIZE == 0
  extern uint8_t __heap_base__[];
  extern uint8_t __heap_end__[];

  /*lint -save -e9033 [10.8] Required cast operations.*/
  ch_memcore.nextmem = __heap_base__;
 8002714:	f2c2 0000 	movt	r0, #8192	; 0x2000
  NVIC->ISER[n >> 5U] = 1U << (n & 0x1FU);
 8002718:	f8cb 1000 	str.w	r1, [fp]
 800271c:	f2c2 0900 	movt	r9, #8192	; 0x2000
 8002720:	f102 0b10 	add.w	fp, r2, #16
 *
 * @notapi
 */
void _vt_init(void) {

  ch.vtlist.next = (virtual_timer_t *)&ch.vtlist;
 8002724:	f103 011c 	add.w	r1, r3, #28
  ch.vtlist.prev = (virtual_timer_t *)&ch.vtlist;
  ch.vtlist.delta = (systime_t)-1;
 8002728:	849e      	strh	r6, [r3, #36]	; 0x24
  ch_memcore.endmem  = __heap_end__;
 800272a:	f2c2 0c00 	movt	ip, #8192	; 0x2000
__STATIC_INLINE void NVIC_SetPriorityGrouping(uint32_t PriorityGroup)
{
  uint32_t reg_value;
  uint32_t PriorityGroupTmp = (PriorityGroup & (uint32_t)0x07UL);             /* only values 0..7 are used          */

  reg_value  =  SCB->AIRCR;                                                   /* read old register configuration    */
 800272e:	f44f 466d 	mov.w	r6, #60672	; 0xed00
 8002732:	f2ce 0600 	movt	r6, #57344	; 0xe000
 8002736:	e880 1200 	stmia.w	r0, {r9, ip}
 * @notapi
 */
void _scheduler_init(void) {

  queue_init(&ch.rlist.queue);
  ch.rlist.prio = NOPRIO;
 800273a:	609d      	str	r5, [r3, #8]
#if CH_CFG_ST_TIMEDELTA == 0
  ch.vtlist.systime = (systime_t)0;
#else /* CH_CFG_ST_TIMEDELTA > 0 */
  ch.vtlist.lasttime = (systime_t)0;
 800273c:	84dd      	strh	r5, [r3, #38]	; 0x26
 *
 * @notapi
 */
thread_t *_thread_init(thread_t *tp, const char *name, tprio_t prio) {

  tp->prio      = prio;
 800273e:	f8c3 e034 	str.w	lr, [r3, #52]	; 0x34
  tp->state     = CH_STATE_WTSTART;
  tp->flags     = CH_FLAG_MODE_STATIC;
 8002742:	f883 504d 	strb.w	r5, [r3, #77]	; 0x4d
  H_NEXT(&default_heap.header) = NULL;
 8002746:	6095      	str	r5, [r2, #8]
  H_PAGES(&default_heap.header) = 0;
 8002748:	60d5      	str	r5, [r2, #12]
 800274a:	6195      	str	r5, [r2, #24]
 *
 * @notapi
 */
void _heap_init(void) {

  default_heap.provider = chCoreAllocAlignedWithOffset;
 800274c:	f8c2 a000 	str.w	sl, [r2]
 8002750:	f8c2 b010 	str.w	fp, [r2, #16]
  tqp->prev = (thread_t *)tqp;
 8002754:	f8c2 b014 	str.w	fp, [r2, #20]
 *
 * @notapi
 */
void _vt_init(void) {

  ch.vtlist.next = (virtual_timer_t *)&ch.vtlist;
 8002758:	61d9      	str	r1, [r3, #28]
  ch.vtlist.prev = (virtual_timer_t *)&ch.vtlist;
 800275a:	6219      	str	r1, [r3, #32]
 *
 * @notapi
 */
static inline void queue_init(threads_queue_t *tqp) {

  tqp->next = (thread_t *)tqp;
 800275c:	601b      	str	r3, [r3, #0]
  tqp->prev = (thread_t *)tqp;
 800275e:	605b      	str	r3, [r3, #4]
#if CH_CFG_TIME_QUANTUM > 0
  tp->preempt   = (tslices_t)CH_CFG_TIME_QUANTUM;
#endif
#if CH_CFG_USE_MUTEXES == TRUE
  tp->realprio  = prio;
 8002760:	f8c3 e068 	str.w	lr, [r3, #104]	; 0x68
#endif
#if CH_DBG_THREADS_PROFILING == TRUE
  tp->time      = (systime_t)0;
#endif
#if CH_CFG_USE_REGISTRY == TRUE
  tp->refs      = (trefs_t)1;
 8002764:	f883 704e 	strb.w	r7, [r3, #78]	; 0x4e
#elif CH_CFG_USE_DYNAMIC == TRUE
  currp->wabase = NULL;
#endif

  /* Setting up the caller as current thread.*/
  currp->state = CH_STATE_CURRENT;
 8002768:	f883 704c 	strb.w	r7, [r3, #76]	; 0x4c
#if CH_CFG_USE_MUTEXES == TRUE
  tp->realprio  = prio;
  tp->mtxlist   = NULL;
#endif
#if CH_CFG_USE_EVENTS == TRUE
  tp->epending  = (eventmask_t)0;
 800276c:	661d      	str	r5, [r3, #96]	; 0x60
 800276e:	68f0      	ldr	r0, [r6, #12]
  reg_value &= ~((uint32_t)(SCB_AIRCR_VECTKEY_Msk | SCB_AIRCR_PRIGROUP_Msk)); /* clear bits to change               */
 8002770:	f64f 01ff 	movw	r1, #63743	; 0xf8ff
  reg_value  =  (reg_value                                   |
 8002774:	f44f 7240 	mov.w	r2, #768	; 0x300
{
  uint32_t reg_value;
  uint32_t PriorityGroupTmp = (PriorityGroup & (uint32_t)0x07UL);             /* only values 0..7 are used          */

  reg_value  =  SCB->AIRCR;                                                   /* read old register configuration    */
  reg_value &= ~((uint32_t)(SCB_AIRCR_VECTKEY_Msk | SCB_AIRCR_PRIGROUP_Msk)); /* clear bits to change               */
 8002778:	4001      	ands	r1, r0
#if CH_DBG_THREADS_PROFILING == TRUE
  tp->time      = (systime_t)0;
#endif
#if CH_CFG_USE_REGISTRY == TRUE
  tp->refs      = (trefs_t)1;
  tp->name      = name;
 800277a:	f642 57f8 	movw	r7, #11768	; 0x2df8
  reg_value  =  (reg_value                                   |
 800277e:	f2c0 52fa 	movt	r2, #1530	; 0x5fa
  REG_INSERT(tp);
 8002782:	f103 002c 	add.w	r0, r3, #44	; 0x2c
 *
 * @notapi
 */
static inline void queue_init(threads_queue_t *tqp) {

  tqp->next = (thread_t *)tqp;
 8002786:	f103 0e58 	add.w	lr, r3, #88	; 0x58
 *
 * @notapi
 */
static inline void list_init(threads_list_t *tlp) {

  tlp->next = (thread_t *)tlp;
 800278a:	f103 0c54 	add.w	ip, r3, #84	; 0x54
 800278e:	430a      	orrs	r2, r1
#if CH_DBG_THREADS_PROFILING == TRUE
  tp->time      = (systime_t)0;
#endif
#if CH_CFG_USE_REGISTRY == TRUE
  tp->refs      = (trefs_t)1;
  tp->name      = name;
 8002790:	f6c0 0700 	movt	r7, #2048	; 0x800

  /* Initializing priority grouping.*/
  NVIC_SetPriorityGrouping(CORTEX_PRIGROUP_INIT);

  /* DWT cycle counter enable, note, the M7 requires DWT unlocking.*/
  CoreDebug->DEMCR |= CoreDebug_DEMCR_TRCENA_Msk;
 8002794:	f64e 51f0 	movw	r1, #60912	; 0xedf0
  REG_INSERT(tp);
 8002798:	6118      	str	r0, [r3, #16]
 800279a:	6158      	str	r0, [r3, #20]
#endif

#if CH_CFG_NO_IDLE_THREAD == FALSE
  /* Now this instructions flow becomes the main thread.*/
#if CH_CFG_USE_REGISTRY == TRUE
  currp = _thread_init(&ch.mainthread, (const char *)&ch_debug, NORMALPRIO);
 800279c:	6198      	str	r0, [r3, #24]
#if CH_CFG_TIME_QUANTUM > 0
  tp->preempt   = (tslices_t)CH_CFG_TIME_QUANTUM;
#endif
#if CH_CFG_USE_MUTEXES == TRUE
  tp->realprio  = prio;
  tp->mtxlist   = NULL;
 800279e:	665d      	str	r5, [r3, #100]	; 0x64
  tp->time      = (systime_t)0;
#endif
#if CH_CFG_USE_REGISTRY == TRUE
  tp->refs      = (trefs_t)1;
  tp->name      = name;
  REG_INSERT(tp);
 80027a0:	63db      	str	r3, [r3, #60]	; 0x3c
 80027a2:	641b      	str	r3, [r3, #64]	; 0x40
       symbol must be provided externally.*/
    extern stkalign_t __main_thread_stack_base__;
    currp->wabase = &__main_thread_stack_base__;
  }
#elif CH_CFG_USE_DYNAMIC == TRUE
  currp->wabase = NULL;
 80027a4:	649d      	str	r5, [r3, #72]	; 0x48
#if CH_DBG_THREADS_PROFILING == TRUE
  tp->time      = (systime_t)0;
#endif
#if CH_CFG_USE_REGISTRY == TRUE
  tp->refs      = (trefs_t)1;
  tp->name      = name;
 80027a6:	645f      	str	r7, [r3, #68]	; 0x44
 80027a8:	f8c3 c054 	str.w	ip, [r3, #84]	; 0x54
 *
 * @notapi
 */
static inline void queue_init(threads_queue_t *tqp) {

  tqp->next = (thread_t *)tqp;
 80027ac:	f8c3 e058 	str.w	lr, [r3, #88]	; 0x58
  tqp->prev = (thread_t *)tqp;
 80027b0:	f8c3 e05c 	str.w	lr, [r3, #92]	; 0x5c
 80027b4:	f2ce 0100 	movt	r1, #57344	; 0xe000
                ((uint32_t)0x5FAUL << SCB_AIRCR_VECTKEY_Pos) |
                (PriorityGroupTmp << 8U)                      );              /* Insert write key and priorty group */
  SCB->AIRCR =  reg_value;
 80027b8:	60f2      	str	r2, [r6, #12]
 80027ba:	68ca      	ldr	r2, [r1, #12]
#if CORTEX_MODEL == 7
  DWT->LAR = 0xC5ACCE55U;
#endif
  DWT->CTRL |= DWT_CTRL_CYCCNTENA_Msk;
 80027bc:	f44f 5380 	mov.w	r3, #4096	; 0x1000

  /* Initializing priority grouping.*/
  NVIC_SetPriorityGrouping(CORTEX_PRIGROUP_INIT);

  /* DWT cycle counter enable, note, the M7 requires DWT unlocking.*/
  CoreDebug->DEMCR |= CoreDebug_DEMCR_TRCENA_Msk;
 80027c0:	f042 7280 	orr.w	r2, r2, #16777216	; 0x1000000
 80027c4:	60ca      	str	r2, [r1, #12]
#if CORTEX_MODEL == 7
  DWT->LAR = 0xC5ACCE55U;
#endif
  DWT->CTRL |= DWT_CTRL_CYCCNTENA_Msk;
 80027c6:	f2ce 0300 	movt	r3, #57344	; 0xe000
 80027ca:	6818      	ldr	r0, [r3, #0]
 */
__STATIC_INLINE void NVIC_SetPriority(IRQn_Type IRQn, uint32_t priority)
{
  if ((int32_t)(IRQn) < 0)
  {
    SCB->SHP[(((uint32_t)(int32_t)IRQn) & 0xFUL)-4UL] = (uint8_t)((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL);
 80027cc:	2110      	movs	r1, #16
 80027ce:	f040 0001 	orr.w	r0, r0, #1
 80027d2:	2220      	movs	r2, #32
 80027d4:	6018      	str	r0, [r3, #0]
 80027d6:	77f1      	strb	r1, [r6, #31]
 80027d8:	f886 2022 	strb.w	r2, [r6, #34]	; 0x22
 80027dc:	f385 8811 	msr	BASEPRI, r5
  \details Enables IRQ interrupts by clearing the I-bit in the CPSR.
           Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __enable_irq(void)
{
  __ASM volatile ("cpsie i" : : : "memory");
 80027e0:	b662      	cpsie	i
  \details Assigns the given value to the Base Priority register.
  \param [in]    basePri  Base Priority value to set
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __set_BASEPRI(uint32_t value)
{
  __ASM volatile ("MSR basepri, %0" : : "r" (value) : "memory");
 80027e2:	2320      	movs	r3, #32
 80027e4:	f383 8811 	msr	BASEPRI, r3
  REG_INSERT(tp);
 80027e8:	f640 0bd8 	movw	fp, #2264	; 0x8d8
 80027ec:	f2c2 0b00 	movt	fp, #8192	; 0x2000
  tp = (thread_t *)((uint8_t *)tdp->wend -
                    MEM_ALIGN_NEXT(sizeof (thread_t), PORT_STACK_ALIGN));

#if (CH_DBG_ENABLE_STACK_CHECK == TRUE) || (CH_CFG_USE_DYNAMIC == TRUE)
  /* Stack boundary.*/
  tp->wabase = tdp->wbase;
 80027f0:	f640 1350 	movw	r3, #2384	; 0x950
 80027f4:	f2c2 0300 	movt	r3, #8192	; 0x2000
 *
 * @notapi
 */
thread_t *_thread_init(thread_t *tp, const char *name, tprio_t prio) {

  tp->prio      = prio;
 80027f8:	2001      	movs	r0, #1
 * @param[in] msg       the wakeup message
 *
 * @sclass
 */
void chSchWakeupS(thread_t *ntp, msg_t msg) {
  thread_t *otp = currp;
 80027fa:	f8db e018 	ldr.w	lr, [fp, #24]
 80027fe:	f8c3 0098 	str.w	r0, [r3, #152]	; 0x98
  /* Stack boundary.*/
  tp->wabase = tdp->wbase;
#endif

  /* Setting up the port-dependent part of the working area.*/
  PORT_SETUP_CONTEXT(tp, tdp->wbase, tp, tdp->funcp, tdp->arg);
 8002802:	f641 27a1 	movw	r7, #6817	; 0x1aa1
 8002806:	f240 2665 	movw	r6, #613	; 0x265

  /* If the waken thread has a not-greater priority than the current
     one then it is just inserted in the ready list else it made
     running immediately and the invoking thread goes in the ready
     list instead.*/
  if (ntp->prio <= otp->prio) {
 800280a:	f8de c008 	ldr.w	ip, [lr, #8]
  tp->time      = (systime_t)0;
#endif
#if CH_CFG_USE_REGISTRY == TRUE
  tp->refs      = (trefs_t)1;
  tp->name      = name;
  REG_INSERT(tp);
 800280e:	f8db 9014 	ldr.w	r9, [fp, #20]
  /* Stack boundary.*/
  tp->wabase = tdp->wbase;
#endif

  /* Setting up the port-dependent part of the working area.*/
  PORT_SETUP_CONTEXT(tp, tdp->wbase, tp, tdp->funcp, tdp->arg);
 8002812:	f103 026c 	add.w	r2, r3, #108	; 0x6c
 8002816:	f6c0 0700 	movt	r7, #2048	; 0x800
 800281a:	f6c0 0600 	movt	r6, #2048	; 0x800
#if CH_DBG_THREADS_PROFILING == TRUE
  tp->time      = (systime_t)0;
#endif
#if CH_CFG_USE_REGISTRY == TRUE
  tp->refs      = (trefs_t)1;
  tp->name      = name;
 800281e:	f642 5594 	movw	r5, #11668	; 0x2d94
  REG_INSERT(tp);
 8002822:	f103 0190 	add.w	r1, r3, #144	; 0x90
  /* Stack boundary.*/
  tp->wabase = tdp->wbase;
#endif

  /* Setting up the port-dependent part of the working area.*/
  PORT_SETUP_CONTEXT(tp, tdp->wbase, tp, tdp->funcp, tdp->arg);
 8002826:	f8c3 209c 	str.w	r2, [r3, #156]	; 0x9c
 800282a:	66df      	str	r7, [r3, #108]	; 0x6c
 800282c:	2200      	movs	r2, #0
 800282e:	f8c3 608c 	str.w	r6, [r3, #140]	; 0x8c
 * @notapi
 */
thread_t *_thread_init(thread_t *tp, const char *name, tprio_t prio) {

  tp->prio      = prio;
  tp->state     = CH_STATE_WTSTART;
 8002832:	f04f 0a02 	mov.w	sl, #2
 *
 * @notapi
 */
static inline void queue_init(threads_queue_t *tqp) {

  tqp->next = (thread_t *)tqp;
 8002836:	f103 06bc 	add.w	r6, r3, #188	; 0xbc
#if CH_DBG_THREADS_PROFILING == TRUE
  tp->time      = (systime_t)0;
#endif
#if CH_CFG_USE_REGISTRY == TRUE
  tp->refs      = (trefs_t)1;
  tp->name      = name;
 800283a:	f6c0 0500 	movt	r5, #2048	; 0x800
 *
 * @notapi
 */
static inline void list_init(threads_list_t *tlp) {

  tlp->next = (thread_t *)tlp;
 800283e:	f103 07b8 	add.w	r7, r3, #184	; 0xb8
  REG_INSERT(tp);
 8002842:	f8c3 90a4 	str.w	r9, [r3, #164]	; 0xa4
  tp = (thread_t *)((uint8_t *)tdp->wend -
                    MEM_ALIGN_NEXT(sizeof (thread_t), PORT_STACK_ALIGN));

#if (CH_DBG_ENABLE_STACK_CHECK == TRUE) || (CH_CFG_USE_DYNAMIC == TRUE)
  /* Stack boundary.*/
  tp->wabase = tdp->wbase;
 8002846:	f8c3 30ac 	str.w	r3, [r3, #172]	; 0xac
  tp->time      = (systime_t)0;
#endif
#if CH_CFG_USE_REGISTRY == TRUE
  tp->refs      = (trefs_t)1;
  tp->name      = name;
  REG_INSERT(tp);
 800284a:	f8c3 b0a0 	str.w	fp, [r3, #160]	; 0xa0
 * @notapi
 */
thread_t *_thread_init(thread_t *tp, const char *name, tprio_t prio) {

  tp->prio      = prio;
  tp->state     = CH_STATE_WTSTART;
 800284e:	f883 a0b0 	strb.w	sl, [r3, #176]	; 0xb0
#if CH_DBG_THREADS_PROFILING == TRUE
  tp->time      = (systime_t)0;
#endif
#if CH_CFG_USE_REGISTRY == TRUE
  tp->refs      = (trefs_t)1;
  tp->name      = name;
 8002852:	f8c3 50a8 	str.w	r5, [r3, #168]	; 0xa8
  tp->flags     = CH_FLAG_MODE_STATIC;
#if CH_CFG_TIME_QUANTUM > 0
  tp->preempt   = (tslices_t)CH_CFG_TIME_QUANTUM;
#endif
#if CH_CFG_USE_MUTEXES == TRUE
  tp->realprio  = prio;
 8002856:	f8c3 00cc 	str.w	r0, [r3, #204]	; 0xcc
#endif
#if CH_DBG_THREADS_PROFILING == TRUE
  tp->time      = (systime_t)0;
#endif
#if CH_CFG_USE_REGISTRY == TRUE
  tp->refs      = (trefs_t)1;
 800285a:	f883 00b2 	strb.w	r0, [r3, #178]	; 0xb2
  /* Stack boundary.*/
  tp->wabase = tdp->wbase;
#endif

  /* Setting up the port-dependent part of the working area.*/
  PORT_SETUP_CONTEXT(tp, tdp->wbase, tp, tdp->funcp, tdp->arg);
 800285e:	671a      	str	r2, [r3, #112]	; 0x70
 */
thread_t *_thread_init(thread_t *tp, const char *name, tprio_t prio) {

  tp->prio      = prio;
  tp->state     = CH_STATE_WTSTART;
  tp->flags     = CH_FLAG_MODE_STATIC;
 8002860:	f883 20b1 	strb.w	r2, [r3, #177]	; 0xb1
#if CH_CFG_TIME_QUANTUM > 0
  tp->preempt   = (tslices_t)CH_CFG_TIME_QUANTUM;
#endif
#if CH_CFG_USE_MUTEXES == TRUE
  tp->realprio  = prio;
  tp->mtxlist   = NULL;
 8002864:	f8c3 20c8 	str.w	r2, [r3, #200]	; 0xc8
#endif
#if CH_CFG_USE_EVENTS == TRUE
  tp->epending  = (eventmask_t)0;
 8002868:	f8c3 20c4 	str.w	r2, [r3, #196]	; 0xc4
  tp->time      = (systime_t)0;
#endif
#if CH_CFG_USE_REGISTRY == TRUE
  tp->refs      = (trefs_t)1;
  tp->name      = name;
  REG_INSERT(tp);
 800286c:	f8c9 1010 	str.w	r1, [r9, #16]
 8002870:	f8cb 1014 	str.w	r1, [fp, #20]
              (ch.rlist.current->prio >= ch.rlist.queue.next->prio),
              "priority order violation");

  /* Storing the message to be retrieved by the target thread when it will
     restart execution.*/
  ntp->u.rdymsg = msg;
 8002874:	f8c3 20b4 	str.w	r2, [r3, #180]	; 0xb4
 8002878:	f8c3 70b8 	str.w	r7, [r3, #184]	; 0xb8
 *
 * @notapi
 */
static inline void queue_init(threads_queue_t *tqp) {

  tqp->next = (thread_t *)tqp;
 800287c:	f8c3 60bc 	str.w	r6, [r3, #188]	; 0xbc
  tqp->prev = (thread_t *)tqp;
 8002880:	f8c3 60c0 	str.w	r6, [r3, #192]	; 0xc0

  /* If the waken thread has a not-greater priority than the current
     one then it is just inserted in the ready list else it made
     running immediately and the invoking thread goes in the ready
     list instead.*/
  if (ntp->prio <= otp->prio) {
 8002884:	f1bc 0f00 	cmp.w	ip, #0
 8002888:	f000 81c0 	beq.w	8002c0c <main+0x70c>
  chDbgCheck(tp != NULL);
  chDbgAssert((tp->state != CH_STATE_READY) &&
              (tp->state != CH_STATE_FINAL),
              "invalid state");

  tp->state = CH_STATE_READY;
 800288c:	f883 20b0 	strb.w	r2, [r3, #176]	; 0xb0
  cp = (thread_t *)&ch.rlist.queue;
 8002890:	465a      	mov	r2, fp
  do {
    cp = cp->queue.next;
 8002892:	6812      	ldr	r2, [r2, #0]
  } while (cp->prio >= tp->prio);
 8002894:	6897      	ldr	r7, [r2, #8]
 8002896:	2f00      	cmp	r7, #0
 8002898:	d1fb      	bne.n	8002892 <main+0x392>
  /* Insertion on prev.*/
  tp->queue.next             = cp;
  tp->queue.prev             = cp->queue.prev;
 800289a:	6850      	ldr	r0, [r2, #4]
  cp = (thread_t *)&ch.rlist.queue;
  do {
    cp = cp->queue.next;
  } while (cp->prio >= tp->prio);
  /* Insertion on prev.*/
  tp->queue.next             = cp;
 800289c:	f8c3 2090 	str.w	r2, [r3, #144]	; 0x90
  tp->queue.prev             = cp->queue.prev;
 80028a0:	f8c3 0094 	str.w	r0, [r3, #148]	; 0x94
  tp->queue.prev->queue.next = tp;
 80028a4:	6001      	str	r1, [r0, #0]
  cp->queue.prev             = tp;
 80028a6:	6051      	str	r1, [r2, #4]
 80028a8:	f387 8811 	msr	BASEPRI, r7
   */
  halInit();
  chSysInit();
  boardInit();
	//ssdInit();
  sdStart(&SD2, &sdcfg1);
 80028ac:	f640 0050 	movw	r0, #2128	; 0x850
 80028b0:	f640 0100 	movw	r1, #2048	; 0x800
 80028b4:	f2c2 0000 	movt	r0, #8192	; 0x2000
 80028b8:	f2c2 0100 	movt	r1, #8192	; 0x2000
 80028bc:	f7fe fcd8 	bl	8001270 <sdStart>
	sdStart(&SD3, &sdcfg2);
 80028c0:	f640 2090 	movw	r0, #2704	; 0xa90
 80028c4:	f640 010c 	movw	r1, #2060	; 0x80c
 80028c8:	f2c2 0000 	movt	r0, #8192	; 0x2000
 80028cc:	f2c2 0100 	movt	r1, #8192	; 0x2000
 80028d0:	f7fe fcce 	bl	8001270 <sdStart>
 80028d4:	2320      	movs	r3, #32
 80028d6:	f383 8811 	msr	BASEPRI, r3
 */
void i2c_lld_start(I2CDriver *i2cp) {
  I2C_TypeDef *dp = i2cp->i2c;

  /* If in stopped state then enables the I2C and DMA clocks.*/
  if (i2cp->state == I2C_STOP) {
 80028da:	f894 a000 	ldrb.w	sl, [r4]
  osalDbgCheck((i2cp != NULL) && (config != NULL));
  osalDbgAssert((i2cp->state == I2C_STOP) || (i2cp->state == I2C_READY) ||
                (i2cp->state == I2C_LOCKED), "invalid state");

  osalSysLock();
  i2cp->config = config;
 80028de:	f642 609c 	movw	r0, #11932	; 0x2e9c
 * @param[in] i2cp      pointer to the @p I2CDriver object
 *
 * @notapi
 */
void i2c_lld_start(I2CDriver *i2cp) {
  I2C_TypeDef *dp = i2cp->i2c;
 80028e2:	6b66      	ldr	r6, [r4, #52]	; 0x34
 80028e4:	f6c0 0000 	movt	r0, #2048	; 0x800
 80028e8:	f640 2558 	movw	r5, #2648	; 0xa58

  /* If in stopped state then enables the I2C and DMA clocks.*/
  if (i2cp->state == I2C_STOP) {
 80028ec:	f1ba 0f01 	cmp.w	sl, #1
 80028f0:	6060      	str	r0, [r4, #4]
 80028f2:	f2c2 0500 	movt	r5, #8192	; 0x2000
 * @param[in] i2cp      pointer to the @p I2CDriver object
 *
 * @notapi
 */
void i2c_lld_start(I2CDriver *i2cp) {
  I2C_TypeDef *dp = i2cp->i2c;
 80028f6:	bf18      	it	ne
 80028f8:	4632      	movne	r2, r6

  /* If in stopped state then enables the I2C and DMA clocks.*/
  if (i2cp->state == I2C_STOP) {
 80028fa:	d142      	bne.n	8002982 <main+0x482>

    i2cp->txdmamode = STM32_DMA_CR_PSIZE_BYTE | STM32_DMA_CR_MSIZE_BYTE |
 80028fc:	229a      	movs	r2, #154	; 0x9a
                      STM32_DMA_CR_MINC       | STM32_DMA_CR_DMEIE |
                      STM32_DMA_CR_TEIE       | STM32_DMA_CR_TCIE |
                      STM32_DMA_CR_DIR_M2P;
    i2cp->rxdmamode = STM32_DMA_CR_PSIZE_BYTE | STM32_DMA_CR_MSIZE_BYTE |
 80028fe:	238a      	movs	r3, #138	; 0x8a

#if STM32_I2C_USE_I2C1
    if (&I2CD1 == i2cp) {
      bool b;

      rccResetI2C1();
 8002900:	f44f 5980 	mov.w	r9, #4096	; 0x1000

    i2cp->txdmamode = STM32_DMA_CR_PSIZE_BYTE | STM32_DMA_CR_MSIZE_BYTE |
                      STM32_DMA_CR_MINC       | STM32_DMA_CR_DMEIE |
                      STM32_DMA_CR_TEIE       | STM32_DMA_CR_TCIE |
                      STM32_DMA_CR_DIR_M2P;
    i2cp->rxdmamode = STM32_DMA_CR_PSIZE_BYTE | STM32_DMA_CR_MSIZE_BYTE |
 8002904:	626b      	str	r3, [r5, #36]	; 0x24

#if STM32_I2C_USE_I2C1
    if (&I2CD1 == i2cp) {
      bool b;

      rccResetI2C1();
 8002906:	f2c4 0902 	movt	r9, #16386	; 0x4002
  I2C_TypeDef *dp = i2cp->i2c;

  /* If in stopped state then enables the I2C and DMA clocks.*/
  if (i2cp->state == I2C_STOP) {

    i2cp->txdmamode = STM32_DMA_CR_PSIZE_BYTE | STM32_DMA_CR_MSIZE_BYTE |
 800290a:	62aa      	str	r2, [r5, #40]	; 0x28

#if STM32_I2C_USE_I2C1
    if (&I2CD1 == i2cp) {
      bool b;

      rccResetI2C1();
 800290c:	f8d9 2010 	ldr.w	r2, [r9, #16]
 8002910:	2300      	movs	r3, #0
 8002912:	f442 1200 	orr.w	r2, r2, #2097152	; 0x200000
      b = dmaStreamAllocate(i2cp->dmarx,
 8002916:	f640 4191 	movw	r1, #3217	; 0xc91

#if STM32_I2C_USE_I2C1
    if (&I2CD1 == i2cp) {
      bool b;

      rccResetI2C1();
 800291a:	f8c9 2010 	str.w	r2, [r9, #16]
      b = dmaStreamAllocate(i2cp->dmarx,
 800291e:	f6c0 0100 	movt	r1, #2048	; 0x800

#if STM32_I2C_USE_I2C1
    if (&I2CD1 == i2cp) {
      bool b;

      rccResetI2C1();
 8002922:	f8c9 3010 	str.w	r3, [r9, #16]
      b = dmaStreamAllocate(i2cp->dmarx,
 8002926:	462a      	mov	r2, r5
 8002928:	6ae8      	ldr	r0, [r5, #44]	; 0x2c
 800292a:	f7ff f8f9 	bl	8001b20 <dmaStreamAllocate.constprop.13>
                            STM32_I2C_I2C1_IRQ_PRIORITY,
                            (stm32_dmaisr_t)i2c_lld_serve_rx_end_irq,
                            (void *)i2cp);
      osalDbgAssert(!b, "stream already allocated");
      b = dmaStreamAllocate(i2cp->dmatx,
 800292e:	f640 4141 	movw	r1, #3137	; 0xc41
 8002932:	f6c0 0100 	movt	r1, #2048	; 0x800
 8002936:	462a      	mov	r2, r5
 8002938:	6b28      	ldr	r0, [r5, #48]	; 0x30
 800293a:	f7ff f8f1 	bl	8001b20 <dmaStreamAllocate.constprop.13>
                            STM32_I2C_I2C1_IRQ_PRIORITY,
                            (stm32_dmaisr_t)i2c_lld_serve_tx_end_irq,
                            (void *)i2cp);
      osalDbgAssert(!b, "stream already allocated");
      rccEnableI2C1(FALSE);
 800293e:	f8d9 001c 	ldr.w	r0, [r9, #28]

#if defined(__CORE_CM0_H_GENERIC)
  NVIC->IP[_IP_IDX(n)] = (NVIC->IP[_IP_IDX(n)] & ~(0xFFU << _BIT_SHIFT(n))) |
                         (NVIC_PRIORITY_MASK(prio) << _BIT_SHIFT(n));
#else
  NVIC->IP[n] = NVIC_PRIORITY_MASK(prio);
 8002942:	f44f 4361 	mov.w	r3, #57600	; 0xe100
 8002946:	f2ce 0300 	movt	r3, #57344	; 0xe000
 800294a:	2250      	movs	r2, #80	; 0x50
#endif
  NVIC->ICPR[n >> 5U] = 1U << (n & 0x1FU);
 800294c:	f04f 4100 	mov.w	r1, #2147483648	; 0x80000000
 8002950:	f440 1000 	orr.w	r0, r0, #2097152	; 0x200000
 8002954:	f8c9 001c 	str.w	r0, [r9, #28]

#if defined(__CORE_CM0_H_GENERIC)
  NVIC->IP[_IP_IDX(n)] = (NVIC->IP[_IP_IDX(n)] & ~(0xFFU << _BIT_SHIFT(n))) |
                         (NVIC_PRIORITY_MASK(prio) << _BIT_SHIFT(n));
#else
  NVIC->IP[n] = NVIC_PRIORITY_MASK(prio);
 8002958:	f883 231f 	strb.w	r2, [r3, #799]	; 0x31f
#endif
  NVIC->ICPR[n >> 5U] = 1U << (n & 0x1FU);
 800295c:	f8c3 1180 	str.w	r1, [r3, #384]	; 0x180
  NVIC->ISER[n >> 5U] = 1U << (n & 0x1FU);
 8002960:	6019      	str	r1, [r3, #0]

#if defined(__CORE_CM0_H_GENERIC)
  NVIC->IP[_IP_IDX(n)] = (NVIC->IP[_IP_IDX(n)] & ~(0xFFU << _BIT_SHIFT(n))) |
                         (NVIC_PRIORITY_MASK(prio) << _BIT_SHIFT(n));
#else
  NVIC->IP[n] = NVIC_PRIORITY_MASK(prio);
 8002962:	f883 2320 	strb.w	r2, [r3, #800]	; 0x320
#endif
  NVIC->ICPR[n >> 5U] = 1U << (n & 0x1FU);
 8002966:	f8c3 a184 	str.w	sl, [r3, #388]	; 0x184
  NVIC->ISER[n >> 5U] = 1U << (n & 0x1FU);
 800296a:	f8c3 a004 	str.w	sl, [r3, #4]
      nvicEnableVector(I2C1_EV_IRQn, STM32_I2C_I2C1_IRQ_PRIORITY);
      nvicEnableVector(I2C1_ER_IRQn, STM32_I2C_I2C1_IRQ_PRIORITY);

      i2cp->rxdmamode |= STM32_DMA_CR_CHSEL(I2C1_RX_DMA_CHANNEL) |
 800296e:	6a6a      	ldr	r2, [r5, #36]	; 0x24
                       STM32_DMA_CR_PL(STM32_I2C_I2C1_DMA_PRIORITY);
      i2cp->txdmamode |= STM32_DMA_CR_CHSEL(I2C1_TX_DMA_CHANNEL) |
 8002970:	6aab      	ldr	r3, [r5, #40]	; 0x28
      osalDbgAssert(!b, "stream already allocated");
      rccEnableI2C1(FALSE);
      nvicEnableVector(I2C1_EV_IRQn, STM32_I2C_I2C1_IRQ_PRIORITY);
      nvicEnableVector(I2C1_ER_IRQn, STM32_I2C_I2C1_IRQ_PRIORITY);

      i2cp->rxdmamode |= STM32_DMA_CR_CHSEL(I2C1_RX_DMA_CHANNEL) |
 8002972:	f442 5140 	orr.w	r1, r2, #12288	; 0x3000
                       STM32_DMA_CR_PL(STM32_I2C_I2C1_DMA_PRIORITY);
      i2cp->txdmamode |= STM32_DMA_CR_CHSEL(I2C1_TX_DMA_CHANNEL) |
 8002976:	f443 5340 	orr.w	r3, r3, #12288	; 0x3000
 800297a:	6868      	ldr	r0, [r5, #4]
 800297c:	6b6a      	ldr	r2, [r5, #52]	; 0x34
      osalDbgAssert(!b, "stream already allocated");
      rccEnableI2C1(FALSE);
      nvicEnableVector(I2C1_EV_IRQn, STM32_I2C_I2C1_IRQ_PRIORITY);
      nvicEnableVector(I2C1_ER_IRQn, STM32_I2C_I2C1_IRQ_PRIORITY);

      i2cp->rxdmamode |= STM32_DMA_CR_CHSEL(I2C1_RX_DMA_CHANNEL) |
 800297e:	6269      	str	r1, [r5, #36]	; 0x24
                       STM32_DMA_CR_PL(STM32_I2C_I2C1_DMA_PRIORITY);
      i2cp->txdmamode |= STM32_DMA_CR_CHSEL(I2C1_TX_DMA_CHANNEL) |
 8002980:	62ab      	str	r3, [r5, #40]	; 0x28
    }
#endif /* STM32_I2C_USE_I2C3 */
  }

  /* I2C registers pointed by the DMA.*/
  dmaStreamSetPeripheral(i2cp->dmarx, &dp->DR);
 8002982:	6ae1      	ldr	r1, [r4, #44]	; 0x2c
  dmaStreamSetPeripheral(i2cp->dmatx, &dp->DR);
 8002984:	6b23      	ldr	r3, [r4, #48]	; 0x30
    }
#endif /* STM32_I2C_USE_I2C3 */
  }

  /* I2C registers pointed by the DMA.*/
  dmaStreamSetPeripheral(i2cp->dmarx, &dp->DR);
 8002986:	f8d1 9004 	ldr.w	r9, [r1, #4]
  dmaStreamSetPeripheral(i2cp->dmatx, &dp->DR);
 800298a:	f8d3 c004 	ldr.w	ip, [r3, #4]

  /* Reset i2c peripheral.*/
  dp->CR1 = I2C_CR1_SWRST;
 800298e:	f44f 4e00 	mov.w	lr, #32768	; 0x8000
    }
#endif /* STM32_I2C_USE_I2C3 */
  }

  /* I2C registers pointed by the DMA.*/
  dmaStreamSetPeripheral(i2cp->dmarx, &dp->DR);
 8002992:	f106 0310 	add.w	r3, r6, #16
  dmaStreamSetPeripheral(i2cp->dmatx, &dp->DR);

  /* Reset i2c peripheral.*/
  dp->CR1 = I2C_CR1_SWRST;
  dp->CR1 = 0;
 8002996:	2500      	movs	r5, #0
  dp->CR2 = I2C_CR2_ITERREN | I2C_CR2_DMAEN;
 8002998:	f44f 6110 	mov.w	r1, #2304	; 0x900
    }
#endif /* STM32_I2C_USE_I2C3 */
  }

  /* I2C registers pointed by the DMA.*/
  dmaStreamSetPeripheral(i2cp->dmarx, &dp->DR);
 800299c:	f8c9 3008 	str.w	r3, [r9, #8]
  dmaStreamSetPeripheral(i2cp->dmatx, &dp->DR);
 80029a0:	f8cc 3008 	str.w	r3, [ip, #8]

  /* Reset i2c peripheral.*/
  dp->CR1 = I2C_CR1_SWRST;
 80029a4:	f8c6 e000 	str.w	lr, [r6]
  dp->CR1 = 0;
 80029a8:	6035      	str	r5, [r6, #0]
  dp->CR2 = I2C_CR2_ITERREN | I2C_CR2_DMAEN;
 80029aa:	6071      	str	r1, [r6, #4]
  osalDbgCheck((i2cp != NULL) &&
               (clock_speed > 0) &&
               (clock_speed <= 4000000));

  /* CR2 Configuration.*/
  dp->CR2 &= (uint16_t)~I2C_CR2_FREQ;
 80029ac:	6853      	ldr	r3, [r2, #4]
 80029ae:	f64f 71c0 	movw	r1, #65472	; 0xffc0
 80029b2:	4019      	ands	r1, r3
 */
static void i2c_lld_set_clock(I2CDriver *i2cp) {
  I2C_TypeDef *dp = i2cp->i2c;
  uint16_t regCCR, clock_div;
  int32_t clock_speed = i2cp->config->clock_speed;
  i2cdutycycle_t duty = i2cp->config->duty_cycle;
 80029b4:	7a05      	ldrb	r5, [r0, #8]
 * @notapi
 */
static void i2c_lld_set_clock(I2CDriver *i2cp) {
  I2C_TypeDef *dp = i2cp->i2c;
  uint16_t regCCR, clock_div;
  int32_t clock_speed = i2cp->config->clock_speed;
 80029b6:	6843      	ldr	r3, [r0, #4]
  osalDbgCheck((i2cp != NULL) &&
               (clock_speed > 0) &&
               (clock_speed <= 4000000));

  /* CR2 Configuration.*/
  dp->CR2 &= (uint16_t)~I2C_CR2_FREQ;
 80029b8:	6051      	str	r1, [r2, #4]
  dp->CR2 |= (uint16_t)I2C_CLK_FREQ;
 80029ba:	f8d2 e004 	ldr.w	lr, [r2, #4]

  /* CCR Configuration.*/
  regCCR = 0;
  clock_div = I2C_CCR_CCR;

  if (clock_speed <= 100000) {
 80029be:	f248 61a0 	movw	r1, #34464	; 0x86a0
 80029c2:	f2c0 0101 	movt	r1, #1
               (clock_speed > 0) &&
               (clock_speed <= 4000000));

  /* CR2 Configuration.*/
  dp->CR2 &= (uint16_t)~I2C_CR2_FREQ;
  dp->CR2 |= (uint16_t)I2C_CLK_FREQ;
 80029c6:	f04e 0e18 	orr.w	lr, lr, #24

  /* CCR Configuration.*/
  regCCR = 0;
  clock_div = I2C_CCR_CCR;

  if (clock_speed <= 100000) {
 80029ca:	428b      	cmp	r3, r1
               (clock_speed > 0) &&
               (clock_speed <= 4000000));

  /* CR2 Configuration.*/
  dp->CR2 &= (uint16_t)~I2C_CR2_FREQ;
  dp->CR2 |= (uint16_t)I2C_CLK_FREQ;
 80029cc:	f8c2 e004 	str.w	lr, [r2, #4]

  /* CCR Configuration.*/
  regCCR = 0;
  clock_div = I2C_CCR_CCR;

  if (clock_speed <= 100000) {
 80029d0:	f340 8148 	ble.w	8002c64 <main+0x764>
    regCCR |= (clock_div & I2C_CCR_CCR);

    /* Sets the Maximum Rise Time for standard mode.*/
    dp->TRISE = I2C_CLK_FREQ + 1;
  }
  else if (clock_speed <= 400000) {
 80029d4:	f44f 51d4 	mov.w	r1, #6784	; 0x1a80
 80029d8:	f2c0 0106 	movt	r1, #6
 80029dc:	428b      	cmp	r3, r1
 80029de:	dc19      	bgt.n	8002a14 <main+0x514>
    /* Configure clock_div in fast mode.*/
    osalDbgAssert((duty == FAST_DUTY_CYCLE_2) ||
                  (duty == FAST_DUTY_CYCLE_16_9),
                  "invalid fast mode duty cycle");

    if (duty == FAST_DUTY_CYCLE_2) {
 80029e0:	2d02      	cmp	r5, #2
 80029e2:	f000 814b 	beq.w	8002c7c <main+0x77c>
      /* Fast mode clock_div calculate: Tlow/Thigh = 2/1.*/
      osalDbgAssert((STM32_PCLK1 % (clock_speed * 3)) == 0,
                    "PCLK1 must be divided without remainder");
      clock_div = (uint16_t)(STM32_PCLK1 / (clock_speed * 3));
    }
    else if (duty == FAST_DUTY_CYCLE_16_9) {
 80029e6:	2d03      	cmp	r5, #3
      /* Fast mode clock_div calculate: Tlow/Thigh = 16/9.*/
      osalDbgAssert((STM32_PCLK1 % (clock_speed * 25)) == 0,
                    "PCLK1 must be divided without remainder");
      clock_div = (uint16_t)(STM32_PCLK1 / (clock_speed * 25));
 80029e8:	bf01      	itttt	eq
 80029ea:	f44f 5158 	moveq.w	r1, #13824	; 0x3600
 80029ee:	eb03 0383 	addeq.w	r3, r3, r3, lsl #2
 80029f2:	f2c0 116e 	movteq	r1, #366	; 0x16e
 80029f6:	eb03 0383 	addeq.w	r3, r3, r3, lsl #2
 80029fa:	bf01      	itttt	eq
 80029fc:	fb91 f1f3 	sdiveq	r1, r1, r3
 8002a00:	ea6f 4781 	mvneq.w	r7, r1, lsl #18
 8002a04:	ea6f 4797 	mvneq.w	r7, r7, lsr #18
 8002a08:	b2bf      	uxtheq	r7, r7
      /* Fast mode clock_div calculate: Tlow/Thigh = 2/1.*/
      osalDbgAssert((STM32_PCLK1 % (clock_speed * 3)) == 0,
                    "PCLK1 must be divided without remainder");
      clock_div = (uint16_t)(STM32_PCLK1 / (clock_speed * 3));
    }
    else if (duty == FAST_DUTY_CYCLE_16_9) {
 8002a0a:	bf18      	it	ne
 8002a0c:	f648 77ff 	movwne	r7, #36863	; 0x8fff
    osalDbgAssert(clock_div >= 0x01,
                  "clock divider less then 0x04 not allowed");
    regCCR |= (I2C_CCR_FS | (clock_div & I2C_CCR_CCR));

    /* Sets the Maximum Rise Time for fast mode.*/
    dp->TRISE = (I2C_CLK_FREQ * 300 / 1000) + 1;
 8002a10:	2308      	movs	r3, #8
 8002a12:	6213      	str	r3, [r2, #32]
  }

  osalDbgAssert((clock_div <= I2C_CCR_CCR), "the selected clock is too low");

  dp->CCR = regCCR;
 8002a14:	61d7      	str	r7, [r2, #28]
  I2C_TypeDef *dp = i2cp->i2c;
  i2copmode_t opmode = i2cp->config->op_mode;
  uint16_t regCR1;

  regCR1 = dp->CR1;
  switch (opmode) {
 8002a16:	7801      	ldrb	r1, [r0, #0]
static void i2c_lld_set_opmode(I2CDriver *i2cp) {
  I2C_TypeDef *dp = i2cp->i2c;
  i2copmode_t opmode = i2cp->config->op_mode;
  uint16_t regCR1;

  regCR1 = dp->CR1;
 8002a18:	6813      	ldr	r3, [r2, #0]
  switch (opmode) {
 8002a1a:	2902      	cmp	r1, #2
static void i2c_lld_set_opmode(I2CDriver *i2cp) {
  I2C_TypeDef *dp = i2cp->i2c;
  i2copmode_t opmode = i2cp->config->op_mode;
  uint16_t regCR1;

  regCR1 = dp->CR1;
 8002a1c:	b29b      	uxth	r3, r3
  switch (opmode) {
 8002a1e:	f000 811b 	beq.w	8002c58 <main+0x758>
 8002a22:	2903      	cmp	r1, #3
  case OPMODE_SMBUS_DEVICE:
    regCR1 |= I2C_CR1_SMBUS;
    regCR1 &= (uint16_t)~(I2C_CR1_SMBTYPE);
    break;
  case OPMODE_SMBUS_HOST:
    regCR1 |= (I2C_CR1_SMBUS|I2C_CR1_SMBTYPE);
 8002a24:	bf08      	it	eq
 8002a26:	f043 030a 	orreq.w	r3, r3, #10
  I2C_TypeDef *dp = i2cp->i2c;
  i2copmode_t opmode = i2cp->config->op_mode;
  uint16_t regCR1;

  regCR1 = dp->CR1;
  switch (opmode) {
 8002a2a:	d005      	beq.n	8002a38 <main+0x538>
 8002a2c:	2901      	cmp	r1, #1
  case OPMODE_I2C:
    regCR1 &= (uint16_t)~(I2C_CR1_SMBUS|I2C_CR1_SMBTYPE);
 8002a2e:	bf02      	ittt	eq
 8002a30:	f023 030a 	biceq.w	r3, r3, #10
 8002a34:	041b      	lsleq	r3, r3, #16
 8002a36:	0c1b      	lsreq	r3, r3, #16
    break;
  case OPMODE_SMBUS_HOST:
    regCR1 |= (I2C_CR1_SMBUS|I2C_CR1_SMBTYPE);
    break;
  }
  dp->CR1 = regCR1;
 8002a38:	6013      	str	r3, [r2, #0]
  /* Setup I2C parameters.*/
  i2c_lld_set_clock(i2cp);
  i2c_lld_set_opmode(i2cp);

  /* Ready to go.*/
  dp->CR1 |= I2C_CR1_PE;
 8002a3a:	6833      	ldr	r3, [r6, #0]
  i2c_lld_start(i2cp);
  i2cp->state = I2C_READY;
 8002a3c:	2202      	movs	r2, #2
 8002a3e:	f043 0301 	orr.w	r3, r3, #1
 8002a42:	6033      	str	r3, [r6, #0]
 8002a44:	2300      	movs	r3, #0
 8002a46:	7022      	strb	r2, [r4, #0]
 8002a48:	f383 8811 	msr	BASEPRI, r3
	palSetPadMode(GPIOA, 2, PAL_MODE_STM32_ALTERNATE_PUSHPULL);
	palSetPadMode(GPIOA, 3, PAL_MODE_STM32_ALTERNATE_PUSHPULL);
*/


  palSetPadMode(GPIOB, 6, PAL_MODE_STM32_ALTERNATE_OPENDRAIN);
 8002a4c:	2040      	movs	r0, #64	; 0x40
 8002a4e:	f7ff f8bf 	bl	8001bd0 <_pal_lld_setgroupmode.constprop.4>
  palSetPadMode(GPIOB, 7, PAL_MODE_STM32_ALTERNATE_OPENDRAIN);
 8002a52:	2080      	movs	r0, #128	; 0x80
 8002a54:	f7ff f8bc 	bl	8001bd0 <_pal_lld_setgroupmode.constprop.4>
 8002a58:	f640 2630 	movw	r6, #2608	; 0xa30
               (timeout != TIME_IMMEDIATE));

  osalDbgAssert(i2cp->state == I2C_READY, "not ready");

  osalSysLock();
  i2cp->errors = I2C_NO_ERROR;
 8002a5c:	4a8e      	ldr	r2, [pc, #568]	; (8002c98 <main+0x798>)
 8002a5e:	f2c2 0600 	movt	r6, #8192	; 0x2000
 8002a62:	f640 07d0 	movw	r7, #2256	; 0x8d0
 8002a66:	f640 2928 	movw	r9, #2600	; 0xa28
 8002a6a:	46b2      	mov	sl, r6
 8002a6c:	f1a2 051c 	sub.w	r5, r2, #28
 8002a70:	f2c2 0700 	movt	r7, #8192	; 0x2000
 8002a74:	f2c2 0900 	movt	r9, #8192	; 0x2000
	  msg_t status = MSG_OK;
	//  systime_t tmo = MS2ST(4);
	  short result;	
	  
	  /* configure gyroscope */
	  SDA_tx_data[0] = ULTS_CTRL_REG1;
 8002a78:	2100      	movs	r1, #0
	  SDA_tx_data[1] = MEASURE_CENTI ;
 8002a7a:	2251      	movs	r2, #81	; 0x51
		SDA_value[0]= REGISTER_POINT;
 8002a7c:	2302      	movs	r3, #2
 8002a7e:	f889 3000 	strb.w	r3, [r9]
	  msg_t status = MSG_OK;
	//  systime_t tmo = MS2ST(4);
	  short result;	
	  
	  /* configure gyroscope */
	  SDA_tx_data[0] = ULTS_CTRL_REG1;
 8002a82:	7039      	strb	r1, [r7, #0]
	  SDA_tx_data[1] = MEASURE_CENTI ;
 8002a84:	707a      	strb	r2, [r7, #1]
 8002a86:	2320      	movs	r3, #32
 8002a88:	f383 8811 	msr	BASEPRI, r3
 * @api
 */
void chMtxLock(mutex_t *mp) {

  chSysLock();
  chMtxLockS(mp);
 8002a8c:	4883      	ldr	r0, [pc, #524]	; (8002c9c <main+0x79c>)
 8002a8e:	f7ff fcc7 	bl	8002420 <chMtxLockS>
 8002a92:	2300      	movs	r3, #0
 8002a94:	f383 8811 	msr	BASEPRI, r3
 8002a98:	2320      	movs	r3, #32
 8002a9a:	f383 8811 	msr	BASEPRI, r3
  i2cp->state = I2C_ACTIVE_TX;
  rdymsg = i2c_lld_master_transmit_timeout(i2cp, addr, txbuf, txbytes,
 8002a9e:	f640 2058 	movw	r0, #2648	; 0xa58
 8002aa2:	f640 01d0 	movw	r1, #2256	; 0x8d0

  osalDbgAssert(i2cp->state == I2C_READY, "not ready");

  osalSysLock();
  i2cp->errors = I2C_NO_ERROR;
  i2cp->state = I2C_ACTIVE_TX;
 8002aa6:	2303      	movs	r3, #3
               (timeout != TIME_IMMEDIATE));

  osalDbgAssert(i2cp->state == I2C_READY, "not ready");

  osalSysLock();
  i2cp->errors = I2C_NO_ERROR;
 8002aa8:	f04f 0e00 	mov.w	lr, #0
  i2cp->state = I2C_ACTIVE_TX;
  rdymsg = i2c_lld_master_transmit_timeout(i2cp, addr, txbuf, txbytes,
 8002aac:	f2c2 0100 	movt	r1, #8192	; 0x2000
 8002ab0:	2202      	movs	r2, #2
 8002ab2:	f2c2 0000 	movt	r0, #8192	; 0x2000

  osalDbgAssert(i2cp->state == I2C_READY, "not ready");

  osalSysLock();
  i2cp->errors = I2C_NO_ERROR;
  i2cp->state = I2C_ACTIVE_TX;
 8002ab6:	7023      	strb	r3, [r4, #0]
               (timeout != TIME_IMMEDIATE));

  osalDbgAssert(i2cp->state == I2C_READY, "not ready");

  osalSysLock();
  i2cp->errors = I2C_NO_ERROR;
 8002ab8:	f8c4 e008 	str.w	lr, [r4, #8]
  i2cp->state = I2C_ACTIVE_TX;
  rdymsg = i2c_lld_master_transmit_timeout(i2cp, addr, txbuf, txbytes,
 8002abc:	f7fe fe88 	bl	80017d0 <i2c_lld_master_transmit_timeout.constprop.11>
                                           rxbuf, rxbytes, timeout);
  if (rdymsg == MSG_TIMEOUT) {
 8002ac0:	3001      	adds	r0, #1
    i2cp->state = I2C_LOCKED;
 8002ac2:	bf0c      	ite	eq
 8002ac4:	2305      	moveq	r3, #5
  }
  else {
    i2cp->state = I2C_READY;
 8002ac6:	2302      	movne	r3, #2
 8002ac8:	702b      	strb	r3, [r5, #0]
 8002aca:	2300      	movs	r3, #0
 8002acc:	f383 8811 	msr	BASEPRI, r3
 * @api
 */
static inline void osalMutexUnlock(mutex_t *mp) {

#if CH_CFG_USE_MUTEXES
  chMtxUnlock(mp);
 8002ad0:	f7fe fec6 	bl	8001860 <chMtxUnlock.constprop.19>
	  /* sending  */
	  i2cAcquireBus(&I2CD1);
	  status = i2cMasterTransmitTimeout(&I2CD1, ADDRESS_SFR02, SDA_tx_data, 2, NULL, 0, TIME_INFINITE);
	  i2cReleaseBus(&I2CD1);

	  chThdSleepMilliseconds(70);
 8002ad4:	2046      	movs	r0, #70	; 0x46
 8002ad6:	f7fe fcfb 	bl	80014d0 <chThdSleep>
 8002ada:	2320      	movs	r3, #32
 8002adc:	f383 8811 	msr	BASEPRI, r3
 8002ae0:	486e      	ldr	r0, [pc, #440]	; (8002c9c <main+0x79c>)
 8002ae2:	f7ff fc9d 	bl	8002420 <chMtxLockS>
 8002ae6:	2300      	movs	r3, #0
 8002ae8:	f383 8811 	msr	BASEPRI, r3
 8002aec:	2320      	movs	r3, #32
 8002aee:	f383 8811 	msr	BASEPRI, r3
  osalDbgAssert(i2cp->state == I2C_READY, "not ready");

  osalSysLock();
  i2cp->errors = I2C_NO_ERROR;
  i2cp->state = I2C_ACTIVE_TX;
  rdymsg = i2c_lld_master_transmit_timeout(i2cp, addr, txbuf, txbytes,
 8002af2:	f640 2058 	movw	r0, #2648	; 0xa58
 8002af6:	f640 2128 	movw	r1, #2600	; 0xa28

  osalDbgAssert(i2cp->state == I2C_READY, "not ready");

  osalSysLock();
  i2cp->errors = I2C_NO_ERROR;
  i2cp->state = I2C_ACTIVE_TX;
 8002afa:	2303      	movs	r3, #3
               (timeout != TIME_IMMEDIATE));

  osalDbgAssert(i2cp->state == I2C_READY, "not ready");

  osalSysLock();
  i2cp->errors = I2C_NO_ERROR;
 8002afc:	f04f 0e00 	mov.w	lr, #0
  i2cp->state = I2C_ACTIVE_TX;
  rdymsg = i2c_lld_master_transmit_timeout(i2cp, addr, txbuf, txbytes,
 8002b00:	f2c2 0100 	movt	r1, #8192	; 0x2000
 8002b04:	2201      	movs	r2, #1
 8002b06:	f2c2 0000 	movt	r0, #8192	; 0x2000

  osalDbgAssert(i2cp->state == I2C_READY, "not ready");

  osalSysLock();
  i2cp->errors = I2C_NO_ERROR;
  i2cp->state = I2C_ACTIVE_TX;
 8002b0a:	7023      	strb	r3, [r4, #0]
               (timeout != TIME_IMMEDIATE));

  osalDbgAssert(i2cp->state == I2C_READY, "not ready");

  osalSysLock();
  i2cp->errors = I2C_NO_ERROR;
 8002b0c:	f8c4 e008 	str.w	lr, [r4, #8]
  i2cp->state = I2C_ACTIVE_TX;
  rdymsg = i2c_lld_master_transmit_timeout(i2cp, addr, txbuf, txbytes,
 8002b10:	f7fe fe5e 	bl	80017d0 <i2c_lld_master_transmit_timeout.constprop.11>
                                           rxbuf, rxbytes, timeout);
  if (rdymsg == MSG_TIMEOUT) {
 8002b14:	3001      	adds	r0, #1
    i2cp->state = I2C_LOCKED;
 8002b16:	bf0c      	ite	eq
 8002b18:	2305      	moveq	r3, #5
  }
  else {
    i2cp->state = I2C_READY;
 8002b1a:	2302      	movne	r3, #2
 8002b1c:	702b      	strb	r3, [r5, #0]
 8002b1e:	2300      	movs	r3, #0
 8002b20:	f383 8811 	msr	BASEPRI, r3
 8002b24:	f7fe fe9c 	bl	8001860 <chMtxUnlock.constprop.19>
 8002b28:	2320      	movs	r3, #32
 8002b2a:	f383 8811 	msr	BASEPRI, r3
 8002b2e:	485b      	ldr	r0, [pc, #364]	; (8002c9c <main+0x79c>)
 8002b30:	f7ff fc76 	bl	8002420 <chMtxLockS>
 8002b34:	2300      	movs	r3, #0
 8002b36:	f383 8811 	msr	BASEPRI, r3
 8002b3a:	2320      	movs	r3, #32
 8002b3c:	f383 8811 	msr	BASEPRI, r3

  osalDbgAssert(i2cp->state == I2C_READY, "not ready");

  osalSysLock();
  i2cp->errors = I2C_NO_ERROR;
  i2cp->state = I2C_ACTIVE_RX;
 8002b40:	2104      	movs	r1, #4

  /* Resetting error flags for this transfer.*/
  i2cp->errors = I2C_NO_ERROR;

  /* Initializes driver fields, LSB = 1 -> receive.*/
  i2cp->addr = (addr << 1) | 0x01;
 8002b42:	22e1      	movs	r2, #225	; 0xe1
               (timeout != TIME_IMMEDIATE));

  osalDbgAssert(i2cp->state == I2C_READY, "not ready");

  osalSysLock();
  i2cp->errors = I2C_NO_ERROR;
 8002b44:	2300      	movs	r3, #0
 8002b46:	8422      	strh	r2, [r4, #32]
  i2cp->state = I2C_ACTIVE_RX;
 8002b48:	7021      	strb	r1, [r4, #0]
               (timeout != TIME_IMMEDIATE));

  osalDbgAssert(i2cp->state == I2C_READY, "not ready");

  osalSysLock();
  i2cp->errors = I2C_NO_ERROR;
 8002b4a:	60a3      	str	r3, [r4, #8]
 * @notapi
 */
msg_t i2c_lld_master_receive_timeout(I2CDriver *i2cp, i2caddr_t addr,
                                     uint8_t *rxbuf, size_t rxbytes,
                                     systime_t timeout) {
  I2C_TypeDef *dp = i2cp->i2c;
 8002b4c:	6b62      	ldr	r2, [r4, #52]	; 0x34
 8002b4e:	f383 8811 	msr	BASEPRI, r3

  /* Releases the lock from high level driver.*/
  osalSysUnlock();

  /* RX DMA setup.*/
  dmaStreamSetMode(i2cp->dmarx, i2cp->rxdmamode);
 8002b52:	6aeb      	ldr	r3, [r5, #44]	; 0x2c
 8002b54:	6a69      	ldr	r1, [r5, #36]	; 0x24
 8002b56:	685b      	ldr	r3, [r3, #4]
  dmaStreamSetMemory0(i2cp->dmarx, rxbuf);
  dmaStreamSetTransactionSize(i2cp->dmarx, rxbytes);
 8002b58:	2402      	movs	r4, #2

  /* Releases the lock from high level driver.*/
  osalSysUnlock();

  /* RX DMA setup.*/
  dmaStreamSetMode(i2cp->dmarx, i2cp->rxdmamode);
 8002b5a:	6019      	str	r1, [r3, #0]
 8002b5c:	f04f 4080 	mov.w	r0, #1073741824	; 0x40000000
  dmaStreamSetMemory0(i2cp->dmarx, rxbuf);
 8002b60:	f8c3 a00c 	str.w	sl, [r3, #12]
  dmaStreamSetTransactionSize(i2cp->dmarx, rxbytes);
 8002b64:	605c      	str	r4, [r3, #4]
 8002b66:	6a43      	ldr	r3, [r0, #36]	; 0x24

  /* Releases the lock from high level driver.*/
  osalSysUnlock();

  /* RX DMA setup.*/
  dmaStreamSetMode(i2cp->dmarx, i2cp->rxdmamode);
 8002b68:	f640 2458 	movw	r4, #2648	; 0xa58
 8002b6c:	fa1f fe83 	uxth.w	lr, r3
 8002b70:	f2c2 0400 	movt	r4, #8192	; 0x2000
 8002b74:	2120      	movs	r1, #32
 8002b76:	f04f 0c00 	mov.w	ip, #0
 8002b7a:	e001      	b.n	8002b80 <main+0x680>
 8002b7c:	f38c 8811 	msr	BASEPRI, ip
 8002b80:	f381 8811 	msr	BASEPRI, r1
  while (true) {
    osalSysLock();

    /* If the bus is not busy then the operation can continue, note, the
       loop is exited in the locked state.*/
    if (!(dp->SR2 & I2C_SR2_BUSY) && !(dp->CR1 & I2C_CR1_STOP))
 8002b84:	6993      	ldr	r3, [r2, #24]
 8002b86:	079b      	lsls	r3, r3, #30
 8002b88:	d402      	bmi.n	8002b90 <main+0x690>
 8002b8a:	6813      	ldr	r3, [r2, #0]
 8002b8c:	059b      	lsls	r3, r3, #22
 8002b8e:	d54b      	bpl.n	8002c28 <main+0x728>
 8002b90:	6a43      	ldr	r3, [r0, #36]	; 0x24
 8002b92:	ebce 0303 	rsb	r3, lr, r3
      break;

    /* If the system time went outside the allowed window then a timeout
       condition is returned.*/
    if (!osalOsIsTimeWithinX(osalOsGetSystemTimeX(), start, end))
 8002b96:	b29b      	uxth	r3, r3
 8002b98:	2b31      	cmp	r3, #49	; 0x31
 8002b9a:	d9ef      	bls.n	8002b7c <main+0x67c>
  i2cp->state = I2C_ACTIVE_RX;
  rdymsg = i2c_lld_master_receive_timeout(i2cp, addr, rxbuf, rxbytes, timeout);
  if (rdymsg == MSG_TIMEOUT) {
    i2cp->state = I2C_LOCKED;
 8002b9c:	2305      	movs	r3, #5
 8002b9e:	702b      	strb	r3, [r5, #0]
 8002ba0:	2300      	movs	r3, #0
 8002ba2:	f383 8811 	msr	BASEPRI, r3
 8002ba6:	f7fe fe5b 	bl	8001860 <chMtxUnlock.constprop.19>
	  i2cAcquireBus(&I2CD1);
	  status = i2cMasterTransmitTimeout(&I2CD1, ADDRESS_SFR02, NULL, 0, SDA_rx_data, 2, TIME_INFINITE);
	  i2cReleaseBus(&I2CD1);
*/

	  result = (SDA_rx_data[0]<<8) | SDA_rx_data[1];
 8002baa:	7873      	ldrb	r3, [r6, #1]
 8002bac:	7832      	ldrb	r2, [r6, #0]
		
		chprintf((BaseChannel *)&SD2, "El resultado es= %d\n\r",result);
 8002bae:	f640 0050 	movw	r0, #2128	; 0x850
	  i2cAcquireBus(&I2CD1);
	  status = i2cMasterTransmitTimeout(&I2CD1, ADDRESS_SFR02, NULL, 0, SDA_rx_data, 2, TIME_INFINITE);
	  i2cReleaseBus(&I2CD1);
*/

	  result = (SDA_rx_data[0]<<8) | SDA_rx_data[1];
 8002bb2:	ea43 2202 	orr.w	r2, r3, r2, lsl #8
		
		chprintf((BaseChannel *)&SD2, "El resultado es= %d\n\r",result);
 8002bb6:	f642 519c 	movw	r1, #11676	; 0x2d9c
 8002bba:	b212      	sxth	r2, r2
 8002bbc:	f6c0 0100 	movt	r1, #2048	; 0x800
 8002bc0:	f2c2 0000 	movt	r0, #8192	; 0x2000
 8002bc4:	f7ff f834 	bl	8001c30 <chprintf.constprop.0>
		//sdPut(&SD2,result);
		chThdSleepMilliseconds(500);
 8002bc8:	f44f 70fa 	mov.w	r0, #500	; 0x1f4
 8002bcc:	f7fe fc80 	bl	80014d0 <chThdSleep>
		//i2cStart(&I2CD1, &i2cfg1);
  	Sfr02Start();

		

		chThdSleepMilliseconds(500);
 8002bd0:	f44f 70fa 	mov.w	r0, #500	; 0x1f4
 8002bd4:	f7fe fc7c 	bl	80014d0 <chThdSleep>
 8002bd8:	2320      	movs	r3, #32
 8002bda:	f383 8811 	msr	BASEPRI, r3
 8002bde:	2200      	movs	r2, #0
 */
bool sdGetWouldBlock(SerialDriver *sdp) {
  bool b;

  osalSysLock();
  b = iqIsEmptyI(&sdp->iqueue);
 8002be0:	f8d8 3014 	ldr.w	r3, [r8, #20]
 8002be4:	f382 8811 	msr	BASEPRI, r2
		if(!sdGetWouldBlock(&SD3)){
 8002be8:	b19b      	cbz	r3, 8002c12 <main+0x712>
		uint8_t c = sdGet(&SD3);
 8002bea:	f64f 71ff 	movw	r1, #65535	; 0xffff
 8002bee:	482c      	ldr	r0, [pc, #176]	; (8002ca0 <main+0x7a0>)
 8002bf0:	f7fe fc96 	bl	8001520 <iqGetTimeout>
		chprintf((BaseChannel *)&SD2, "El valor es= %d\n\r",c);
 8002bf4:	f642 51b4 	movw	r1, #11700	; 0x2db4
 8002bf8:	b2c2      	uxtb	r2, r0
 8002bfa:	f640 0050 	movw	r0, #2128	; 0x850
 8002bfe:	f6c0 0100 	movt	r1, #2048	; 0x800
 8002c02:	f2c2 0000 	movt	r0, #8192	; 0x2000
 8002c06:	f7ff f813 	bl	8001c30 <chprintf.constprop.0>
 8002c0a:	e735      	b.n	8002a78 <main+0x578>
  chDbgCheck(tp != NULL);
  chDbgAssert((tp->state != CH_STATE_READY) &&
              (tp->state != CH_STATE_FINAL),
              "invalid state");

  tp->state = CH_STATE_READY;
 8002c0c:	f88e c020 	strb.w	ip, [lr, #32]
 8002c10:	e7fe      	b.n	8002c10 <main+0x710>
		}else{
		chprintf((BaseChannel *)&SD2, "Tal ves deberias considerar ser taxista :'v \n\r");
 8002c12:	f640 0050 	movw	r0, #2128	; 0x850
 8002c16:	f642 51c8 	movw	r1, #11720	; 0x2dc8
 8002c1a:	f6c0 0100 	movt	r1, #2048	; 0x800
 8002c1e:	f2c2 0000 	movt	r0, #8192	; 0x2000
 8002c22:	f7ff f805 	bl	8001c30 <chprintf.constprop.0>
 8002c26:	e727      	b.n	8002a78 <main+0x578>

    osalSysUnlock();
  }

  /* Starts the operation.*/
  dp->CR2 |= I2C_CR2_ITEVTEN;
 8002c28:	6851      	ldr	r1, [r2, #4]
 8002c2a:	f8db 3018 	ldr.w	r3, [fp, #24]
 8002c2e:	f441 7100 	orr.w	r1, r1, #512	; 0x200
 8002c32:	6051      	str	r1, [r2, #4]
  dp->CR1 |= I2C_CR1_START | I2C_CR1_ACK;
 8002c34:	6811      	ldr	r1, [r2, #0]
    if (chVTIsArmedI(&vt)) {
      chVTDoResetI(&vt);
    }
  }
  else {
    chSchGoSleepS(newstate);
 8002c36:	2003      	movs	r0, #3
 8002c38:	f441 61a0 	orr.w	r1, r1, #1280	; 0x500
 8002c3c:	6011      	str	r1, [r2, #0]
  if (TIME_IMMEDIATE == timeout) {
    return MSG_TIMEOUT;
  }

  *trp = tp;
  tp->u.wttrp = trp;
 8002c3e:	4a16      	ldr	r2, [pc, #88]	; (8002c98 <main+0x798>)

  if (TIME_IMMEDIATE == timeout) {
    return MSG_TIMEOUT;
  }

  *trp = tp;
 8002c40:	61eb      	str	r3, [r5, #28]
  tp->u.wttrp = trp;
 8002c42:	625a      	str	r2, [r3, #36]	; 0x24
 8002c44:	f7ff fafc 	bl	8002240 <chSchGoSleepS>
  }

  return currp->u.rdymsg;
 8002c48:	f8db 3018 	ldr.w	r3, [fp, #24]

  osalSysLock();
  i2cp->errors = I2C_NO_ERROR;
  i2cp->state = I2C_ACTIVE_RX;
  rdymsg = i2c_lld_master_receive_timeout(i2cp, addr, rxbuf, rxbytes, timeout);
  if (rdymsg == MSG_TIMEOUT) {
 8002c4c:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 8002c4e:	3301      	adds	r3, #1
 8002c50:	d0a4      	beq.n	8002b9c <main+0x69c>
    i2cp->state = I2C_LOCKED;
  }
  else {
    i2cp->state = I2C_READY;
 8002c52:	2302      	movs	r3, #2
 8002c54:	702b      	strb	r3, [r5, #0]
 8002c56:	e7a3      	b.n	8002ba0 <main+0x6a0>
  case OPMODE_I2C:
    regCR1 &= (uint16_t)~(I2C_CR1_SMBUS|I2C_CR1_SMBTYPE);
    break;
  case OPMODE_SMBUS_DEVICE:
    regCR1 |= I2C_CR1_SMBUS;
    regCR1 &= (uint16_t)~(I2C_CR1_SMBTYPE);
 8002c58:	f64f 71f7 	movw	r1, #65527	; 0xfff7
 8002c5c:	4019      	ands	r1, r3
 8002c5e:	f041 0302 	orr.w	r3, r1, #2
 8002c62:	e6e9      	b.n	8002a38 <main+0x538>
    osalDbgAssert(duty == STD_DUTY_CYCLE, "invalid standard mode duty cycle");

    /* Standard mode clock_div calculate: Tlow/Thigh = 1/1.*/
    osalDbgAssert((STM32_PCLK1 % (clock_speed * 2)) == 0,
                  "PCLK1 must be divisible without remainder");
    clock_div = (uint16_t)(STM32_PCLK1 / (clock_speed * 2));
 8002c64:	f44f 5158 	mov.w	r1, #13824	; 0x3600
 8002c68:	005b      	lsls	r3, r3, #1
 8002c6a:	f2c0 116e 	movt	r1, #366	; 0x16e
 8002c6e:	fb91 f1f3 	sdiv	r1, r1, r3
    osalDbgAssert(clock_div >= 0x04,
                  "clock divider less then 0x04 not allowed");
    regCCR |= (clock_div & I2C_CCR_CCR);

    /* Sets the Maximum Rise Time for standard mode.*/
    dp->TRISE = I2C_CLK_FREQ + 1;
 8002c72:	2319      	movs	r3, #25
 8002c74:	f3c1 070b 	ubfx	r7, r1, #0, #12
 8002c78:	6213      	str	r3, [r2, #32]
 8002c7a:	e6cb      	b.n	8002a14 <main+0x514>

    if (duty == FAST_DUTY_CYCLE_2) {
      /* Fast mode clock_div calculate: Tlow/Thigh = 2/1.*/
      osalDbgAssert((STM32_PCLK1 % (clock_speed * 3)) == 0,
                    "PCLK1 must be divided without remainder");
      clock_div = (uint16_t)(STM32_PCLK1 / (clock_speed * 3));
 8002c7c:	f44f 5158 	mov.w	r1, #13824	; 0x3600
 8002c80:	eb03 0343 	add.w	r3, r3, r3, lsl #1
 8002c84:	f2c0 116e 	movt	r1, #366	; 0x16e
 8002c88:	fb91 f1f3 	sdiv	r1, r1, r3
 8002c8c:	ea6f 4741 	mvn.w	r7, r1, lsl #17
 8002c90:	ea6f 4757 	mvn.w	r7, r7, lsr #17
 8002c94:	b2bf      	uxth	r7, r7
 8002c96:	e6bb      	b.n	8002a10 <main+0x510>
 8002c98:	20000a74 	.word	0x20000a74
 8002c9c:	20000a64 	.word	0x20000a64
 8002ca0:	20000a9c 	.word	0x20000a9c
 8002ca4:	08002e88 	.word	0x08002e88
 8002ca8:	f3af 8000 	nop.w
 8002cac:	f3af 8000 	nop.w
